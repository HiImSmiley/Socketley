.\" Socketley Manual Page
.\" Copyright (c) 2025
.\"
.TH SOCKETLEY 1 "2026" "socketley" "User Commands"
.SH NAME
socketley \- manage network runtimes (servers, clients, proxies, Redis-compatible caches) in Docker-like style
.SH SYNOPSIS
.B socketley
.I command
.RI [ options ]
.br
.B socketley
.B daemon
.br
.B socketley
.B daemon
.BI \-\-name " name"
.RB [ \-\-cluster
.IR dir ]
.br
.B socketley
.B cluster
.RI [ ls | ps | group | show | stats | watch ]
.br
.B socketley
.B create
.I type name
.RI [ flags ]
.br
.B socketley
.B add
.I path
.RB [ \-\-name
.IR name ]
.RB [ \-s ]
.br
.B socketley
.B start
.IR name | pattern ...
.RB [ \-i ]
.br
.B socketley
.B stop
.IR name | pattern ...
.br
.B socketley
.B remove
.IR name | pattern ...
.br
.B socketley
.B stats
.IR name | pattern ...
.br
.B socketley
.B reload
.IR name | pattern ...
.br
.B socketley
.B reload-lua
.IR name | pattern ...
.br
.B socketley
.B show
.IR name | pattern ...
.br
.B socketley
.B edit
.I name
.RI [ flags ]
.br
.B socketley
.B edit
.I name
.RB [ \-r | \-\-reload ]
.br
.B socketley
.B ls
.br
.B socketley
.B ps
.br
.B socketley
.B owner
.I name
.br
.B socketley
.B \-\-lua
.I lua_file
.SH DESCRIPTION
.B socketley
is a high-performance Linux daemon and CLI that manages network runtimes
(servers, clients, proxies, Redis-compatible caches) in a Docker-like style \(em
with clustering, TLS, WebSocket, Lua scripting, and io_uring async I/O.
.SH COMMANDS
.TP
.B daemon
Start the socketley daemon.
When installed system-wide (via .deb package or install.sh), the daemon is
managed by systemd and starts automatically \(em you do not need to run this
command manually. Use
.B systemctl start socketley
or
.B systemctl enable socketley
to control the service.
.PP
When running from the build directory (development mode), start the daemon
manually:
.B ./bin/Release/socketley daemon &
.PP
Creates IPC socket at /run/socketley/socketley.sock (system install) or
/tmp/socketley.sock (development mode).
On startup, restores persisted runtime configurations. Runtimes that were
running when the daemon last stopped are auto-started.
.TP
.BI "daemon \-\-name " "name " "[\-\-cluster " "dir" "]"
Configure the running daemon for cluster mode. These flags are sent as IPC
commands to the already-running daemon (auto-started if not running).
.B \-\-name
sets the daemon's identity in the cluster.
.B \-\-cluster
enables cluster discovery on the given shared directory (see
.BR "CLUSTER MODE" ).
The name can be changed at any time; if cluster mode is active, the cluster
file is republished under the new name.
.RS
.PP
.nf
socketley daemon --name node1 --cluster /shared/cluster
socketley daemon --name new-name   # rename while cluster is active
.fi
.RE
.TP
.BI "create " "type name " "[flags]"
Create a new runtime instance.
.I type
can be: server, client, proxy, cache.
.I name
is a unique identifier for the runtime.
.TP
.BI "attach " "type name port " "[\-\-owner " "name" "]"
Register an external process as a runtime visible in
.BR ls / ps .
The daemon does NOT bind the port or forward any I/O — the external process
manages its own network connections. The runtime appears as running and can
be inspected or removed like any other runtime.
.RS
.TP
.I type
Runtime type: server, client, proxy, or cache.
.TP
.I name
Unique name for this external runtime.
.TP
.I port
Port number the external process is listening on (informational only).
.TP
.B \-\-owner \fIname\fR
Optional owner runtime name.
.RE
.TP
.BI "add " "path " "[\-\-name " "name" "] [\-s]"
Register and manage an external binary (built with the C++ SDK).
The daemon will fork+exec the binary and manage its full lifecycle:
auto-restart on crash, re-launch on daemon boot, and normal
start/stop/remove commands.
.RS
.TP
.I path
Path to the executable (must exist and be executable).
.TP
.B \-\-name \fIname\fR, \fB\-n\fR \fIname\fR
Name for the runtime. If omitted, derived from the binary's filename
(basename without extension).
.TP
.B \-s
Start immediately after adding.
.PP
The binary receives
.B SOCKETLEY_MANAGED=1
and
.B SOCKETLEY_NAME=\fIname\fR
environment variables. When using
.BR daemon_attach() ,
these cause the binary to re-attach to the existing runtime entry
and skip the atexit self-removal.
.PP
.nf
socketley add /usr/local/bin/myapp -s
socketley add /usr/local/bin/myapp --name chat
socketley stop chat
socketley start chat
socketley remove chat
.fi
.RE
.TP
.BI "start " "name|pattern" "... [\-i]"
Start one or more runtimes. Accepts multiple names, glob patterns
.RB ( * ", " ? ", " [] ),
or a mix. With
.BR * ,
starts all non-running runtimes.
.RS
.TP
.B \-i
Interactive mode. Starts the runtime and opens an interactive session.
For server: stdin is broadcast to clients, received messages appear on stdout.
For client: stdin is sent to server, received messages appear on stdout.
For cache: stdin accepts cache commands, responses appear on stdout (like redis-cli).
Not supported for proxy. Press Ctrl+C to detach (runtime continues running).
If the runtime is already running, attaches without restarting.
.RE
.TP
.BI "stop " "name|pattern" "..."
Stop one or more running runtimes. Accepts multiple names, glob patterns
.RB ( * ", " ? ", " [] ),
or a mix. With
.BR * ,
stops all running runtimes.
.TP
.BI "remove " "name|pattern" "..."
Remove one or more runtimes from the registry. Cannot be undone.
Accepts multiple names, glob patterns, or a mix. Running runtimes
are stopped first. With
.BR * ,
stops and removes all.
.TP
.BI "send " "name" " [message]"
Send a message to a running server or client runtime.
For servers, the message is broadcast to all connected clients.
For clients, the message is sent to the connected server.
Respects the runtime's mode setting (fails if mode is receive-only).
.PP
If no message is given, reads from stdin:
.nf
echo "hello" | socketley send myserver
cat data.txt | socketley send myclient
.fi
.TP
.BI "stats " "name|pattern" "..."
Display runtime statistics including total connections, messages processed,
bytes in/out, and type-specific counters. Accepts multiple names, glob
patterns, or a mix. With
.BR * ,
shows stats for all runtimes.
.TP
.BI "reload " "name|pattern" "..."
Restart one or more running runtimes (stop + start). Accepts multiple
names, glob patterns, or a mix. Non-running runtimes are skipped.
With
.BR * ,
restarts all running runtimes.
.TP
.BI "reload-lua " "name|pattern" "..."
Hot-reload the Lua script attached to one or more runtimes. The Lua
context is destroyed and re-created from the original script path.
Accepts multiple names, glob patterns, or a mix. Runtimes without
Lua scripts are skipped. With
.BR * ,
reloads Lua on all runtimes that have scripts loaded.
.TP
.BI "show " "name|pattern" "..."
Print runtime JSON configuration to stdout. Accepts multiple names,
glob patterns, or a mix. With
.BR * ,
prints all runtimes.
.TP
.BI "edit " "name " "[flags]"
Edit a runtime's configuration. When called with flags (e.g. \-p 9001),
applies changes directly like
.BR create .
When called without flags (or with only \-r/\-\-reload),
opens the runtime's JSON configuration in
.BR $VISUAL ,
.BR $EDITOR ,
or
.BR vim .
After saving, changes are validated and applied.
.TP
.BI "edit " "name " "\-r"
Interactive editor mode with auto-reload. After saving changes, the
runtime's Lua script is automatically hot-reloaded. Alias:
.BR \-\-reload .
.SS Edit: JSON Configuration Fields
The interactive editor opens a JSON file with the following fields.
Fields marked
.B (read-only)
are ignored on import. Fields marked
.B (requires restart)
cannot be changed while the runtime is running \(em stop the runtime first.
.PP
.B Identity fields:
.TS
l l.
name	Runtime name \fB(requires restart)\fR
id	6-char hex identifier (read-only, ignored on import)
type	Runtime type: server, client, proxy, cache (read-only, ignored on import)
was_running	Internal daemon state (ignored on import)
.TE
.PP
.B Common fields (all types):
.TS
l l l.
Field	Type	Description
_
port	number	Listener/connection port \fB(requires restart)\fR
log_file	string	State transition log file path
write_file	string	Message write file path
lua_script	string	Lua script path (absolute)
bash_output	bool	Output messages to stdout
bash_prefix	bool	Prefix messages with [name]
bash_timestamp	bool	Prefix messages with [HH:MM:SS]
max_connections	number	Max concurrent connections (0 = unlimited)
rate_limit	number	Messages/sec per connection (0 = unlimited)
global_rate_limit	number	Messages/sec across all connections (0 = unlimited)
idle_timeout	number	Close idle connections after N seconds (0 = disabled)
drain	bool	Graceful shutdown (flush writes before close)
tls	bool	Enable TLS \fB(requires restart)\fR
cert_path	string	TLS certificate file (PEM)
key_path	string	TLS private key file (PEM)
ca_path	string	TLS CA certificate file
target	string	Client target host:port \fB(requires restart)\fR
cache_name	string	Connected cache runtime name
group	string	Group tag for dynamic proxy discovery
.TE
.PP
.B Server fields:
.TS
l l l.
Field	Type	Description
_
mode	string	"inout", "in", "out", or "master"
udp	bool	Use UDP instead of TCP \fB(requires restart)\fR
master_pw	string	Static password for master mode
master_forward	bool	Forward non-master messages to master
.TE
.PP
.B Client fields:
.TS
l l l.
Field	Type	Description
_
mode	string	"inout", "in", or "out"
udp	bool	Use UDP instead of TCP \fB(requires restart)\fR
reconnect	number	Auto-reconnect max attempts (-1=off, 0=infinite)
.TE
.PP
.B Proxy fields:
.TS
l l l.
Field	Type	Description
_
protocol	string	"http" or "tcp" \fB(requires restart)\fR
strategy	string	"round-robin", "random", or "lua"
backends	array	List of backend addresses ["ip:port", "@group", ...]
.TE
.PP
.B Cache fields:
.TS
l l l.
Field	Type	Description
_
persistent_path	string	Persistence file path
cache_mode	string	"readonly", "readwrite", or "admin"
resp_forced	bool	Force RESP2 protocol \fB(requires restart)\fR
replicate_target	string	Leader host:port \fB(requires restart)\fR
max_memory	number	Max memory in bytes (0 = unlimited)
eviction	string	"noeviction", "allkeys-lru", "allkeys-random"
.TE
.PP
.B Example JSON (server):
.nf
{
    "name": "api",
    "id": "a1b2c3",
    "type": "server",
    "port": 9000,
    "was_running": true,
    "lua_script": "/home/user/handler.lua",
    "max_connections": 100,
    "rate_limit": 1000,
    "mode": "inout"
}
.fi
.TP
.B ls
List all runtimes (all states). Docker-style output with columns:
ID, NAME, TYPE, PORT, CONN (connections), OWNED BY, STATUS, CREATED.
.TP
.B ps
List only running runtimes. Same format as
.BR ls .
.TP
.BI "owner " "name"
Show ownership info for a runtime: parent name, children list, and
on_parent_stop policy (stop or remove).
.TP
.BI "cluster " "[subcommand]"
Inspect the cluster. Requires a running daemon with cluster mode enabled
(via
.B daemon \-\-name
+
.BR "daemon \-\-cluster" ).
The cluster directory is read from the daemon automatically.
.RS
.TP
.B ls
List all daemons in the cluster with runtime counts and heartbeat status.
.TP
.B ps
List all runtimes across the entire cluster.
.TP
.BI "group " "name"
Show all members of a specific group across the cluster.
.TP
.BI "show " "daemon\-name"
Print a daemon's raw cluster JSON file.
.TP
.B stats
Show cluster summary: daemon counts, runtime totals, group membership.
.TP
.B watch
Continuously refresh the cluster view every 2 seconds (Ctrl+C to stop).
.RE
.TP
.BI "\-\-lua " "lua_file"
Load Lua orchestration configuration. Optionally configures daemon name
and cluster mode, then creates multiple runtimes from a single config file.
.SH DAEMON FLAGS
These flags configure the running daemon via IPC commands. The daemon is
auto-started if not already running.
.TP
.BI "\-\-name " "name" " | \-n " "name"
Set this daemon's identity. Required before enabling cluster mode.
Can be changed at any time; if cluster mode is active, the cluster file
is republished under the new name (old name is removed).
.TP
.BI "\-\-cluster " "dir"
Enable cluster mode on the given shared directory. Each daemon publishes
its runtime state there every 2 seconds and scans for peer daemons. Proxy
.B @group
backends automatically discover runtimes on remote daemons.
In Docker Compose, mount a shared volume at this path.
The advertised host address is set automatically via
.BR gethostname (3).
Requires
.B \-\-name
to be set first.
.SH COMMON FLAGS
These flags work with all runtime types:
.TP
.BI "\-p " "port"
Set listener port (server, proxy, cache) or target port (client).
.TP
.B \-s
Start immediately after creation.
.TP
.B \-\-test
Dry run. Validate configuration without starting.
.TP
.BI "\-\-log " "file"
Log state transitions (created, running, stopped, failed) to file.
.TP
.BI "\-w " "file"
Write every received message to file.
.TP
.BI "\-\-lua " "script"
Attach Lua configuration script with callbacks.
.TP
.B \-b
Output received messages to stdout (bash mode).
.TP
.B \-bp
Output messages with runtime name prefix: [name] message
.TP
.B \-bt
Output messages with timestamp: [HH:MM:SS] message
.TP
.B \-bpt
Output messages with both timestamp and prefix: [HH:MM:SS] [name] message
.TP
.BI "\-\-max\-connections " "n"
Limit maximum concurrent connections. New connections beyond this limit
are immediately closed. 0 means unlimited (default). Alias:
.BR \-\-max\-conn .
.TP
.BI "\-\-rate\-limit " "n"
Limit messages per second per connection using a token bucket algorithm.
Excess messages are silently dropped. 0 means unlimited (default).
.TP
.BI "\-\-global\-rate\-limit " "n"
Limit total messages per second across all connections using a shared
token bucket. Excess messages are silently dropped (server) or responded
with an error (cache). 0 means unlimited (default).
.TP
.BI "\-\-idle\-timeout " "seconds"
Close connections that have been idle (no data received) for longer than
the specified number of seconds. A sweep timer runs every 30 seconds to
check for idle connections. 0 means disabled (default).
.TP
.B \-\-drain
Enable graceful shutdown. When stopping, the runtime closes its listener
but flushes all pending write queues before closing connections.
.TP
.B \-\-tls
Enable TLS encryption for all connections. Requires
.B \-\-cert
and
.B \-\-key
for accepting runtimes (server, cache, proxy) or
.B \-\-ca
for connecting runtimes (client).
.TP
.BI "\-\-cert " "file"
Path to TLS certificate file (PEM format).
.TP
.BI "\-\-key " "file"
Path to TLS private key file (PEM format).
.TP
.BI "\-\-ca " "file"
Path to TLS CA certificate file for client verification.
.TP
.BI "\-g " "name"
.TQ
.BI "\-\-group " "name"
Assign the runtime to a named group. Groups enable dynamic proxy backend
discovery: a proxy using
.B @groupname
as a backend will route to all running members of that group at connection
time. New group members are discovered automatically without restarting
the proxy.
.SH SERVER FLAGS
.TP
.BI "\-\-mode " "mode"
Message flow direction:
.B inout
(bidirectional, default),
.B in
(receive only),
.B out
(send only),
.B master
(one client claims master, only master's messages are broadcast).
.TP
.B \-\-udp
Use UDP instead of TCP. The server binds a single SOCK_DGRAM socket.
Peers are auto-registered on first datagram. Each datagram is one message
(no line-parsing). Broadcast sends to all known peers via sendto().
Not available for cache or proxy. Incompatible with master mode.
.TP
.BI "\-\-master\-pw " "password"
Static password for master mode authentication. A client sends "master <password>"
to claim master role. Only one master at a time; master is released on disconnect.
Alternatively, use the
.B on_master_auth(client_id, password)
Lua callback for dynamic authentication.
.TP
.B \-\-master\-forward
When set in master mode, non-master client messages are forwarded to the master
as "[<fd>] <message>\\n" instead of being silently dropped.
.TP
.BI "\-\-http " "directory"
Serve static files from the given directory over HTTP. When a browser makes a
plain HTTP GET request (without a WebSocket upgrade header), the server responds
with the requested file. GET / serves index.html. HTML files (.html, .htm)
automatically get a WebSocket connection script injected before </head>.
Content-Type is detected from the file extension. WebSocket upgrades continue
to work as before on the same port. Only GET requests are served; other HTTP
methods fall through to raw TCP handling.
.TP
.B \-\-http\-cache
When used with \-\-http, reads all files into memory at startup instead of
reading from disk on each request. Faster for production. The cache is rebuilt
on
.BR reload\-lua .
Without this flag, files are read from disk on each request (suitable for
development).
.TP
.TP
.BI "\-u " "host:port"
.TQ
.BI "\-\-upstream " "host:port"
Add an outbound upstream connection. The server connects to the specified
host:port on startup and auto-reconnects with exponential backoff (1s\(en30s)
if the connection drops. Multiple \-u flags may be specified, or multiple
addresses separated by semicolons (e.g. \-u "feed:9000;cache:6379").
Each upstream gets a stable 1-based conn_id for use in Lua callbacks.
.PP
.RS
Upstream Lua callbacks:
.TP
.B on_upstream(conn_id, data)
Called for each newline-delimited message received from an upstream.
.TP
.B on_upstream_connect(conn_id)
Called when an upstream connects (including reconnects).
.TP
.B on_upstream_disconnect(conn_id)
Called when an upstream disconnects.
.RE
.RS
Upstream Lua actions:
.TP
.B self.upstream_send(conn_id, msg)
Send a message to a specific upstream.
.TP
.B self.upstream_broadcast(msg)
Send a message to all connected upstreams.
.TP
.B self.upstreams()
Returns a table of currently connected upstream conn_ids.
.RE
.TP
.BI "\-\-cache " "name"
Link this server to an existing cache runtime. Clients can then send
"cache <command>" messages (e.g. "cache set foo bar", "cache get foo")
which are executed against the linked cache and the response returned to
the sender only. Normal messages are still processed according to the
server's mode.
.SS WebSocket Support
Servers automatically detect WebSocket upgrade requests on each connection.
When a client sends an HTTP GET with "Upgrade: websocket", the server completes
the handshake and transparently frames/deframes messages. Raw TCP and WebSocket
clients coexist on the same port. No flag is needed.
.PP
Browser example:
.nf
const ws = new WebSocket("ws://localhost:9000");
ws.onmessage = e => console.log(e.data);
ws.send("hello");
.fi
.SS Cache Access via Server
When a server is linked to a cache with
.BR \-\-cache ,
clients can send "cache <command>" messages to execute commands directly against
the linked cache. The response is sent back to the sender only (never broadcast).
Normal messages are still processed according to the server's mode.
.PP
.nf
socketley create cache store -p 9001 -s
socketley create server api -p 9000 --cache store -s
# Client sends: "cache set foo bar" → receives "ok"
# Client sends: "cache get foo" → receives "bar"
.fi
.PP
Default port: 8000
.SH CLIENT FLAGS
.TP
.BI "\-t " "host:port"
Target server to connect to. Default: 127.0.0.1:8000
.TP
.BI "\-\-mode " "mode"
Message flow direction:
.B inout
(bidirectional, default),
.B in
(receive only),
.B out
(send only).
.TP
.B \-\-udp
Use UDP instead of TCP. Creates a connected SOCK_DGRAM socket.
Each datagram is one message (no line-parsing).
Not available for cache or proxy.
.TP
.BI "\-\-reconnect " "[max\-attempts]"
Enable automatic reconnection with exponential backoff when the connection
is lost. Backoff starts at 1 second and doubles each attempt up to 30 seconds,
with random jitter. Set to 0 for infinite attempts (default when flag is given
without a value). Set to a positive number to limit reconnection attempts.
.SH PROXY FLAGS
.TP
.BI "\-\-backend " "addr"
Add backend server. Can be ip:port, runtime name, or
.BI @ groupname
to dynamically target all running members of that group. Repeatable or comma-separated.
Group backends are resolved at connection time, so new group members are picked up
automatically without restarting the proxy.
.TP
.BI "\-\-strategy " "strategy"
Load balancing strategy:
.B round-robin
(default),
.B random
,
.B lua
(custom via on_route callback).
.TP
.BI "\-\-protocol " "protocol"
.B http
(default, path-based routing) or
.B tcp
(raw byte forwarding).
.PP
Default port: 8080
.PP
HTTP mode: Requests to /<proxy-name>/* are forwarded with prefix stripped.
.SH CACHE FLAGS
.TP
.BI "\-\-persistent " "file"
Persistent storage file. Cache is saved on stop and loaded on start.
.TP
.BI "\-\-mode " "mode"
Access control mode:
.B readonly
(GET, SIZE only),
.B readwrite
(GET, SET, DEL, SIZE \- default),
.B admin
(all commands including FLUSH, LOAD).
.TP
.BI "\-\-maxmemory " "size"
Maximum memory for cache data. Supports K, M, G suffixes (e.g., 100M, 1G).
When exceeded, behavior depends on eviction policy. 0 means unlimited (default).
.TP
.BI "\-\-eviction " "policy"
Eviction policy when maxmemory is reached:
.B noeviction
(reject writes, default),
.B allkeys\-lru
(evict least recently used),
.B allkeys\-random
(evict random keys).
.TP
.B \-\-resp
Force RESP2 protocol mode for all connections (Redis wire protocol).
By default, the cache auto-detects RESP mode when a connection's first
byte is '*'. With this flag, all connections use RESP regardless.
.TP
.BI "\-\-replicate " "host:port"
Connect as a follower to the specified leader cache. The follower receives
a full data dump on connect, then receives ongoing write command replication.
The follower operates in read-only mode.
.PP
Default port: 9000
.SS Cache Protocol
Connect via TCP and send commands (newline-terminated, all lowercase).
.PP
.B Strings:
.TP
.BI "set " "key value"
Store a key-value pair. Returns "ok" or "error: type conflict".
.TP
.BI "get " "key"
Retrieve value. Returns value or "nil".
.TP
.BI "del " "key"
Delete key (any type). Returns "ok" or "nil".
.TP
.BI "exists " "key"
Check if key exists. Returns "1" or "0".
.TP
.BI "incr " "key"
Increment integer value by 1. Returns new integer.
.TP
.BI "decr " "key"
Decrement integer value by 1. Returns new integer.
.TP
.BI "incrby " "key delta"
Increment integer value by delta. Returns new integer.
.TP
.BI "decrby " "key delta"
Decrement integer value by delta. Returns new integer.
.TP
.BI "append " "key value"
Append to string value. Returns new length.
.TP
.BI "strlen " "key"
Return string length. Returns 0 if missing.
.TP
.BI "getset " "key newvalue"
Set new value and return old value. Returns old value or "nil".
.TP
.BI "mget " "key [key ...]"
Get multiple keys. Returns one value per line (nil if missing), then "end".
.TP
.BI "mset " "key value [key value ...]"
Set multiple key-value pairs atomically. Returns "ok".
.TP
.BI "type " "key"
Return type of key: "string", "list", "set", "hash", or "none".
.TP
.BI "keys " "pattern"
List all matching keys (glob patterns, "*" for all). Returns keys then "end".
.TP
.BI "setnx " "key value"
Set key only if it does not exist. Returns "1" (set) or "0" (not set).
.TP
.BI "setex " "key seconds value"
Set key with expiry. Equivalent to SET + EXPIRE. Returns "ok".
.TP
.BI "psetex " "key milliseconds value"
Set key with millisecond-precision expiry. Returns "ok".
.TP
.BI "scan " "cursor [match pattern] [count n]"
Cursor-based key iteration. Returns next cursor (0 = done), then matching keys, then "end".
Use cursor=0 to start; repeat with returned cursor until 0 is returned.
.TP
.B size
Return number of stored keys (all types).
.PP
.B Lists (ordered, deque-backed):
.TP
.BI "lpush " "key value"
Insert at front. Returns "ok" or "error: type conflict".
.TP
.BI "rpush " "key value"
Insert at back.
.TP
.BI "lpop " "key"
Remove and return front element. Returns value or "nil".
.TP
.BI "rpop " "key"
Remove and return back element.
.TP
.BI "llen " "key"
Return list length.
.TP
.BI "lindex " "key index"
Return element at index (negative = from end).
.TP
.BI "lrange " "key start stop"
Return range of elements (multi-line, "end" terminator). Negative indices supported.
.PP
.B Sets (unique unordered members):
.TP
.BI "sadd " "key member"
Add member. Returns "ok", "exists", or "error: type conflict".
.TP
.BI "srem " "key member"
Remove member. Returns "ok" or "nil".
.TP
.BI "sismember " "key member"
Check membership. Returns "1" or "0".
.TP
.BI "scard " "key"
Return set cardinality.
.TP
.BI "smembers " "key"
Return all members (multi-line, "end" terminator).
.PP
.B Hashes (nested key-value maps):
.TP
.BI "hset " "key field value"
Set hash field. Returns "ok" or "error: type conflict".
.TP
.BI "hget " "key field"
Get hash field value. Returns value or "nil".
.TP
.BI "hdel " "key field"
Delete hash field. Returns "ok" or "nil".
.TP
.BI "hlen " "key"
Return number of hash fields.
.TP
.BI "hgetall " "key"
Return all fields and values (multi-line "field value\n", "end" terminator).
.PP
.B TTL / Expiry:
.TP
.BI "expire " "key seconds"
Set time-to-live. Returns "ok" or "nil" (key not found).
.TP
.BI "ttl " "key"
Return remaining seconds, -1 (no ttl), or -2 (not found).
.TP
.BI "persist " "key"
Remove expiry. Returns "ok" or "nil".
.TP
.BI "pexpire " "key milliseconds"
Set millisecond-precision TTL. Returns "1" (set) or "0" (key not found).
.TP
.BI "pttl " "key"
Return remaining TTL in milliseconds, -1 (no ttl), or -2 (not found).
.TP
.BI "expireat " "key unix_seconds"
Set expiry to an absolute Unix timestamp (seconds). Returns "1" or "0".
.TP
.BI "pexpireat " "key unix_ms"
Set expiry to an absolute Unix timestamp in milliseconds. Returns "1" or "0".
.PP
.B Pub/Sub:
.TP
.BI "subscribe " "channel"
Subscribe to a channel. Returns "ok". Messages are delivered as
"message <channel> <payload>\\n".
.TP
.BI "unsubscribe " "channel"
Unsubscribe from a channel. Returns "ok".
.TP
.BI "publish " "channel message"
Publish a message to all subscribers. Returns number of subscribers reached.
.PP
.B Memory Management:
.TP
.BI "maxmemory " ""
Query current maxmemory setting. Returns bytes or "0" (unlimited).
.TP
.BI "memory " ""
Query current memory usage in bytes.
.PP
.B Admin (requires --mode admin):
.TP
.BI "flush " "[path]"
Save cache to file (uses --persistent path if omitted).
.TP
.BI "load " "[path]"
Load cache from file.
.PP
Type enforcement: a key can only hold one data type. Writing to a key of a different type returns "error: type conflict".
Multi-line responses (lrange, smembers, hgetall) terminate with "end\n".
.SS RESP Protocol (Redis Compatibility)
The cache supports the RESP2 wire protocol for compatibility with Redis clients
(redis-cli, Redis client libraries). RESP mode is auto-detected when a
connection's first byte is '*', or can be forced with
.BR \-\-resp .
.PP
Supported Redis commands (case-insensitive): SET (with EX, PX, NX, XX options),
GET, DEL, EXISTS, PING, DBSIZE, INCR, DECR, INCRBY, DECRBY, APPEND, STRLEN,
GETSET, MGET, MSET, TYPE, KEYS, SETNX, SETEX, PSETEX, SCAN,
LPUSH, RPUSH, LPOP, RPOP, LLEN, LRANGE, LINDEX,
SADD, SREM, SISMEMBER, SCARD, SMEMBERS,
HSET, HGET, HDEL, HLEN, HGETALL,
EXPIRE, TTL, PERSIST, PEXPIRE, PTTL, EXPIREAT, PEXPIREAT,
SUBSCRIBE, UNSUBSCRIBE, PUBLISH.
.PP
Example with redis-cli:
.nf
redis-cli -p 9000 SET mykey myval
redis-cli -p 9000 GET mykey
redis-cli -p 9000 SUBSCRIBE news
.fi
.SS Database Backend
Cache runtimes support four Lua callbacks for DB-backed operation.
Attach a Lua script with
.BR \-\-lua
and implement whichever callbacks you need using any Lua DB library
(luasql-mysql, luasql-postgres, lsqlite3, etc.).
.PP
.TS
tab(|);
l l l.
Callback|Signature|When called
_
on_miss(key)|→ value [, ttl_seconds]|GET returns nil — fetch from DB
on_write(key, value, ttl)|→ nothing|After successful SET/SETEX/SETNX/MSET
on_delete(key)|→ nothing|After DEL — delete from DB
on_expire(key)|→ nothing|After TTL sweep removes key
.TE
.PP
\fBon_miss\fR may return two values (Lua multi-return): the fetched string and an
optional TTL in seconds.
If the value is nil or empty, the GET returns nil to the client normally.
If a value is returned, it is inserted into the cache and returned to
the client transparently (read-through / lazy population).
.PP
\fBon_write\fR is called synchronously on the event loop thread.
For write-heavy loads, use the write-behind pattern: buffer writes in Lua
inside \fBon_write\fR and flush to the DB in \fBon_tick\fR every few seconds.
This decouples SET latency from DB latency entirely.
.PP
Example (SQLite write-behind):
.nf
tick_ms = 2000
local db, pending = nil, {}

function on_start()
    local sq = require("lsqlite3")
    db = sq.open("/tmp/cache.db")
    db:exec("CREATE TABLE IF NOT EXISTS cache_kv (key TEXT PRIMARY KEY, value TEXT)")
end

function on_miss(key)
    for row in db:nrows("SELECT value FROM cache_kv WHERE key=" .. db:quote(key)) do
        return row.value, 300  -- value + 300 s TTL
    end
end

function on_write(key, value, ttl)
    pending[key] = value  -- buffer
end

function on_tick(dt)
    for k, v in pairs(pending) do
        db:exec("INSERT OR REPLACE INTO cache_kv(key,value) VALUES("..db:quote(k)..","..db:quote(v)..")")
    end
    pending = {}
end

function on_delete(key)
    db:exec("DELETE FROM cache_kv WHERE key="..db:quote(key))
end
.fi
.PP
See
.B examples/cache/db-backend.lua
for a full example with MySQL, Postgres, and SQLite backends.
.SS Replication
Cache runtimes support leader-follower replication.
.PP
The follower connects to the leader and receives a full data dump, then
ongoing write commands are forwarded in real-time. Followers are read-only.
.PP
.nf
# Start leader cache
socketley create cache leader -p 9000 -s

# Start follower
socketley create cache follower -p 9001 --replicate 127.0.0.1:9000 -s

# Writes on leader are replicated to follower
echo "set key val" | nc localhost 9000
echo "get key" | nc localhost 9001    # Returns "val"
.fi
.PP
Example with netcat:
.nf
echo "set user:1 alice" | nc localhost 9000
echo "get user:1" | nc localhost 9000
echo "lpush queue task1" | nc localhost 9000
echo "hset user:1 name alice" | nc localhost 9000
echo "expire user:1 300" | nc localhost 9000
echo "subscribe news" | nc localhost 9000
.fi
.SH LUA CONFIGURATION
Lua scripts can define multiple runtimes and attach callbacks.
.SS Configuration File Format
.nf
\-\- Optional: configure daemon name and cluster directory
daemon = {
    name = "node1",
    cluster = "/shared/cluster"
}

runtimes = {
    { type = "server", name = "api", port = 9000, group = "api", start = true },
    { type = "client", name = "cli", port = 9000, target = "127.0.0.1:9000" },
    { type = "proxy",  name = "gw", port = 8080,
      backends = {"@api", "127.0.0.1:9000"}, strategy = "round-robin" },
    { type = "cache",  name = "store", port = 9001,
      persistent = "/data/store.bin" }
}
.fi
.PP
The
.B daemon
table is processed first (name, then cluster). If omitted, the daemon
runs without cluster mode.
.SS Available Callbacks
.TP
.B on_start()
Called when runtime starts.
.TP
.B on_stop()
Called when runtime stops.
.TP
.B on_message(msg)
Called when message received (server/client).
When defined on a server, this callback claims message handling: the default broadcast
(in \fBinout\fR and \fBmaster\fR modes) is suppressed. Use \fBself.broadcast(msg)\fR
to relay messages manually.
.TP
.B on_client_message(client_id, msg)
Called when message received with sender identification (server only).
Fires alongside on_message for backward compatibility.
.TP
.B on_connect(client_id)
Called when a client connects (server/client). The client_id is the file descriptor.
.TP
.B on_disconnect(client_id)
Called when a client disconnects (server/client).
.TP
.B on_send(msg)
Called when message sent.
.TP
.B on_route(method, path)
Proxy only. Custom backend selection. Returns backend index (0-based).
.TP
.B on_proxy_request(client_id, data) \(-> string | nil
Proxy only. Called for every chunk forwarded from a client to a backend.
Return a modified string to replace the data, or
.B nil
to drop the chunk entirely (the backend never receives it).
.TP
.B on_proxy_response(client_id, data) \(-> string | nil
Proxy only. Called for every chunk forwarded from a backend to a client.
Same semantics as
.BR on_proxy_request :
return a replacement string or nil to drop.
.TP
.B on_master_auth(client_id, password)
Server only (master mode). Custom authentication. Return true to grant
master role, false to deny. If defined, overrides
.BR \-\-master\-pw .
.TP
.B on_auth(client_id) \(-> bool
Server only. Called immediately after a client is accepted, before
.B on_connect
fires. Return
.B true
to admit the client or
.B false
to reject and close the connection. If the callback throws a Lua error, the client is also rejected (fail-closed). When no
.B on_auth
callback is defined, all clients are admitted.
.TP
.B on_websocket(client_id, headers)
Server only. Called immediately after a WebSocket upgrade handshake completes,
after
.B on_connect
has already fired. The
.I headers
argument is a Lua table containing any subset of the following keys from the
HTTP upgrade request:
.BR cookie ,
.BR origin ,
.BR protocol
(Sec-WebSocket-Protocol), and
.BR authorization .
Only keys present in the request are set; absent headers are nil.
This callback never fires for plain TCP clients.
.TP
.B on_tick(dt)
Called at a configurable interval while the runtime is running.
.I dt
is the actual elapsed time in milliseconds since the last tick (double).
Requires a top-level
.B tick_ms
global (integer, minimum 10, default 100 if omitted) to be set in the Lua script.
Example:
.nf
tick_ms = 50
function on_tick(dt)
    self.broadcast("ping")
end
.fi
.TP
.B on_upstream(conn_id, data)
Server only. Called for each newline-delimited message received from an
upstream connection. Use \-u to configure upstreams.
.TP
.B on_upstream_connect(conn_id)
Server only. Called when an upstream connects (including auto-reconnects).
.TP
.B on_upstream_disconnect(conn_id)
Server only. Called when an upstream disconnects.
.TP
.B on_cluster_join(daemon)
Cluster only. Called when a new remote daemon is discovered. See
.BR "Cluster Event Callbacks" .
.TP
.B on_cluster_leave(daemon)
Cluster only. Called when a remote daemon becomes stale or disappears.
.TP
.B on_group_change(group, members)
Cluster only. Called when the member count of a group changes.
.SS Runtime Methods (in Lua)
.nf
self.name      -- Runtime name (read-only)
self.port      -- Port number (read-only)
self.state     -- Current state (read-only)
self.type      -- Runtime type (read-only)
self.protocol  -- "tcp" or "udp" (server/client only)
self.send(msg)             -- Send message (client)
self.send(client_id, msg)  -- Send to specific client (server)
self.broadcast(msg)        -- Broadcast to all clients (server)

-- Upstream actions (server with -u)
self.upstream_send(conn_id, msg) -- Send to a specific upstream
self.upstream_broadcast(msg)     -- Send to all connected upstreams
self.upstreams()                 -- Table of connected upstream conn_ids

-- Cache: strings
self.get(key)       -- Get string value
self.set(key, val)  -- Set string value
self.del(key)       -- Delete key (any type)

-- Cache: lists
self.lpush(key, val)        -- Push to front
self.rpush(key, val)        -- Push to back
self.lpop(key)              -- Pop from front
self.rpop(key)              -- Pop from back
self.llen(key)              -- List length

-- Cache: sets
self.sadd(key, member)      -- Add member
self.srem(key, member)      -- Remove member
self.sismember(key, member) -- Check membership
self.scard(key)             -- Set cardinality

-- Cache: hashes
self.hset(key, field, val)  -- Set hash field
self.hget(key, field)       -- Get hash field
self.hdel(key, field)       -- Delete hash field
self.hlen(key)              -- Hash field count

-- Cache: TTL
self.expire(key, seconds)   -- Set expiry
self.ttl(key)               -- Get remaining TTL
self.persist(key)           -- Remove expiry

-- Cache: pub/sub
self.publish(channel, msg)  -- Publish to channel

-- Server: connection control
self.disconnect(client_id)         -- Terminate a connection from Lua
self.peer_ip(client_id)            -- Get client IP (IPv4 or IPv6 string)
self.ws_headers(client_id)         -- Get WS upgrade headers table (nil for TCP)

-- Server: client enumeration and multicast
self.clients()                     -- Return table of all connected client_ids
self.multicast(ids, msg)           -- Send msg to a subset of clients (ids = table of client_ids)

-- Server: per-connection metadata
self.set_data(id, key, val)        -- Set string metadata on a connection (nil val deletes key)
self.get_data(id, key)             -- Get metadata string or nil

-- Server: client routing
self.route(client_id, target)      -- Forward client to sub-server
self.unroute(client_id)            -- Stop forwarding
self.get_route(client_id)          -- Get current route (string or nil)

-- Server: owner-targeted sending (sub-server only)
self.owner_send(client_id, msg)    -- Send to owner's client by fd
self.owner_broadcast(msg)          -- Broadcast to all owner's clients
.fi
.SS Global Functions
.TP
.B socketley.log(msg)
Output log message with [lua] prefix.
.TP
.B socketley.set_timeout(ms, fn)
Fire
.I fn
once after
.I ms
milliseconds using an io_uring timeout SQE.
Shares the event loop with the runtime — no extra threads.
.TP
.B socketley.set_interval(ms, fn)
Fire
.I fn
every
.I ms
milliseconds.
Cancel by calling from within
.BR on_stop ,
where the context will be destroyed and the timer freed safely.
.TP
.B socketley.subscribe(cache_name, channel, fn)
Register
.I fn(channel, message)
to be called whenever the named cache runtime publishes to
.IR channel .
The function is called on the subscribing runtime's event loop turn (not from the cache itself).
Multiple subscriptions to the same channel are all fired in registration order.
.TP
.B socketley.http(opts) \(-> table
Synchronous HTTP/HTTPS client.
.B WARNING:
Blocks the event loop thread. Use only in
.BR on_start / on_stop
or low-frequency
.B on_tick
callbacks.
.PP
.I opts
table keys:
.nf
url         string   Request URL (http:// or https://)
method      string   HTTP method (default "GET")
body        string   Request body (optional)
headers     table    Extra headers e.g. {["Content-Type"]="application/json"}
timeout_ms  number   Timeout in milliseconds (default 5000)
.fi
.PP
Returns a table:
.nf
ok      bool    true if HTTP status 2xx
status  number  HTTP status code (e.g. 200, 404)
body    string  Response body
error   string  Error message on failure
.fi
.PP
HTTPS uses OpenSSL with
.B SSL_VERIFY_NONE
(no certificate validation) — suitable for trusted internal services.
For external HTTPS with cert validation, use
.BR "io.popen(\"curl -s ...\")" .
.SS Runtime Management API
Create, start, stop, and remove runtimes from Lua scripts:
.nf
socketley.create(type, name, config)  -- Create runtime
socketley.start(name)                 -- Start runtime
socketley.stop(name)                  -- Stop runtime
socketley.remove(name)                -- Stop + remove runtime
socketley.send(name, msg)             -- Send/broadcast to runtime
socketley.list()                      -- List all runtime names (table)
socketley.get(name)                   -- Get info table or nil
.fi
.P
Config table keys: port, config (lua script path), target, mode, group, on_parent_stop ("remove"/"stop"), start (bool).
Lua-created runtimes have parent-child ownership; port=0 creates internal-only servers that receive forwarded messages only.
.SS Cluster Introspection API
When the daemon runs in cluster mode (\fB\-\-cluster\fR), the
.B socketley.cluster
table provides read-only introspection into the full cluster topology.
All functions return empty tables when not in cluster mode, so scripts work in both standalone and cluster setups without modification.
.TP
.B socketley.cluster.daemons() \(-> table
Returns an array of daemon info tables. Each entry has:
.nf
name      string   Daemon name (from \-\-name)
host      string   Advertised address (from \-\-cluster\-addr)
runtimes  number   Count of runtimes on this daemon
.fi
.IP
The local daemon is always the first entry. Remote daemons follow in discovery order.
.TP
.B socketley.cluster.runtimes() \(-> table
Returns a flat array of all runtimes across every daemon in the cluster:
.nf
daemon       string   Name of the daemon hosting this runtime
name         string   Runtime name
type         string   "server", "client", "proxy", or "cache"
port         number   Listen port (0 = internal-only)
group        string   Group tag (empty string if unset)
state        string   "created", "running", "stopped", or "failed"
connections  number   Current connection count
.fi
.TP
.B socketley.cluster.group(name) \(-> table
Returns running members of the named group that have a valid port.
Each entry has:
.nf
daemon       string   Daemon name
host         string   Advertised address
port         number   Listen port
connections  number   Current connection count
.fi
.IP
Useful for building custom routing, health checks, or failover logic from Lua.
.TP
.B socketley.cluster.stats() \(-> table
Aggregate cluster statistics:
.nf
daemons   number   Total daemon count (local + remote)
runtimes  number   Total runtime count across all daemons
running   number   Count of runtimes in "running" state
groups    table    Maps group name (string) \(-> member count (number)
.fi
.SS Cluster Event Callbacks
These optional callbacks fire when the cluster topology changes.
Events are detected during the 2-second scan/publish cycle, so callbacks
may fire up to 2 seconds after the actual change.
A daemon is considered stale and triggers
.B on_cluster_leave
after 10 seconds without a heartbeat update.
.TP
.B on_cluster_join(daemon)
Fired when a new remote daemon is discovered in the cluster directory.
.I daemon
is a table with
.B name
(string) and
.B host
(string) fields.
.TP
.B on_cluster_leave(daemon)
Fired when a remote daemon's heartbeat file becomes stale (>10s old) or is
removed from the cluster directory.
.I daemon
is a table with a
.B name
(string) field.
.TP
.B on_group_change(group, members)
Fired when the total member count of a group changes (a runtime joins or
leaves the group, or a daemon with group members appears/disappears).
Only fires on actual count changes, not on every scan cycle.
.I group
is the group name (string).
.I members
is an array of tables, each with
.BR daemon ", " host ", and " port
fields representing the current group membership.
.PP
Example \(em log topology changes and maintain a local routing table:
.nf
local backends = {}

function on_cluster_join(daemon)
    socketley.log("daemon joined: " .. daemon.name .. " at " .. daemon.host)
end

function on_cluster_leave(daemon)
    socketley.log("daemon left: " .. daemon.name)
end

function on_group_change(group, members)
    if group == "api" then
        backends = members   \-\- update routing table
        socketley.log("api group now has " .. #members .. " members")
    end
end

function on_start()
    \-\- Initial snapshot
    local stats = socketley.cluster.stats()
    socketley.log("cluster: " .. stats.daemons .. " daemons, "
                  .. stats.running .. " running runtimes")
end
.fi
.SH RUNTIME STATES
.TP
.B created
Initial state after creation.
.TP
.B running
Active and processing I/O.
.TP
.B stopped
Stopped but can be restarted.
.TP
.B failed
Setup failed, cannot recover.
.SH EXAMPLES
Create a simple server (daemon is managed by systemd when installed):
.PP
.nf
socketley create server myserver -p 9000 -s
.fi
.PP
Create client connecting to server:
.PP
.nf
socketley create client myclient -t 127.0.0.1:9000 -s
.fi
.PP
Create HTTP proxy with load balancing:
.PP
.nf
socketley create proxy gateway -p 8080 \\
    --backend 127.0.0.1:9001,127.0.0.1:9002 \\
    --strategy round-robin -s
.fi
.PP
Server with bash output (messages to stdout):
.PP
.nf
socketley create server echo -p 9000 -b -s
# With timestamp and prefix:
socketley create server echo -p 9000 -bpt -s
.fi
.PP
Send message to runtime:
.PP
.nf
socketley send myserver "Hello from CLI"
socketley send myclient "Message to server"
.fi
.PP
Create persistent cache with maxmemory:
.PP
.nf
socketley create cache store -p 9000 \\
    --persistent /data/cache.bin \\
    --maxmemory 256M --eviction allkeys-lru -s
.fi
.PP
Create cache with RESP mode (Redis-compatible):
.PP
.nf
socketley create cache redis-compat -p 6379 --resp -s
redis-cli -p 6379 SET mykey myval
redis-cli -p 6379 GET mykey
.fi
.PP
Server with connection limits and rate limiting:
.PP
.nf
socketley create server api -p 9000 \\
    --max-connections 100 --rate-limit 1000 -s
.fi
.PP
View runtime statistics:
.PP
.nf
socketley stats myserver
# Output: name, type, port, connections, total_messages, bytes_in/out, ...
.fi
.PP
Restart a running runtime:
.PP
.nf
socketley reload myserver
# Stops and restarts the runtime
socketley reload *
# Restarts all running runtimes
.fi
.PP
Hot-reload Lua script:
.PP
.nf
socketley reload-lua myserver
# Re-loads the Lua script without stopping the runtime
socketley reload-lua *
# Hot-reloads Lua on all runtimes with scripts
.fi
.PP
Start/stop all runtimes:
.PP
.nf
socketley start *
# Starts all non-running runtimes
socketley stop *
# Stops all running runtimes
socketley remove *
# Stops all and removes everything
.fi
.PP
Multiple names and glob patterns:
.PP
.nf
socketley stop myserver myclient
# Stops both runtimes
socketley stop my*
# Stops all runtimes starting with "my"
socketley stats cache?
# Shows stats for cache1, cache2, etc.
socketley start myserver cache*
# Starts myserver and all cache-prefixed runtimes
socketley remove api-* test-*
# Removes all api- and test- prefixed runtimes
.fi
.PP
Interactive mode (live terminal session):
.PP
.nf
# Start server and enter interactive session
socketley create server echo -p 9000
socketley start echo -i
# Type messages to broadcast, see received messages
# Press Ctrl+C to detach (server keeps running)

# Attach to already-running cache
socketley start mycache -i
# Type cache commands: set foo bar, get foo, etc.
.fi
.PP
Interactive edit (opens JSON config in $EDITOR):
.PP
.nf
socketley edit myserver           # Opens config in editor
socketley edit myserver -r        # Opens editor, auto-reloads Lua after save
socketley edit myserver -p 9001   # Flag-based edit (direct)
.fi
.PP
Cache replication (leader-follower):
.PP
.nf
socketley create cache leader -p 9000 -s
socketley create cache follower -p 9001 --replicate 127.0.0.1:9000 -s
.fi
.PP
TLS-encrypted server:
.PP
.nf
socketley create server secure -p 9000 \\
    --tls --cert server.pem --key server-key.pem -s
.fi
.PP
Graceful shutdown (drain pending writes):
.PP
.nf
socketley create server api -p 9000 --drain -s
socketley stop api   # Flushes write queues before closing
.fi
.PP
UDP server (fire-and-forget messaging):
.PP
.nf
socketley create server metrics -p 9000 --udp -b -s
echo "cpu.load 0.42" | socat - UDP:localhost:9000
.fi
.PP
UDP client:
.PP
.nf
socketley create client udpcli -t 127.0.0.1:9000 --udp -s
.fi
.PP
Create read-only cache (for shared lookups):
.PP
.nf
socketley create cache lookup -p 9000 --mode readonly -s
.fi
.PP
Master mode server (one controller, many viewers):
.PP
.nf
socketley create server broadcast -p 9000 \\
    --mode master --master-pw secret -s
# Client A: sends "master secret" → "master: ok"
# Client A: sends "hello" → broadcast to all others
# Client B: sends "hello" → silently dropped
.fi
.PP
Master mode with forwarding:
.PP
.nf
socketley create server ctrl -p 9000 \\
    --mode master --master-pw admin123 --master-forward -s
# Non-master messages forwarded to master as "[<fd>] msg"
.fi
.PP
WebSocket server (auto-detected, no flags needed):
.PP
.nf
socketley create server ws -p 9000 -s
# Browser: new WebSocket("ws://localhost:9000")
# Raw TCP clients also work on the same port
.fi
.PP
Cache access through server:
.PP
.nf
socketley create cache db -p 9001 -s
socketley create server api -p 9000 --cache db -s
# Client sends: "cache set user:1 alice" → "ok"
# Client sends: "cache get user:1" → "alice"
# Client sends: "hello" → broadcast as usual
.fi
.PP
Dynamic proxy with group-based backend discovery:
.PP
.nf
socketley create server api1 -p 9001 -g api -s
socketley create server api2 -p 9002 -g api -s
socketley create proxy gw -p 8080 --backend @api -s
# Proxy routes to all running members of group "api"

# Add a new member dynamically (no proxy restart needed)
socketley create server api3 -p 9003 -g api -s

# Mix group and direct backends
socketley create proxy gw2 -p 8081 \\
    --backend @api,10.0.0.5:9000 -s
.fi
.PP
Load complex configuration:
.PP
.nf
socketley --lua /etc/socketley/setup.lua
.fi
.SH CLUSTER MODE
Multi-daemon cluster discovery allows proxies to route to runtimes on remote
daemons. Each daemon publishes its state to a shared directory (typically a
Docker volume) every 2 seconds. Stale entries (heartbeat older than 10s) are
automatically excluded.
.PP
.B How it works:
.RS
.IP 1. 3
Each daemon writes its state to
.IR dir / name .json
.IP 2. 3
Every 2 seconds, each daemon scans the directory for peer files
.IP 3. 3
Proxy
.B @group
resolution includes both local and remote group members
.IP 4. 3
On graceful shutdown, the daemon deletes its file
.RE
.PP
.B Docker Compose example:
.PP
.nf
version: "3.8"
volumes:
  cluster:

services:
  api1:
    image: socketley
    command: >
      sh -c "socketley daemon &
             sleep 1 &&
             socketley daemon --name api1 --cluster /cluster &&
             socketley create server web -p 9001 -g api -s && wait"
    volumes: [cluster:/cluster]

  api2:
    image: socketley
    command: >
      sh -c "socketley daemon &
             sleep 1 &&
             socketley daemon --name api2 --cluster /cluster &&
             socketley create server web -p 9001 -g api -s && wait"
    volumes: [cluster:/cluster]

  gateway:
    image: socketley
    command: >
      sh -c "socketley daemon &
             sleep 1 &&
             socketley daemon --name gateway --cluster /cluster &&
             sleep 1 &&
             socketley create proxy gw -p 8080 --backend @api -s && wait"
    volumes: [cluster:/cluster]
    ports: ["8080:8080"]
.fi
.PP
Alternatively, use a Lua config file:
.PP
.nf
\-\- /etc/socketley/setup.lua
daemon = { name = "api1", cluster = "/cluster" }
runtimes = {
    { type = "server", name = "web", port = 9001, group = "api", start = true }
}
.fi
.PP
.nf
socketley daemon &
sleep 1 && socketley --lua /etc/socketley/setup.lua
.fi
.PP
.B Inspecting the cluster:
.PP
.nf
socketley cluster ls
socketley cluster ps
socketley cluster group api
socketley cluster stats
socketley cluster watch
.fi
.PP
.B Stale detection:
.TS
l l l.
Scenario	Behavior	Recovery
_
Graceful shutdown	File deleted	Immediate
Container killed	Stale heartbeat	~10 seconds
Container restart	File overwritten	Immediate
.TE
.SH INSTALLATION
.SS Quick Install
.nf
sudo bash packaging/install.sh
sudo systemctl start socketley
.fi
.SS Debian Package
.nf
bash packaging/build-deb.sh 1.0.5
sudo dpkg -i socketley_1.0.5_amd64.deb
sudo systemctl start socketley
.fi
.SS Uninstall
.nf
sudo bash packaging/uninstall.sh
.fi
.SH STATE PERSISTENCE
Runtime configurations are persisted as JSON files. When a runtime is created,
its configuration is saved. When the daemon starts, all persisted runtimes are
restored. Runtimes that were running when the daemon stopped are auto-started.
.PP
This means runtimes survive daemon restarts and system reboots (like Docker
with restart-always policy).
.PP
State is saved after create, start, stop, remove, and edit commands.
The
.B was_running
field tracks whether a runtime should be auto-started on daemon startup.
.SH FILES
.SS System Mode (installed via package)
.TP
.I /usr/bin/socketley
Binary.
.TP
.I /usr/lib/systemd/system/socketley.service
systemd unit file.
.TP
.I /run/socketley/socketley.sock
Unix domain socket for daemon IPC.
.TP
.I /var/lib/socketley/runtimes/
Per-runtime JSON configuration files.
.TP
.I /etc/socketley/config.lua
Daemon configuration (log_level, metrics_port).
.SS Development Mode (no system install)
.TP
.I /tmp/socketley.sock
Unix domain socket for daemon IPC.
.TP
.I ~/.local/share/socketley/runtimes/
Per-runtime JSON configuration files.
.TP
.I ~/.config/socketley/config.lua
Daemon configuration (or set SOCKETLEY_CONFIG env var).
.SS Daemon Configuration
The daemon config file is a Lua script that sets a
.B config
table:
.nf
config = {
    log_level = "info",      -- debug, info, warn, error
    metrics_port = 9100      -- Prometheus metrics HTTP endpoint
}
.fi
.PP
When
.B metrics_port
is set, the daemon starts an HTTP endpoint that serves Prometheus exposition
format metrics at
.BR "GET /metrics" .
Metrics include: runtimes total/running, connections total/active,
messages total, bytes in/out, and per-runtime breakdowns.
.SH C++ SDK
Socketley ships a three-tier modular C++ SDK in
.BR include/linux/socketley/ .
Tiers 1 and 3 are fully self-contained header-only files \(em copy them anywhere,
compile with
.BR "g++ -std=c++17" ,
no library needed. Tier 2 requires building from source.
.PP
.TS
l l l l .
Tier	Header	Use Case	Dependencies
_
1	socketley/control.h	Control a running daemon	None (POSIX)
2	socketley/{server,cache,proxy,client}.h	Embed the full engine	libsocketley_sdk.a
3	socketley/attach.h	Register with a daemon	None (Tier 1)
.TE
.SS Tier 1: Daemon Control (header-only)
.B socketley/control.h
provides full programmatic control over a running daemon through the same Unix
socket IPC that the CLI uses. Zero dependencies beyond POSIX.
.PP
.B "Result type:"
.nf
struct socketley::result {
    int         exit_code;  // 0=success, 1=bad input, 2=fatal, -1=connect fail
    std::string data;       // response body
};
.fi
.PP
.B "Runtime management functions"
(all in namespace
.BR socketley::ctl ):
.nf
command(cmd)               // raw command (glob patterns work)
command(socket_path, cmd)  // custom socket path
create(type, name, flags)  // "server", "client", "proxy", "cache"
start(name)                stop(name)
remove(name)               send(name, message)
ls()   ps()   stats(name)  show(name)
reload(name)               reload_lua(name)
edit(name, flags)
.fi
.PP
.B "Cache string operations"
(direct IPC, no TCP connection needed):
.nf
cache_get(cache, key)           cache_set(cache, key, value)
cache_del(cache, key)           cache_exists(cache, key)
cache_incr(cache, key)          cache_decr(cache, key)
cache_incrby(cache, key, n)     cache_decrby(cache, key, n)
cache_append(cache, key, val)
.fi
.PP
.B "Cache list operations:"
.nf
cache_lpush(cache, key, val)    cache_rpush(cache, key, val)
cache_lpop(cache, key)          cache_rpop(cache, key)
cache_llen(cache, key)          cache_lrange(cache, key, start, stop)
cache_lindex(cache, key, idx)
.fi
.PP
.B "Cache set operations:"
.nf
cache_sadd(cache, key, member)  cache_srem(cache, key, member)
cache_sismember(cache, key, m)  cache_scard(cache, key)
cache_smembers(cache, key)
.fi
.PP
.B "Cache hash operations:"
.nf
cache_hset(cache, key, f, v)    cache_hget(cache, key, field)
cache_hdel(cache, key, field)   cache_hlen(cache, key)
cache_hgetall(cache, key)
.fi
.PP
.B "Cache TTL:"
.nf
cache_expire(cache, key, sec)   cache_ttl(cache, key)
cache_persist(cache, key)
.fi
.PP
.B "Cache pub/sub:"
.nf
cache_publish(cache, ch, msg)
.fi
.PP
.B "Cache admin:"
.nf
cache_size(cache)               cache_memory(cache)
cache_keys(cache, pattern)
cache_flush(cache [, path])     cache_load(cache [, path])
.fi
.PP
Socket path resolution: checks
.B SOCKETLEY_SOCKET
env, then
.BR /run/socketley/socketley.sock ,
then
.BR /tmp/socketley.sock .
.PP
.B "Example: lifecycle management"
.nf
#include <socketley/control.h>
#include <cstdio>

int main() {
    auto r = socketley::ctl::create("server", "myapp", "-p 9000 -s");
    if (r.exit_code != 0) return 1;

    socketley::ctl::send("myapp", "Hello from C++!");
    auto stats = socketley::ctl::stats("myapp");
    printf("%s\\n", stats.data.c_str());

    socketley::ctl::stop("myapp");
    socketley::ctl::remove("myapp");
}
// g++ -std=c++17 myapp.cpp -Iinclude/linux -o myapp
.fi
.PP
.B "Example: fleet management with globs"
.nf
for (int i = 0; i < 5; ++i) {
    std::string name  = "api_" + std::to_string(i);
    std::string flags = "-p " + std::to_string(9000+i) + " -s";
    socketley::ctl::create("server", name, flags);
}
socketley::ctl::command("start api_*");    // start all
socketley::ctl::command("stats api_*");    // query all
socketley::ctl::command("stop api_*");     // stop all
socketley::ctl::command("remove api_*");   // remove all
.fi
.PP
.B "Example: cache operations"
.nf
socketley::ctl::create("cache", "store", "-p 6379 --mode admin -s");
socketley::ctl::cache_set("store", "user:1", "alice");
auto r = socketley::ctl::cache_get("store", "user:1");
printf("user:1 = %s\\n", r.data.c_str());  // "alice"
socketley::ctl::cache_del("store", "user:1");
socketley::ctl::cache_flush("store", "/tmp/store.bin");
.fi
.SS Tier 2: Embed Engine (build from source)
Embed the full io_uring event loop and all four runtime types in your own binary.
Maximum performance with no IPC overhead. Requires
.B libsocketley_sdk.a
and link flags
.BR "-luring -lssl -lcrypto [-lluajit]" .
.PP
Headers:
.B socketley/core.h
(event_loop, runtime_manager, enums),
.B socketley/server.h ,
.B socketley/client.h ,
.B socketley/proxy.h ,
.B socketley/cache.h .
.PP
Define
.B SOCKETLEY_NO_LUA
to build without LuaJIT (omit
.B -lluajit
from link flags).
.PP
.B "High-Level Wrapper Classes (recommended)"
.PP
The
.B socketley::server\fR, \fBsocketley::client\fR, \fBsocketley::proxy\fR, and \fBsocketley::cache
classes wrap the raw engine API into a fluent, chainable interface.
All boilerplate (event loop, runtime manager, signal handling) is internal.
.PP
.B "socketley::server"
.nf
server(uint16_t port)

// Config (all return server& for chaining)
tls(cert, key)         max_connections(n)    rate_limit(r)
global_rate_limit(r)   idle_timeout(s)       lua(path)
mode(m)                udp()                 http_dir(path)
http_cache()           upstream(addr)        master_pw(pw)
drain()                group(g)              tick_interval(ms)

// Callbacks (return server& for chaining)
on_start(void())                             on_stop(void())
on_connect(void(int fd))                     on_disconnect(void(int fd))
on_message(void(int fd, string_view msg))    on_tick(void(double dt_ms))

// Actions
send(fd, msg)       broadcast(msg)      disconnect(fd)
peer_ip(fd)         clients()           multicast(fds, msg)
set_data(fd,k,v)    get_data(fd,k)

// Lifecycle
start()   stop()

// Escape hatches (raw engine access)
instance() -> server_instance*
manager()  -> runtime_manager&
loop()     -> event_loop&
.fi
.PP
.B "socketley::client"
.nf
client(string_view host, uint16_t port)

// Config
tls()              tls_ca(ca)         reconnect(max)
mode(m)            udp()              lua(path)
tick_interval(ms)

// Callbacks
on_start    on_stop    on_connect    on_disconnect
on_message(void(string_view msg))   on_tick

// Actions
send(msg)

// Lifecycle: start()  stop()
// Escape hatches: instance()  manager()  loop()
.fi
.PP
.B "socketley::proxy"
.nf
proxy(uint16_t port)

// Config
backend(addr)      strategy(s)        protocol(p)
tls(cert, key)     max_connections(n)  idle_timeout(s)
lua(path)          group(g)

// Callbacks: on_start  on_stop
// Lifecycle: start()  stop()
// Escape hatches: instance()  manager()  loop()
.fi
.PP
.B "socketley::cache"
.nf
cache(uint16_t port)

// Config
persistent(path)   max_memory(bytes)   eviction(policy)
resp()             mode(m)             tls(cert, key)
max_connections(n) idle_timeout(s)     replicate(target)
lua(path)          group(g)

// Callbacks: on_start  on_stop
// Lifecycle: start()  stop()
// Escape hatches: instance()  manager()  loop()
.fi
.PP
.B "Limitations:"
One
.B start()
per process (the signal handler points to one event_loop).
.B start()
blocks until SIGINT/SIGTERM. For multi-runtime or async patterns, use the raw API
via the escape hatches or directly.
.PP
.B "Example: echo server (3 lines)"
.nf
#include <socketley/server.h>
#include <cstdio>

int main() {
    socketley::server srv(9000);

    srv.on_connect([](int fd) {
        printf("client %d connected\\n", fd);
    });
    srv.on_message([&](int fd, std::string_view msg) {
        srv.send(fd, "echo: " + std::string(msg));
    });
    srv.on_disconnect([](int fd) {
        printf("client %d disconnected\\n", fd);
    });

    srv.start();
}
// g++ -std=c++23 echo.cpp -I. -Iinclude/linux \\
//     -Lbin/Release -lsocketley_sdk -luring -lssl -lcrypto
.fi
.PP
.B "Example: server with Lua scripting"
.nf
int main(int argc, char* argv[]) {
    socketley::server srv(9000);
    srv.lua(argv[1]);
    srv.start();
}
.fi
.PP
.B "Example: TCP proxy"
.nf
socketley::proxy px(8080);
px.backend("127.0.0.1:9001")
  .backend("127.0.0.1:9002")
  .protocol(protocol_tcp)
  .strategy(strategy_round_robin);
px.start();
.fi
.PP
.B "Example: Redis-compatible cache"
.nf
socketley::cache c(6379);
c.persistent("/var/data/store.dat")
 .resp()
 .max_memory(256 * 1024 * 1024)
 .eviction(evict_allkeys_lru);
c.start();
.fi
.PP
.B "Example: client with auto-reconnect"
.nf
socketley::client cli("127.0.0.1", 9000);
cli.reconnect(0);  // 0 = infinite
cli.on_connect([&](int) { cli.send("hello"); });
cli.on_message([](std::string_view msg) {
    printf("%.*s\\n", (int)msg.size(), msg.data());
});
cli.start();
.fi
.PP
.B "Raw Engine API (advanced)"
.PP
For multi-runtime processes or custom event loop control, use the raw types directly.
The wrapper classes use this API internally.
.PP
.B "Core pattern:"
create event_loop, create runtime_manager, create runtimes, configure, run, loop.
.PP
.B "C++ callbacks"
(alternative to Lua scripts, set on any runtime):
.nf
set_on_start(function<void()>)
set_on_stop(function<void()>)
set_on_connect(function<void(int fd)>)
set_on_disconnect(function<void(int fd)>)
set_on_client_message(function<void(int fd, string_view)>)
set_on_message(function<void(string_view)>)
set_on_tick(function<void(double dt_ms)>)
.fi
.PP
.B "Common runtime setters:"
.nf
set_port(uint16_t)            set_event_loop(event_loop*)
set_runtime_manager(mgr*)     set_cache_name(string_view)
set_tls(bool)                 set_cert_path(string_view)
set_key_path(string_view)     set_max_connections(uint32_t)
set_rate_limit(double)        set_idle_timeout(uint32_t)
set_log_file(string_view)     set_group(string_view)
set_drain(bool)               load_lua_script(string_view)
.fi
.PP
.B "Server-specific:"
.nf
set_mode(mode_inout|mode_in|mode_out|mode_master)
set_udp(bool)          set_http_dir(string_view)
lua_broadcast(msg)     lua_send_to(fd, msg)
lua_disconnect(fd)     lua_peer_ip(fd)
lua_clients()          lua_multicast(fds, msg)
.fi
.PP
.B "Cache-specific:"
.nf
set_mode(cache_mode_readonly|readwrite|admin)
set_persistent(path)   set_max_memory(bytes)
set_resp_forced(bool)  set_replicate_target(host:port)
.fi
.PP
.B "Proxy-specific:"
.nf
set_protocol(protocol_http|protocol_tcp)
set_strategy(strategy_round_robin|random|lua)
add_backend(addr)      clear_backends()
.fi
.PP
.B "Example: multi-runtime with raw API (server + cache)"
.nf
#include <socketley/server.h>
#include <socketley/cache.h>

// ... (event_loop + runtime_manager setup as above)

mgr.create(runtime_cache, "store");
auto* cache = static_cast<cache_instance*>(mgr.get("store"));
cache->set_port(6379);
cache->set_mode(cache_mode_admin);
cache->set_runtime_manager(&mgr);
cache->set_event_loop(&loop);

mgr.create(runtime_server, "api");
auto* srv = static_cast<server_instance*>(mgr.get("api"));
srv->set_port(9000);
srv->set_cache_name("store");  // clients can "cache set k v"
srv->set_runtime_manager(&mgr);
srv->set_event_loop(&loop);

mgr.start("store", loop);
mgr.start("api", loop);
loop.run();
.fi
.SS Cross-Platform SDK (Windows / macOS)
Header-only TCP clients for connecting to Socketley runtimes from non-Linux platforms.
Available in
.B include/windows/socketley/
and
.BR include/darwin/socketley/ .
.PP
.B socketley/ws_client.h
\(em WebSocket (RFC 6455) + raw TCP client for server runtimes.
Embedded SHA-1 and Base64 (no OpenSSL). Modes:
.BR ws_mode::websocket " and " ws_mode::raw_tcp .
.PP
.B socketley/cache_client.h
\(em text protocol client for cache runtimes. Supports all cache commands
(get, set, del, lpush, sadd, hset, expire, publish, subscribe, etc.).
Returns
.B cache_result
with
.IR ok ", " value ", " values ", " integer
fields.
.PP
Build with C++17, no external dependencies:
.RS
.nf
# MSVC
cl /std:c++17 /I include\\windows app.cpp

# clang++ (macOS)
clang++ -std=c++17 -I include/darwin app.cpp -o app

# g++ (Linux)
g++ -std=c++17 -I include/windows app.cpp -o app
.fi
.RE
.SS Tier 3: Daemon Attach (header-only)
.B socketley/attach.h
registers your own process as a runtime with a running daemon.
After attaching, your process shows up in
.BR "socketley ls" ,
.BR "socketley stats" ,
and
.BR "socketley ps" .
Fully self-contained (builds on control.h). Auto-deregisters on
.BR exit() .
.PP
.B "API:"
.nf
bool daemon_attach(name, type, port)  // register, auto-detach on exit
void daemon_detach(name)              // explicit deregister
void daemon_detach()                  // deregister attach'd name
.fi
.PP
.B "Example:"
.nf
#include <socketley/attach.h>
#include <cstdio>

int main() {
    // Start your own TCP server (any framework)
    // ...bind, listen on port 8080...

    if (socketley::daemon_attach("myservice", "server", 8080))
        printf("registered with daemon\\n");
    else
        printf("daemon not running (standalone mode)\\n");

    // Your accept loop here...
    // atexit() automatically calls daemon_detach()
}
// g++ -std=c++17 myapp.cpp -Iinclude/linux -o myapp
.fi
.SS Mixed: Engine + Daemon Attach (Tier 2 + 3)
Embed the full engine for maximum performance, and register with the daemon
for fleet monitoring. Best of both worlds.
.PP
.nf
#include <socketley/server.h>
#include <socketley/attach.h>

socketley::server srv(9000);
srv.on_message([&](int fd, std::string_view msg) {
    srv.send(fd, msg);
});

// Register with daemon so socketley ls/stats can see it
socketley::daemon_attach("app_srv", "server", 9000);

srv.start();  // daemon sees the runtime
.fi
.PP
.B "When to use each tier:"
.PP
.TP
.B "Tier 1"
Orchestration scripts, deployment tools, monitoring, CI/CD.
.TP
.B "Tier 2"
Custom daemons, game servers, IoT gateways, performance-critical services.
.TP
.B "Tier 3"
Legacy services, third-party processes, fleet visibility for external apps.
.TP
.B "Mixed"
Embedded engine with daemon monitoring \(em maximum performance with fleet management.
.SH EXIT STATUS
.TP
.B 0
Success.
.TP
.B 1
Error (invalid command, runtime not found, etc.).
.SH SEE ALSO
.BR docker (1),
.BR nginx (1),
.BR redis-server (1)
.SH BUGS
Report bugs at: https://github.com/socketley/socketley/issues
.SH AUTHORS
socketley was created for high-performance network runtime management.
