// ╔═══════════════════════════════════════════════════════════════════╗
// ║  socketley.h — Single-header SDK (stb-style)                    ║
// ║  Auto-generated by tools/amalgamate.sh — DO NOT EDIT BY HAND    ║
// ║                                                                  ║
// ║  Usage:                                                          ║
// ║    #define SOCKETLEY_IMPLEMENTATION   // in exactly ONE .cpp     ║
// ║    #include "socketley.h"                                        ║
// ║                                                                  ║
// ║  Optional defines (before #include):                             ║
// ║    #define SOCKETLEY_NO_LUA    — disable Lua/sol2 dependency     ║
// ║    #define SOCKETLEY_NO_HTTPS  — disable HTTP client in Lua      ║
// ║                                                                  ║
// ║  Link: -luring -lssl -lcrypto [-lluajit-5.1]                    ║
// ╚═══════════════════════════════════════════════════════════════════╝
#ifndef SOCKETLEY_H
#define SOCKETLEY_H

#ifndef __linux__
#  error "Socketley requires Linux (io_uring, kernel 5.11+)"
#endif

// ── System includes ──

#include <algorithm>
#include <arpa/inet.h>
#include <atomic>
#include <cctype>
#include <cerrno>
#include <charconv>
#include <chrono>
#include <cmath>
#include <csignal>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <dirent.h>
#include <fcntl.h>
#include <filesystem>
#include <fnmatch.h>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <liburing.h>
#include <linux/time_types.h>
#include <list>
#include <memory>
#include <mutex>
#include <netdb.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/sha.h>
#include <openssl/ssl.h>
#include <pwd.h>
#include <queue>
#include <random>
#include <shared_mutex>
#include <sstream>
#include <string>
#include <string_view>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/un.h>
#include <sys/utsname.h>
#include <unistd.h>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

#ifndef SOCKETLEY_NO_LUA
#include <sol/sol.hpp>
#endif // SOCKETLEY_NO_LUA

// ════════════════════════════════════════════════════════════════════
//  DECLARATIONS
// ════════════════════════════════════════════════════════════════════

// ── socketley/cli/command_hashing.h ──


constexpr uint32_t fnv1a(std::string_view sv)
{
    uint32_t hash = 2166136261u;
    for (char c : sv)
        hash = (hash ^ static_cast<uint8_t>(c)) * 16777619u;
    return hash;
}

// Case-insensitive hash (converts to lowercase on the fly, no allocation)
constexpr uint32_t fnv1a_lower(std::string_view sv)
{
    uint32_t hash = 2166136261u;
    for (char c : sv)
    {
        char lower = (c >= 'A' && c <= 'Z') ? static_cast<char>(c + 32) : c;
        hash = (hash ^ static_cast<uint8_t>(lower)) * 16777619u;
    }
    return hash;
}

// ── socketley/shared/runtime_definitions.h ──


enum runtime_state : uint8_t
{
    runtime_created = 0,
    runtime_running = 1,
    runtime_stopped = 2,
    runtime_failed  = 3
};

enum runtime_type : uint8_t
{
    runtime_server = 0,
    runtime_client = 1,
    runtime_proxy  = 2,
    runtime_cache  = 3
};

inline constexpr const char* type_to_string(runtime_type t)
{
    switch (t)
    {
        case runtime_server: return "server";
        case runtime_client: return "client";
        case runtime_proxy:  return "proxy";
        case runtime_cache:  return "cache";
    }
    return "unknown";
}

// ── socketley/cli/runtime_type_parser.h ──



inline bool parse_runtime_type(std::string_view str, runtime_type& out)
{
    switch (fnv1a(str))
    {
        case fnv1a("server"):
            out = runtime_server;
            return true;
        case fnv1a("client"):
            out = runtime_client;
            return true;
        case fnv1a("proxy"):
            out = runtime_proxy;
            return true;
        case fnv1a("cache"):
            out = runtime_cache;
            return true;
        default:
            return false;
    }
}

// ── socketley/shared/event_loop_definitions.h ──


class io_handler
{
public:
    virtual ~io_handler() = default;
    virtual void on_cqe(struct io_uring_cqe* cqe) = 0;
};

enum op_type : uint8_t
{
    op_accept           = 0,
    op_read             = 1,
    op_write            = 2,
    op_nop              = 3,
    op_multishot_accept = 4,
    op_read_provided    = 5,
    op_writev           = 6,
    op_recvmsg          = 7,
    op_timeout          = 8
};

struct io_request
{
    op_type type;
    int fd;
    char* buffer;
    uint32_t length;
    io_handler* owner;
};

// ── socketley/shared/id_generator.h ──


inline std::string generate_runtime_id()
{
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<uint32_t> dist(0, 0xFFFFFF);

    uint32_t id = dist(gen);

    std::ostringstream ss;
    ss << std::hex << std::setfill('0') << std::setw(6) << id;
    return ss.str();
}

// ── socketley/shared/scoped_fd.h ──


// RAII wrapper for file descriptors
class scoped_fd
{
public:
    scoped_fd() noexcept : m_fd(-1) {}
    explicit scoped_fd(int fd) noexcept : m_fd(fd) {}

    ~scoped_fd() { reset(); }

    scoped_fd(const scoped_fd&) = delete;
    scoped_fd& operator=(const scoped_fd&) = delete;

    scoped_fd(scoped_fd&& other) noexcept : m_fd(other.release()) {}

    scoped_fd& operator=(scoped_fd&& other) noexcept
    {
        if (this != &other)
            reset(other.release());
        return *this;
    }

    int get() const noexcept { return m_fd; }
    explicit operator bool() const noexcept { return m_fd >= 0; }

    int release() noexcept
    {
        int fd = m_fd;
        m_fd = -1;
        return fd;
    }

    void reset(int fd = -1) noexcept
    {
        if (m_fd >= 0)
            ::close(m_fd);
        m_fd = fd;
    }

private:
    int m_fd;
};

// ── socketley/shared/logging.h ──


enum log_level : uint8_t
{
    log_debug = 0,
    log_info  = 1,
    log_warn  = 2,
    log_error = 3
};

struct logger
{
    static inline log_level g_level = log_info;

    static void log(log_level level, const char* msg)
    {
        if (level < g_level)
            return;

        auto now = std::chrono::system_clock::now();
        auto t = std::chrono::system_clock::to_time_t(now);
        std::tm tm{};
        localtime_r(&t, &tm);

        const char* tag;
        switch (level)
        {
            case log_debug: tag = "DEBUG"; break;
            case log_info:  tag = "INFO";  break;
            case log_warn:  tag = "WARN";  break;
            case log_error: tag = "ERROR"; break;
            default:        tag = "?";     break;
        }

        std::fprintf(stderr, "[%02d:%02d:%02d] [%s] %s\n",
            tm.tm_hour, tm.tm_min, tm.tm_sec, tag, msg);
    }
};

#define LOG_DEBUG(msg) do { if (logger::g_level <= log_debug) logger::log(log_debug, msg); } while(0)
#define LOG_INFO(msg)  do { if (logger::g_level <= log_info)  logger::log(log_info,  msg); } while(0)
#define LOG_WARN(msg)  do { if (logger::g_level <= log_warn)  logger::log(log_warn,  msg); } while(0)
#define LOG_ERROR(msg) do { if (logger::g_level <= log_error) logger::log(log_error, msg); } while(0)

// ── socketley/shared/time_format.h ──


inline std::string format_duration(std::chrono::seconds duration)
{
    auto secs = duration.count();

    if (secs < 60)
        return std::to_string(secs) + " second" + (secs == 1 ? "" : "s");

    auto mins = secs / 60;
    if (mins < 60)
        return std::to_string(mins) + " minute" + (mins == 1 ? "" : "s");

    auto hours = mins / 60;
    if (hours < 24)
        return std::to_string(hours) + " hour" + (hours == 1 ? "" : "s");

    auto days = hours / 24;
    return std::to_string(days) + " day" + (days == 1 ? "" : "s");
}

inline std::string format_time_ago(std::chrono::system_clock::time_point tp)
{
    auto now = std::chrono::system_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::seconds>(now - tp);
    return format_duration(duration) + " ago";
}

inline std::string format_uptime(std::chrono::system_clock::time_point start_time)
{
    auto now = std::chrono::system_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::seconds>(now - start_time);
    return "Up " + format_duration(duration);
}

// ── socketley/shared/paths.h ──


struct socketley_paths
{
    std::filesystem::path socket_path;
    std::filesystem::path state_dir;     // runtimes/ JSON configs
    std::filesystem::path config_path;   // daemon config.lua
    bool system_mode = false;            // true if installed system-wide

    static socketley_paths resolve();
};

// ── socketley/shared/name_resolver.h ──


template<typename MapT>
std::vector<std::string> resolve_names_impl(
    const std::string_view* args, size_t count,
    const MapT& names, size_t start = 1)
{
    std::vector<std::string> result;
    for (size_t i = start; i < count; ++i)
    {
        std::string_view arg = args[i];
        if (arg.empty() || arg[0] == '-')
            continue;

        bool is_glob = arg.find_first_of("*?[") != std::string_view::npos;
        if (is_glob)
        {
            std::string pattern(arg);
            for (const auto& [name, val] : names)
                if (fnmatch(pattern.c_str(), name.c_str(), 0) == 0)
                    result.push_back(name);
        }
        else
        {
            if (names.find(arg) != names.end())
                result.push_back(std::string(arg));
        }
    }
    return result;
}

// ── socketley/shared/ws_protocol.h ──


// WebSocket frame opcodes
constexpr uint8_t WS_OP_TEXT  = 0x1;
constexpr uint8_t WS_OP_CLOSE = 0x8;
constexpr uint8_t WS_OP_PING  = 0x9;
constexpr uint8_t WS_OP_PONG  = 0xA;

// Max payload size (16 MB) to prevent memory exhaustion
constexpr uint64_t WS_MAX_PAYLOAD = 16 * 1024 * 1024;

static constexpr const char* WS_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

struct ws_frame
{
    uint8_t opcode;
    std::string payload;
    size_t consumed;
};

// Compute Sec-WebSocket-Accept from client key
inline std::string ws_accept_key(std::string_view client_key)
{
    std::string combined;
    combined.reserve(client_key.size() + 36);
    combined.append(client_key);
    combined.append(WS_GUID);

    unsigned char sha1_hash[SHA_DIGEST_LENGTH];
    SHA1(reinterpret_cast<const unsigned char*>(combined.data()),
         combined.size(), sha1_hash);

    // Base64 encode (SHA1 = 20 bytes -> 28 chars base64 + null)
    char b64[32];
    EVP_EncodeBlock(reinterpret_cast<unsigned char*>(b64), sha1_hash, SHA_DIGEST_LENGTH);
    return std::string(b64);
}

// Build 101 Switching Protocols response
inline std::string ws_handshake_response(std::string_view client_key)
{
    std::string accept = ws_accept_key(client_key);
    std::string resp;
    resp.reserve(160 + accept.size());
    resp += "HTTP/1.1 101 Switching Protocols\r\n"
            "Upgrade: websocket\r\n"
            "Connection: Upgrade\r\n"
            "Sec-WebSocket-Accept: ";
    resp += accept;
    resp += "\r\n\r\n";
    return resp;
}

// Create text frame (server->client, unmasked)
inline std::string ws_frame_text(std::string_view payload)
{
    std::string frame;
    size_t len = payload.size();

    if (len <= 125)
    {
        frame.resize(2 + len);
        frame[0] = static_cast<char>(0x81); // FIN + text
        frame[1] = static_cast<char>(len);
        std::memcpy(&frame[2], payload.data(), len);
    }
    else if (len <= 65535)
    {
        frame.resize(4 + len);
        frame[0] = static_cast<char>(0x81);
        frame[1] = static_cast<char>(126);
        frame[2] = static_cast<char>((len >> 8) & 0xFF);
        frame[3] = static_cast<char>(len & 0xFF);
        std::memcpy(&frame[4], payload.data(), len);
    }
    else
    {
        frame.resize(10 + len);
        frame[0] = static_cast<char>(0x81);
        frame[1] = static_cast<char>(127);
        for (int i = 0; i < 8; i++)
            frame[2 + i] = static_cast<char>((len >> (56 - 8 * i)) & 0xFF);
        std::memcpy(&frame[10], payload.data(), len);
    }

    return frame;
}

// Create pong frame
inline std::string ws_frame_pong(std::string_view payload)
{
    // RFC 6455: control frame payloads must not exceed 125 bytes
    if (payload.size() > 125)
        payload = payload.substr(0, 125);
    std::string frame;
    frame.resize(2 + payload.size());
    frame[0] = static_cast<char>(0x80 | WS_OP_PONG); // FIN + pong
    frame[1] = static_cast<char>(payload.size());
    if (!payload.empty())
        std::memcpy(&frame[2], payload.data(), payload.size());
    return frame;
}

// Create close frame
inline std::string ws_frame_close()
{
    std::string frame(2, '\0');
    frame[0] = static_cast<char>(0x80 | WS_OP_CLOSE); // FIN + close
    frame[1] = 0;
    return frame;
}

// Parse one frame from buffer. Returns false if incomplete.
// Handles masked client frames (RFC 6455 requires clients to mask).
inline bool ws_parse_frame(const char* data, size_t len, ws_frame& out)
{
    if (len < 2)
        return false;

    uint8_t b0 = static_cast<uint8_t>(data[0]);
    uint8_t b1 = static_cast<uint8_t>(data[1]);

    out.opcode = b0 & 0x0F;
    bool fin = (b0 & 0x80) != 0;
    bool masked = (b1 & 0x80) != 0;
    uint64_t payload_len = b1 & 0x7F;
    size_t header_size = 2;

    if (payload_len == 126)
    {
        if (len < 4) return false;
        payload_len = (static_cast<uint64_t>(static_cast<uint8_t>(data[2])) << 8) |
                       static_cast<uint64_t>(static_cast<uint8_t>(data[3]));
        header_size = 4;
    }
    else if (payload_len == 127)
    {
        if (len < 10) return false;
        payload_len = 0;
        for (int i = 0; i < 8; i++)
            payload_len = (payload_len << 8) | static_cast<uint64_t>(static_cast<uint8_t>(data[2 + i]));
        header_size = 10;
    }

    if (payload_len > WS_MAX_PAYLOAD)
        return false;

    // Reject control frames with payload > 125 (RFC 6455 §5.5)
    if (out.opcode >= 0x8 && payload_len > 125)
        return false;

    // Reject fragmented frames (FIN=0) — we don't support reassembly
    if (!fin)
        return false;

    size_t mask_size = masked ? 4 : 0;
    size_t total = header_size + mask_size + payload_len;
    if (len < total)
        return false;

    const uint8_t* mask_key = masked ?
        reinterpret_cast<const uint8_t*>(data + header_size) : nullptr;
    const char* payload_start = data + header_size + mask_size;

    out.payload.resize(payload_len);
    if (masked)
    {
        for (uint64_t i = 0; i < payload_len; i++)
            out.payload[i] = payload_start[i] ^ mask_key[i & 3];
    }
    else
    {
        std::memcpy(out.payload.data(), payload_start, payload_len);
    }

    out.consumed = total;
    return true;
}

// ── socketley/shared/tls_context.h ──


// Forward declare OpenSSL types to avoid pulling in headers everywhere
typedef struct ssl_ctx_st SSL_CTX;
typedef struct ssl_st SSL;

// TLS context wrapper for server/client runtimes
// Uses OpenSSL BIO memory pairs for non-blocking integration with io_uring
class tls_context
{
public:
    tls_context();
    ~tls_context();

    // Initialize as server (accept connections)
    bool init_server(std::string_view cert_path, std::string_view key_path);

    // Initialize as client (connect to server)
    bool init_client(std::string_view ca_path = {});

    // Create a new SSL connection from this context
    SSL* create_ssl() const;

    // Accept a TLS handshake on an SSL object
    // Returns: 1 = complete, 0 = want more data, -1 = error
    static int do_handshake(SSL* ssl);

    // Read decrypted data from SSL
    // Returns bytes read, 0 = want more data, -1 = error/closed
    static int ssl_read(SSL* ssl, char* buf, int len);

    // Write data to SSL (encrypts)
    // Returns bytes written, 0 = want more data, -1 = error
    static int ssl_write(SSL* ssl, const char* buf, int len);

    // Read encrypted data from SSL's output BIO (to send via io_uring)
    static int bio_read_out(SSL* ssl, char* buf, int len);

    // Write encrypted data into SSL's input BIO (received from io_uring)
    static int bio_write_in(SSL* ssl, const char* buf, int len);

    // Check if SSL needs to write (has pending encrypted output)
    static bool has_pending_out(SSL* ssl);

    // Free an SSL connection
    static void free_ssl(SSL* ssl);

    bool is_initialized() const { return m_ctx != nullptr; }

private:
    SSL_CTX* m_ctx = nullptr;
};

// ── socketley/runtime/cache/resp_parser.h ──


// RESP2 protocol encoder/decoder for Redis compatibility
// Auto-detect: first byte '*' = RESP mode, else plaintext

namespace resp {

// Safety limits to prevent resource exhaustion
constexpr int RESP_MAX_ARRAY_SIZE = 1024;
constexpr int RESP_MAX_BULK_LEN = 512 * 1024; // 512 KB

// ─── Zero-allocation encoding (appends directly to caller's buffer) ───

inline void encode_ok_into(std::string& buf)
{
    buf.append("+OK\r\n", 5);
}

inline void encode_null_into(std::string& buf)
{
    buf.append("$-1\r\n", 5);
}

inline void encode_error_into(std::string& buf, std::string_view msg)
{
    buf.append("-ERR ", 5);
    buf.append(msg.data(), msg.size());
    buf.append("\r\n", 2);
}

inline void encode_simple_into(std::string& buf, std::string_view msg)
{
    buf += '+';
    buf.append(msg.data(), msg.size());
    buf.append("\r\n", 2);
}

inline void encode_integer_into(std::string& buf, int64_t n)
{
    char tmp[24];
    auto [end, ec] = std::to_chars(tmp, tmp + sizeof(tmp), n);
    buf += ':';
    buf.append(tmp, static_cast<size_t>(end - tmp));
    buf.append("\r\n", 2);
}

inline void encode_bulk_into(std::string& buf, std::string_view str)
{
    char tmp[24];
    auto [end, ec] = std::to_chars(tmp, tmp + sizeof(tmp), str.size());
    buf += '$';
    buf.append(tmp, static_cast<size_t>(end - tmp));
    buf.append("\r\n", 2);
    buf.append(str.data(), str.size());
    buf.append("\r\n", 2);
}

inline void encode_array_header_into(std::string& buf, int n)
{
    char tmp[16];
    auto [end, ec] = std::to_chars(tmp, tmp + sizeof(tmp), n);
    buf += '*';
    buf.append(tmp, static_cast<size_t>(end - tmp));
    buf.append("\r\n", 2);
}

// ─── Allocating encoding (kept for use in execute() / tests) ───

inline std::string encode_ok()
{
    return "+OK\r\n";
}

inline std::string encode_error(std::string_view msg)
{
    std::string out;
    out.reserve(5 + msg.size());
    out += "-ERR ";
    out.append(msg.data(), msg.size());
    out += "\r\n";
    return out;
}

inline std::string encode_integer(int64_t n)
{
    std::string out = ":";
    out += std::to_string(n);
    out += "\r\n";
    return out;
}

inline std::string encode_bulk(std::string_view str)
{
    std::string out = "$";
    out += std::to_string(str.size());
    out += "\r\n";
    out.append(str.data(), str.size());
    out += "\r\n";
    return out;
}

inline std::string encode_null()
{
    return "$-1\r\n";
}

inline std::string encode_array_header(int n)
{
    std::string out = "*";
    out += std::to_string(n);
    out += "\r\n";
    return out;
}

inline std::string encode_simple(std::string_view msg)
{
    std::string out = "+";
    out.append(msg.data(), msg.size());
    out += "\r\n";
    return out;
}

// ─── Decoding ───

enum class parse_result { ok, incomplete, error };

// Parse a single RESP message from partial buffer.
// Returns parse_result::ok and fills `args` with extracted strings.
// `consumed` is set to how many bytes were consumed from `buf`.
inline parse_result parse_message(std::string_view buf, std::vector<std::string>& args, size_t& consumed)
{
    args.clear();
    consumed = 0;

    if (buf.empty())
        return parse_result::incomplete;

    if (buf[0] != '*')
        return parse_result::error;

    // Find end of array count line
    size_t pos = buf.find("\r\n");
    if (pos == std::string_view::npos)
        return parse_result::incomplete;

    int count = 0;
    auto [ptr, ec] = std::from_chars(buf.data() + 1, buf.data() + pos, count);
    if (ec != std::errc{} || count < 0 || count > RESP_MAX_ARRAY_SIZE)
        return parse_result::error;

    size_t offset = pos + 2;

    for (int i = 0; i < count; i++)
    {
        if (offset >= buf.size())
            return parse_result::incomplete;

        if (buf[offset] != '$')
            return parse_result::error;

        size_t end = buf.find("\r\n", offset);
        if (end == std::string_view::npos)
            return parse_result::incomplete;

        int len = 0;
        auto [p2, e2] = std::from_chars(buf.data() + offset + 1, buf.data() + end, len);
        if (e2 != std::errc{} || len < 0 || len > RESP_MAX_BULK_LEN)
            return parse_result::error;

        offset = end + 2;

        if (offset + static_cast<size_t>(len) + 2 > buf.size())
            return parse_result::incomplete;

        args.emplace_back(buf.data() + offset, static_cast<size_t>(len));
        offset += static_cast<size_t>(len) + 2; // skip \r\n
    }

    consumed = offset;
    return parse_result::ok;
}

// Zero-allocation RESP parser: fills string_view array pointing into buf.
// args[] must have room for at least max_args entries.
// Safe to call in a tight loop — no heap allocations.
inline parse_result parse_message_views(std::string_view buf,
    std::string_view* args, int max_args, int& argc, size_t& consumed)
{
    argc = 0;
    consumed = 0;

    if (buf.empty())
        return parse_result::incomplete;

    if (buf[0] != '*')
        return parse_result::error;

    size_t pos = buf.find("\r\n");
    if (pos == std::string_view::npos)
        return parse_result::incomplete;

    int count = 0;
    auto [ptr, ec] = std::from_chars(buf.data() + 1, buf.data() + pos, count);
    if (ec != std::errc{} || count < 0 || count > RESP_MAX_ARRAY_SIZE || count > max_args)
        return parse_result::error;

    size_t offset = pos + 2;

    for (int i = 0; i < count; i++)
    {
        if (offset >= buf.size())
            return parse_result::incomplete;

        if (buf[offset] != '$')
            return parse_result::error;

        size_t end = buf.find("\r\n", offset);
        if (end == std::string_view::npos)
            return parse_result::incomplete;

        int len = 0;
        auto [p2, e2] = std::from_chars(buf.data() + offset + 1, buf.data() + end, len);
        if (e2 != std::errc{} || len < 0 || len > RESP_MAX_BULK_LEN)
            return parse_result::error;

        offset = end + 2;

        if (offset + static_cast<size_t>(len) + 2 > buf.size())
            return parse_result::incomplete;

        args[i] = std::string_view(buf.data() + offset, static_cast<size_t>(len));
        offset += static_cast<size_t>(len) + 2;
    }

    argc = count;
    consumed = offset;
    return parse_result::ok;
}

// Convert uppercase Redis command to lowercase for FNV-1a dispatch
inline void to_lower(std::string& s)
{
    for (auto& c : s)
    {
        if (c >= 'A' && c <= 'Z')
            c += 32;
    }
}

} // namespace resp

// ── socketley/runtime/cache/cache_store.h ──


// Transparent hash for heterogeneous lookup (avoids string copies on find/erase)
struct string_hash
{
    using is_transparent = void;

    size_t operator()(std::string_view sv) const noexcept
    {
        return std::hash<std::string_view>{}(sv);
    }

    size_t operator()(const std::string& s) const noexcept
    {
        return std::hash<std::string_view>{}(s);
    }
};

struct string_equal
{
    using is_transparent = void;

    bool operator()(std::string_view lhs, std::string_view rhs) const noexcept
    {
        return lhs == rhs;
    }
};

using string_map = std::unordered_map<std::string, std::string, string_hash, string_equal>;
using list_map = std::unordered_map<std::string, std::deque<std::string>, string_hash, string_equal>;
using set_inner = std::unordered_set<std::string, string_hash, string_equal>;
using set_map = std::unordered_map<std::string, set_inner, string_hash, string_equal>;
using hash_inner = std::unordered_map<std::string, std::string, string_hash, string_equal>;
using hash_map = std::unordered_map<std::string, hash_inner, string_hash, string_equal>;
using expiry_map = std::unordered_map<std::string, std::chrono::steady_clock::time_point, string_hash, string_equal>;
using channel_map = std::unordered_map<std::string, std::unordered_set<int>, string_hash, string_equal>;

enum eviction_policy : uint8_t
{
    evict_none           = 0,
    evict_allkeys_lru    = 1,
    evict_allkeys_random = 2
};

class cache_store
{
public:
    // --- Strings (existing) ---
    bool set(std::string_view key, std::string_view value);
    bool get(std::string_view key, std::string& out) const;
    const std::string* get_ptr(std::string_view key) const;

    // --- Lists ---
    bool lpush(std::string_view key, std::string_view val);
    bool rpush(std::string_view key, std::string_view val);
    bool lpop(std::string_view key, std::string& out);
    bool rpop(std::string_view key, std::string& out);
    int llen(std::string_view key) const;
    const std::deque<std::string>* list_ptr(std::string_view key) const;
    const std::string* lindex(std::string_view key, int idx) const;

    // --- Sets ---
    // Returns: 1 = added, 0 = already exists, -1 = type conflict
    int sadd(std::string_view key, std::string_view member);
    bool srem(std::string_view key, std::string_view member);
    bool sismember(std::string_view key, std::string_view member) const;
    int scard(std::string_view key) const;
    const set_inner* set_ptr(std::string_view key) const;

    // --- Hashes ---
    bool hset(std::string_view key, std::string_view field, std::string_view val);
    const std::string* hget(std::string_view key, std::string_view field) const;
    bool hdel(std::string_view key, std::string_view field);
    int hlen(std::string_view key) const;
    const hash_inner* hash_ptr(std::string_view key) const;

    // --- TTL / Expiry ---
    bool set_expiry(std::string_view key, int seconds);
    int get_ttl(std::string_view key) const;    // -1 = no ttl, -2 = key not found
    bool persist(std::string_view key);
    void check_expiry(std::string_view key);
    std::vector<std::string> sweep_expired();  // removes expired keys, returns their names

    // --- Millisecond-precision TTL ---
    bool set_expiry_ms(std::string_view key, int64_t ms);
    int64_t get_pttl(std::string_view key) const;  // ms; -1=no ttl, -2=not found

    // --- Set if not exists ---
    bool setnx(std::string_view key, std::string_view value);

    // --- Cursor scan (stateless offset cursor; returns next cursor, 0=done) ---
    uint64_t scan(uint64_t cursor, std::string_view pattern,
                  size_t count, std::vector<std::string_view>& out) const;

    // --- Atomic increment ---
    bool incr(std::string_view key, int64_t delta, int64_t& result);

    // --- String extras ---
    size_t append(std::string_view key, std::string_view suffix);  // returns new length
    size_t strlen_key(std::string_view key) const;                  // 0 if missing
    bool getset(std::string_view key, std::string_view newval, std::string& oldval);

    // --- Type / Keys ---
    std::string_view type(std::string_view key) const;
    // returns "string", "list", "set", "hash", or "none"
    void keys(std::string_view pattern, std::vector<std::string_view>& out) const;

    // --- General ---
    bool del(std::string_view key);
    uint32_t size() const;
    bool exists(std::string_view key) const;

    bool save(std::string_view path) const;
    bool load(std::string_view path);

    // --- Eviction / Memory ---
    void set_max_memory(size_t bytes);
    size_t get_max_memory() const { return m_max_memory; }
    size_t get_memory_used() const { return m_current_memory; }
    void set_eviction(eviction_policy policy);
    eviction_policy get_eviction() const { return m_eviction; }
    bool check_memory(size_t needed);  // returns false if OOM and evict_none

    // --- Pub/Sub ---
    void subscribe(int fd, std::string_view channel);
    void unsubscribe(int fd, std::string_view channel);
    void unsubscribe_all(int fd);
    const std::unordered_set<int>* get_subscribers(std::string_view channel) const;
    size_t channel_count() const { return m_channels.size(); }

private:
    bool has_type_conflict_for_string(std::string_view key) const;
    bool has_type_conflict_for_list(std::string_view key) const;
    bool has_type_conflict_for_set(std::string_view key) const;
    bool has_type_conflict_for_hash(std::string_view key) const;

    bool save_v2(std::string_view path) const;
    bool load_v2(std::ifstream& file);
    bool load_v1(std::ifstream& file, uint32_t first_key_len);

    void touch_lru(std::string_view key);
    bool try_evict(size_t needed);
    void track_add(size_t bytes);
    void track_sub(size_t bytes);

    string_map m_data;
    list_map m_lists;
    set_map m_sets;
    hash_map m_hashes;
    expiry_map m_expiry;

    // Eviction / Memory
    size_t m_max_memory = 0;
    size_t m_current_memory = 0;
    eviction_policy m_eviction = evict_none;
    std::list<std::string> m_lru_order;
    std::unordered_map<std::string, std::list<std::string>::iterator, string_hash, string_equal> m_lru_map;

    // Pub/Sub
    channel_map m_channels;
};

// ── socketley/shared/event_loop.h ──



struct buf_ring_pool
{
    struct io_uring_buf_ring* ring{nullptr};
    char* base{nullptr};
    uint32_t buf_count{0};
    uint32_t buf_size{0};
};

class event_loop
{
public:
    explicit event_loop(uint32_t queue_depth = 2048);
    ~event_loop();

    bool init();
    void run();
    void request_stop();
    int get_signal_write_fd() const;

    // Batched submissions - these queue SQEs without submitting
    void submit_accept(int listen_fd, struct sockaddr_in* addr, socklen_t* addrlen, io_request* req);
    void submit_multishot_accept(int listen_fd, io_request* req);
    void submit_read(int fd, char* buf, uint32_t len, io_request* req);
    void submit_write(int fd, const char* buf, uint32_t len, io_request* req);
    void submit_writev(int fd, struct iovec* iovs, uint32_t count, io_request* req);
    void submit_recvmsg(int fd, struct msghdr* msg, io_request* req);
    void submit_timeout(struct __kernel_timespec* ts, io_request* req);

    // Provided buffer ring API
    bool setup_buf_ring(uint16_t group_id, uint32_t buf_count, uint32_t buf_size);
    void submit_read_provided(int fd, uint16_t group_id, io_request* req);
    // Cancel all pending io_uring ops for a fd (user_data=null, CQE is ignored).
    // Submit this BEFORE close(fd) to guarantee the kernel generates cancellation
    // CQEs before any subsequently-submitted timeout/cleanup SQE fires.
    void submit_cancel_fd(int fd);
    char* get_buf_ptr(uint16_t group_id, uint16_t buf_id);
    void return_buf(uint16_t group_id, uint16_t buf_id);
    bool has_buf_ring(uint16_t group_id) const;

    // Flush all pending submissions (single syscall)
    void flush();

    struct io_uring* get_ring();

    // Check if multishot accept is supported
    static bool supports_multishot_accept();

private:
    void setup_signal_pipe();

    struct io_uring m_ring{};
    std::atomic<bool> m_running;
    uint32_t m_queue_depth;
    uint32_t m_pending_submissions{0};
    int m_signal_pipe[2]{-1, -1};
    io_request m_signal_req{};
    char m_signal_buf{};
    bool m_multishot_supported{false};
    bool m_sqpoll_enabled{false};
    std::unordered_map<uint16_t, buf_ring_pool> m_buf_rings;
};

// ── socketley/shared/daemon_client.h ──


namespace socketley {

// Attach this process to a running Socketley daemon.
// Shows up in `socketley ps/ls`; `socketley stop <name>` sends SIGTERM.
// On success calls atexit(daemon_detach) automatically. Returns true on success.
bool daemon_attach(std::string_view name, std::string_view type, uint16_t port);

// Remove this process from the daemon registry.
// Safe to call multiple times; no-op if not attached or already detached.
void daemon_detach();

} // namespace socketley

// ── socketley/shared/lua_context.h ──


#ifndef SOCKETLEY_NO_LUA


class runtime_instance;

// Lua context for a runtime - manages state and bindings
class lua_context
{
public:
    lua_context();
    ~lua_context();

    // Load and execute a Lua script, registering callbacks
    bool load_script(std::string_view path, runtime_instance* owner);

    // Get the Lua state (for callback invocation)
    sol::state& state() { return m_lua; }

    // Update self.state to reflect current runtime state
    void update_self_state(const char* state_str);

    // Check if context has valid callbacks
    bool has_on_start() const;
    bool has_on_stop() const;
    bool has_on_message() const;
    bool has_on_send() const;
    bool has_on_connect() const;
    bool has_on_disconnect() const;
    bool has_on_route() const;
    bool has_on_master_auth() const;
    bool has_on_client_message() const;
    bool has_on_tick() const;
    bool has_on_miss() const;
    bool has_on_write() const;
    bool has_on_delete() const;
    bool has_on_expire() const;
    bool has_on_auth() const;
    bool has_on_websocket() const;
    bool has_on_proxy_request()  const;
    bool has_on_proxy_response() const;
    bool has_on_cluster_join()   const;
    bool has_on_cluster_leave()  const;
    bool has_on_group_change()   const;

    // Get callbacks
    sol::function& on_start() { return m_on_start; }
    sol::function& on_stop() { return m_on_stop; }
    sol::function& on_message() { return m_on_message; }
    sol::function& on_send() { return m_on_send; }
    sol::function& on_connect() { return m_on_connect; }
    sol::function& on_disconnect() { return m_on_disconnect; }
    sol::function& on_route() { return m_on_route; }
    sol::function& on_master_auth() { return m_on_master_auth; }
    sol::function& on_client_message() { return m_on_client_message; }
    sol::function& on_tick() { return m_on_tick; }
    sol::function& on_miss()      { return m_on_miss; }
    sol::function& on_write()     { return m_on_write; }
    sol::function& on_delete_cb() { return m_on_delete; }  // avoid clash with std::delete
    sol::function& on_expire()    { return m_on_expire; }
    sol::function& on_auth()        { return m_on_auth; }
    sol::function& on_websocket()   { return m_on_websocket; }
    sol::function& on_proxy_request()  { return m_on_proxy_request; }
    sol::function& on_proxy_response() { return m_on_proxy_response; }
    sol::function& on_cluster_join()   { return m_on_cluster_join; }
    sol::function& on_cluster_leave()  { return m_on_cluster_leave; }
    sol::function& on_group_change()   { return m_on_group_change; }
    uint32_t get_tick_ms() const { return m_tick_ms; }

    // Cross-runtime pub/sub dispatch (called from runtime_instance)
    void dispatch_publish(std::string_view cache_name, std::string_view channel, std::string_view message);

private:
    void register_bindings(runtime_instance* owner);
    void register_server_table(runtime_instance* owner, sol::table& self);
    void register_client_table(runtime_instance* owner, sol::table& self);
    void register_cache_table(runtime_instance* owner, sol::table& self);
    void register_proxy_table(runtime_instance* owner, sol::table& self);

    sol::state m_lua;
    sol::function m_on_start;
    sol::function m_on_stop;
    sol::function m_on_message;
    sol::function m_on_send;
    sol::function m_on_connect;
    sol::function m_on_disconnect;
    sol::function m_on_route;
    sol::function m_on_master_auth;
    sol::function m_on_client_message;
    sol::function m_on_tick;
    sol::function m_on_miss;
    sol::function m_on_write;
    sol::function m_on_delete;
    sol::function m_on_expire;
    sol::function m_on_auth;
    sol::function m_on_websocket;
    sol::function m_on_proxy_request;
    sol::function m_on_proxy_response;
    sol::function m_on_cluster_join;
    sol::function m_on_cluster_leave;
    sol::function m_on_group_change;
    uint32_t m_tick_ms{0};

    // Timer lifetime guard — set to false in destructor; timers check before firing
    std::shared_ptr<bool> m_alive{std::make_shared<bool>(true)};

    // Cross-runtime pub/sub: key = cache_name + '\0' + channel
    std::unordered_map<std::string, std::vector<sol::function>> m_subscriptions;
};

#else // SOCKETLEY_NO_LUA


class runtime_instance;

// No-op stub — same public interface, no LuaJIT required
class lua_context
{
public:
    lua_context() = default;
    ~lua_context() = default;

    bool load_script(std::string_view, runtime_instance*) { return true; }
    void update_self_state(const char*) {}

    bool has_on_start()          const { return false; }
    bool has_on_stop()           const { return false; }
    bool has_on_message()        const { return false; }
    bool has_on_send()           const { return false; }
    bool has_on_connect()        const { return false; }
    bool has_on_disconnect()     const { return false; }
    bool has_on_route()          const { return false; }
    bool has_on_master_auth()    const { return false; }
    bool has_on_client_message() const { return false; }
    bool has_on_tick()           const { return false; }
    bool has_on_miss()           const { return false; }
    bool has_on_write()          const { return false; }
    bool has_on_delete()         const { return false; }
    bool has_on_expire()         const { return false; }
    bool has_on_auth()           const { return false; }
    bool has_on_websocket()      const { return false; }
    bool has_on_proxy_request()  const { return false; }
    bool has_on_proxy_response() const { return false; }
    bool has_on_cluster_join()   const { return false; }
    bool has_on_cluster_leave()  const { return false; }
    bool has_on_group_change()   const { return false; }
    uint32_t get_tick_ms()       const { return 0; }
    void dispatch_publish(std::string_view, std::string_view, std::string_view) {}
    // on_*() callbacks omitted — only called when has_*() returns true,
    // and guarded by #ifndef SOCKETLEY_NO_LUA at each call site.
};

#endif // SOCKETLEY_NO_LUA

// ── socketley/shared/runtime_instance.h ──


#ifndef SOCKETLEY_NO_LUA
#endif

class event_loop;
class lua_context;
class runtime_manager;

class runtime_instance : public io_handler
{
public:
    runtime_instance(runtime_type type, std::string_view name);
    ~runtime_instance() override;

    bool start(event_loop& loop);
    bool stop(event_loop& loop);

    void on_cqe(struct io_uring_cqe* cqe) override = 0;
    virtual bool setup(event_loop& loop) = 0;
    virtual void teardown(event_loop& loop) = 0;

    runtime_state get_state() const;
    runtime_type get_type() const;
    std::string_view get_name() const;
    void set_name(std::string_view name);
    std::string_view get_id() const;
    void set_id(std::string_view id);

    std::chrono::system_clock::time_point get_created_time() const;
    std::chrono::system_clock::time_point get_start_time() const;

    void set_port(uint16_t port);
    uint16_t get_port() const;

    void set_log_file(std::string_view path);
    std::string_view get_log_file() const;

    void set_write_file(std::string_view path);
    std::string_view get_write_file() const;

    void set_test_mode(bool enabled);
    bool get_test_mode() const;

    void set_target(std::string_view target);
    std::string_view get_target() const;

    void set_cache_name(std::string_view name);
    std::string_view get_cache_name() const;

    // Bash output settings
    void set_bash_output(bool enabled);
    void set_bash_prefix(bool enabled);
    void set_bash_timestamp(bool enabled);
    bool get_bash_output() const;
    bool get_bash_prefix() const;
    bool get_bash_timestamp() const;

    // Connection count (virtual, implemented per runtime type)
    virtual size_t get_connection_count() const { return 0; }

    // Max connections
    void set_max_connections(uint32_t max);
    uint32_t get_max_connections() const;

    // Rate limiting (messages per second, 0 = unlimited)
    void set_rate_limit(double rate);
    double get_rate_limit() const;

    // Global rate limiting (across all connections, messages per second, 0 = unlimited)
    void set_global_rate_limit(double rate);
    double get_global_rate_limit() const;

    // Idle connection timeout (seconds, 0 = disabled)
    void set_idle_timeout(uint32_t seconds);
    uint32_t get_idle_timeout() const;

    // Graceful shutdown
    void set_drain(bool enabled);
    bool get_drain() const;

    // Reconnect (client only)
    void set_reconnect(int max_attempts);
    int get_reconnect() const;

    // TLS
    void set_tls(bool enabled);
    bool get_tls() const;
    void set_cert_path(std::string_view path);
    std::string_view get_cert_path() const;
    void set_key_path(std::string_view path);
    std::string_view get_key_path() const;
    void set_ca_path(std::string_view path);
    std::string_view get_ca_path() const;

    // Stats
    virtual std::string get_stats() const;
    std::atomic<uint64_t> m_stat_total_connections{0};
    std::atomic<uint64_t> m_stat_total_messages{0};
    std::atomic<uint64_t> m_stat_bytes_in{0};
    std::atomic<uint64_t> m_stat_bytes_out{0};

    // Lua hot-reload
    bool reload_lua_script();
    std::string_view get_lua_script_path() const;

    // Interactive mode observer fds
    void add_interactive_fd(int fd);
    void remove_interactive_fd(int fd);
    void notify_interactive(std::string_view msg) const;

    // UDP mode (virtual, implemented by server/client)
    virtual bool is_udp() const { return false; }

    // Group tagging (for dynamic proxy backend discovery)
    void set_group(std::string_view group);
    std::string_view get_group() const;

    // Ownership system
    void set_owner(std::string_view owner_name);
    std::string_view get_owner() const;
    void set_lua_created(bool v);
    bool is_lua_created() const;

    // External (attach) mode — runtime is managed by another process
    void mark_external();
    bool is_external() const;
    void set_pid(pid_t pid);
    pid_t get_pid() const;

    enum class child_policy { stop, remove };
    void set_child_policy(child_policy p);
    child_policy get_child_policy() const;

    // Runtime manager / event loop (base class — used by Lua management API)
    void set_runtime_manager(runtime_manager* mgr);
    void set_event_loop(event_loop* loop);
    runtime_manager* get_runtime_manager() const;
    event_loop* get_event_loop() const;

    // Lua integration
    bool load_lua_script(std::string_view path);
    lua_context* lua() const { return m_lua.get(); }

    // ── C++ event callbacks (alternative to Lua) ─────────────────────────────
    // If set, the C++ callback is invoked *instead of* the Lua callback for that event.
    // Use set_tick_interval() to control the tick period when not using Lua.
    void set_on_start          (std::function<void()>                         cb);
    void set_on_stop           (std::function<void()>                         cb);
    void set_on_connect        (std::function<void(int fd)>                   cb);
    void set_on_disconnect     (std::function<void(int fd)>                   cb);
    void set_on_client_message (std::function<void(int fd, std::string_view)> cb);
    void set_on_message        (std::function<void(std::string_view)>         cb);
    void set_on_tick           (std::function<void(double dt_ms)>             cb);
    void set_tick_interval     (uint32_t ms);   // tick period in ms; 0 = use Lua value (default)

    // Cross-runtime pub/sub dispatch (called by runtime_manager on publish)
    virtual void on_publish_dispatch(std::string_view cache_name, std::string_view channel, std::string_view message);

    // Virtual methods for Lua actions (overridden by specific runtimes)
    virtual void lua_send(std::string_view msg) {}
    virtual void lua_broadcast(std::string_view msg) {}
    virtual void lua_send_to(int client_id, std::string_view msg) {}

    // Virtual methods for Lua cache access (overridden by cache_instance)
    virtual std::string lua_cache_get(std::string_view key) { return ""; }
    virtual bool lua_cache_set(std::string_view key, std::string_view value) { return false; }
    virtual bool lua_cache_del(std::string_view key) { return false; }

    // Lists
    virtual bool lua_cache_lpush(std::string_view key, std::string_view val) { return false; }
    virtual bool lua_cache_rpush(std::string_view key, std::string_view val) { return false; }
    virtual std::string lua_cache_lpop(std::string_view key) { return ""; }
    virtual std::string lua_cache_rpop(std::string_view key) { return ""; }
    virtual int lua_cache_llen(std::string_view key) { return 0; }

    // Sets
    virtual int lua_cache_sadd(std::string_view key, std::string_view member) { return -1; }
    virtual bool lua_cache_srem(std::string_view key, std::string_view member) { return false; }
    virtual bool lua_cache_sismember(std::string_view key, std::string_view member) { return false; }
    virtual int lua_cache_scard(std::string_view key) { return 0; }

    // Hashes
    virtual bool lua_cache_hset(std::string_view key, std::string_view field, std::string_view val) { return false; }
    virtual std::string lua_cache_hget(std::string_view key, std::string_view field) { return ""; }
    virtual bool lua_cache_hdel(std::string_view key, std::string_view field) { return false; }
    virtual int lua_cache_hlen(std::string_view key) { return 0; }

    // TTL
    virtual bool lua_cache_expire(std::string_view key, int seconds) { return false; }
    virtual int lua_cache_ttl(std::string_view key) { return -2; }
    virtual bool lua_cache_persist(std::string_view key) { return false; }

    // Pub/Sub
    virtual int lua_cache_publish(std::string_view channel, std::string_view message) { return 0; }

protected:
    // Invoke Lua callbacks safely
    void invoke_on_start();
    void invoke_on_stop();
    void invoke_on_message(std::string_view msg);
    void invoke_on_connect(int client_id);
    void invoke_on_disconnect(int client_id);
    bool invoke_on_auth(int client_id);
    void invoke_on_send(std::string_view msg);
    void invoke_on_client_message(int client_id, std::string_view msg);

    // Global rate limit check (token bucket, shared across all connections)
    bool check_global_rate_limit();

    // Bash output helper
    void print_bash_message(std::string_view msg) const;

private:
    std::string m_name;
    std::string m_id;
    runtime_type m_type;
    std::atomic<runtime_state> m_state;
    uint16_t m_port = 0;
    bool m_test_mode = false;
    std::string m_log_file;
    std::string m_write_file;
    std::string m_target;
    std::string m_cache_name;
    std::unique_ptr<lua_context> m_lua;

    std::chrono::system_clock::time_point m_created_time;
    std::chrono::system_clock::time_point m_start_time;

    // Bash output settings
    bool m_bash_output = false;
    bool m_bash_prefix = false;
    bool m_bash_timestamp = false;

    // Resource limits
    uint32_t m_max_connections = 0;
    double m_rate_limit = 0.0;
    double m_global_rate_limit = 0.0;
    double m_global_tokens = 0.0;
    std::chrono::steady_clock::time_point m_global_last{};
    uint32_t m_idle_timeout = 0;

    // Graceful shutdown
    bool m_drain = false;

    // Reconnect
    int m_reconnect = -1; // -1 = disabled, 0 = infinite, >0 = max attempts

    // TLS
    bool m_tls = false;
    std::string m_cert_path;
    std::string m_key_path;
    std::string m_ca_path;

    // Lua script path for hot-reload
    std::string m_lua_script_path;

    // C++ event callbacks
    std::function<void()>                        m_cb_on_start;
    std::function<void()>                        m_cb_on_stop;
    std::function<void(int)>                     m_cb_on_connect;
    std::function<void(int)>                     m_cb_on_disconnect;
    std::function<void(int, std::string_view)>   m_cb_on_client_message;
    std::function<void(std::string_view)>        m_cb_on_message;
    std::function<void(double)>                  m_cb_on_tick;
    uint32_t                                     m_cb_tick_ms = 0;

    // Interactive mode observer fds (IPC sockets)
    std::vector<int> m_interactive_fds;

    // Group tag
    std::string m_group;

    // Ownership
    std::string m_owner;
    bool m_lua_created = false;
    bool m_external = false;
    pid_t m_pid = 0;           // PID of external process (used by stop() to send SIGTERM)
    child_policy m_child_policy = child_policy::stop;

    // Runtime manager / event loop (base class)
    runtime_manager* m_runtime_manager = nullptr;
    event_loop* m_event_loop = nullptr;

    // Tick timer
    struct tick_handler : io_handler {
        runtime_instance* rt{nullptr};
        io_request req{};
        struct __kernel_timespec ts{};
        std::chrono::steady_clock::time_point last{};
        void on_cqe(struct io_uring_cqe* cqe) override;
    };
    tick_handler* m_tick{nullptr};
    void start_tick_timer();
    void fire_tick(int res);
};

// ── socketley/shared/state_persistence.h ──



struct runtime_config
{
    std::string name;
    std::string id;
    runtime_type type = runtime_server;
    uint16_t port = 0;
    bool was_running = false;

    // Common
    std::string log_file;
    std::string write_file;
    std::string lua_script;
    bool bash_output = false;
    bool bash_prefix = false;
    bool bash_timestamp = false;
    uint32_t max_connections = 0;
    double rate_limit = 0.0;
    double global_rate_limit = 0.0;
    uint32_t idle_timeout = 0;
    bool drain = false;
    int reconnect = -1;
    bool tls = false;
    std::string cert_path;
    std::string key_path;
    std::string ca_path;
    std::string target;
    std::string cache_name;

    // Group
    std::string group;

    // Ownership
    std::string owner;
    int child_policy = 0; // 0 = stop, 1 = remove

    // External (attach) mode
    bool external_runtime = false;
    int32_t pid = 0;  // PID of external process (0 = unknown)

    // Server/Client
    uint8_t mode = 0;       // server_mode or client_mode
    bool udp = false;

    // Server master mode
    std::string master_pw;
    bool master_forward = false;

    // Server HTTP static file serving
    std::string http_dir;
    bool http_cache = false;

    // Proxy
    uint8_t protocol = 0;   // proxy_protocol
    uint8_t strategy = 0;   // proxy_strategy
    std::vector<std::string> backends;

    // Cache
    std::string persistent_path;
    uint8_t cache_mode = 1;  // cache_mode (default readwrite)
    bool resp_forced = false;
    std::string replicate_target;
    size_t max_memory = 0;
    uint8_t eviction = 0;    // eviction_policy
};

class runtime_instance;
class runtime_manager;

class state_persistence
{
public:
    explicit state_persistence(const std::filesystem::path& state_dir);

    void save_runtime(const runtime_instance* instance);
    void remove_runtime(std::string_view name);
    void set_was_running(std::string_view name, bool running);

    std::vector<runtime_config> load_all();

    runtime_config read_from_instance(const runtime_instance* instance) const;
    std::string format_json_pretty(const runtime_config& cfg) const;
    bool parse_json_string(const std::string& json, runtime_config& cfg) const;

private:
    std::filesystem::path config_path(std::string_view name) const;
    bool write_json(const runtime_config& cfg) const;
    bool read_json(const std::filesystem::path& path, runtime_config& cfg) const;

    std::filesystem::path m_state_dir;
};

// ── socketley/shared/cluster_discovery.h ──




class event_loop;
class runtime_manager;

struct cluster_event
{
    enum type_t { daemon_join, daemon_leave, group_change } kind;
    std::string daemon_name;   // for join/leave
    std::string group_name;    // for group_change
    int member_count = 0;      // for group_change (new count)
};

struct remote_runtime
{
    std::string daemon_name;
    std::string host;
    std::string name;
    std::string type;
    std::string group;
    uint16_t port = 0;
    std::string state;
    size_t connections = 0;
};

struct remote_daemon
{
    std::string name;
    std::string host;
    time_t heartbeat = 0;
    std::vector<remote_runtime> runtimes;
};

class cluster_discovery : public io_handler
{
public:
    cluster_discovery(std::string_view daemon_name,
                      std::string_view cluster_dir,
                      runtime_manager& manager);
    ~cluster_discovery() override;

    // Start the publish/scan timer cycle.
    // Returns false if a daemon with the same name is already active in the cluster.
    bool start(event_loop& loop);

    // Stop and unpublish (graceful shutdown)
    void stop();

    // Get remote runtimes matching a group (thread-safe, returns snapshot)
    struct remote_endpoint { std::string host; uint16_t port; };
    std::vector<remote_endpoint> get_remote_group(std::string_view group) const;

    // Get all remote daemons (thread-safe, returns snapshot)
    std::vector<remote_daemon> get_all_daemons() const;

    // Event callback for topology changes
    using event_callback_t = std::function<void(const std::vector<cluster_event>&)>;
    void set_event_callback(event_callback_t cb);

    // Get the cluster directory path
    std::string_view get_cluster_dir() const { return m_cluster_dir; }

    // Get this daemon's name
    std::string_view get_daemon_name() const { return m_daemon_name; }

    // Get the advertised cluster address
    std::string_view get_cluster_addr() const { return m_cluster_addr; }

    // io_handler — timer CQE callback
    void on_cqe(struct io_uring_cqe* cqe) override;

private:
    // Publish this daemon's state to <cluster_dir>/<name>.json
    void publish();

    // Scan all *.json files in cluster_dir (skip own), update cache
    void scan();

    // Delete this daemon's JSON file
    void unpublish();

    // Schedule the next timer
    void schedule_timer();

    // Build JSON string for this daemon's state
    std::string build_publish_json() const;

    // Parse a remote daemon's JSON file into remote_daemon struct
    bool parse_daemon_json(const std::string& json, remote_daemon& out) const;

    std::string m_daemon_name;
    std::string m_cluster_dir;
    std::string m_cluster_addr;   // advertised host for remote daemons
    runtime_manager& m_manager;
    event_loop* m_loop = nullptr;

    // Timer
    io_request m_timer_req{};
    struct __kernel_timespec m_timer_ts{};

    // Cached remote daemons (protected by mutex)
    mutable std::mutex m_remote_mutex;
    std::unordered_map<std::string, remote_daemon> m_remote_daemons;

    // mtime cache: filename → last seen mtime (skip re-reading unchanged files)
    std::unordered_map<std::string, time_t> m_mtime_cache;

    // Change detection for event callbacks
    event_callback_t m_event_callback;
    std::unordered_set<std::string> m_previous_daemon_names;
    std::unordered_map<std::string, int> m_previous_group_counts;

    static constexpr int PUBLISH_INTERVAL_SEC = 2;
    static constexpr int STALE_THRESHOLD_SEC = 10;
};

// ── socketley/shared/runtime_manager.h ──




class event_loop;
class cluster_discovery;
struct cluster_event;

// Transparent hash for heterogeneous lookup (avoids string copies on find)
struct runtime_string_hash
{
    using is_transparent = void;

    size_t operator()(std::string_view sv) const noexcept
    {
        return std::hash<std::string_view>{}(sv);
    }

    size_t operator()(const std::string& s) const noexcept
    {
        return std::hash<std::string_view>{}(s);
    }
};

struct runtime_string_equal
{
    using is_transparent = void;

    bool operator()(std::string_view lhs, std::string_view rhs) const noexcept
    {
        return lhs == rhs;
    }
};

class runtime_manager
{
public:
    using runtime_map = std::unordered_map<std::string, std::unique_ptr<runtime_instance>,
                                            runtime_string_hash, runtime_string_equal>;

    bool create(runtime_type type, std::string_view name);
    bool run(std::string_view name, event_loop& loop);
    bool stop(std::string_view name, event_loop& loop);
    bool remove(std::string_view name);
    // Like remove(), but returns ownership so the caller controls when destruction happens.
    std::unique_ptr<runtime_instance> extract(std::string_view name);
    bool rename(std::string_view old_name, std::string_view new_name);
    void stop_all(event_loop& loop);

    // Cross-runtime pub/sub: dispatch a published message to all runtimes
    void dispatch_publish(std::string_view cache_name, std::string_view channel, std::string_view message);

    // Cluster event dispatch: forward topology changes to all runtimes with Lua callbacks
    void dispatch_cluster_events(const std::vector<cluster_event>& events);

    // Ownership cascading
    std::vector<std::string> get_children(std::string_view parent_name) const;
    void stop_children(std::string_view parent_name, event_loop& loop);
    void remove_children(std::string_view parent_name, event_loop& loop);

    // Group query: return all running instances with the given group tag
    std::vector<runtime_instance*> get_by_group(std::string_view group) const;

    const runtime_map& list() const;
    runtime_instance* get(std::string_view name);

    // Cluster discovery integration
    void set_cluster_discovery(cluster_discovery* cd);
    cluster_discovery* get_cluster_discovery() const;

    mutable std::shared_mutex mutex;

private:
    runtime_map runtimes;
    cluster_discovery* m_cluster = nullptr;
};

// ── socketley/shared/runtime_factory.h ──



class runtime_instance;

std::unique_ptr<runtime_instance> create_runtime(runtime_type type, std::string_view name);

// ── socketley/runtime/server/server_instance.h ──



class runtime_manager;

enum ws_state : uint8_t { ws_unknown = 0, ws_tcp = 1, ws_upgrading = 2, ws_active = 3 };

struct server_connection
{
    static constexpr size_t MAX_WRITE_BATCH = 16;
    static constexpr size_t MAX_WRITE_QUEUE = 4096;
    static constexpr size_t MAX_PARTIAL_SIZE = 1 * 1024 * 1024;

    int fd;
    io_request read_req;
    io_request write_req;
    char read_buf[4096];
    std::string partial;
    std::queue<std::shared_ptr<const std::string>> write_queue;

    // writev batch: holds refs alive until CQE completes
    std::shared_ptr<const std::string> write_batch[MAX_WRITE_BATCH];
    struct iovec write_iovs[MAX_WRITE_BATCH];
    uint32_t write_batch_count{0};

    bool read_pending{false};
    bool write_pending{false};
    bool closing{false};

    // WebSocket auto-detect state
    ws_state ws{ws_unknown};

    // WebSocket handshake headers (non-empty only for ws_active connections)
    std::string ws_cookie;
    std::string ws_origin;
    std::string ws_protocol;  // Sec-WebSocket-Protocol
    std::string ws_auth;      // Authorization

    // Rate limiting (token bucket)
    double rl_tokens{0.0};
    double rl_max{0.0};
    std::chrono::steady_clock::time_point rl_last{};

    // Master auth attempt tracking
    uint8_t auth_failures{0};

    // Idle connection tracking
    std::chrono::steady_clock::time_point last_activity{};

    // Per-connection metadata (freed automatically on disconnect)
    std::unordered_map<std::string, std::string> meta;
};

enum server_mode : uint8_t
{
    mode_inout  = 0,
    mode_in     = 1,
    mode_out    = 2,
    mode_master = 3
};

class server_instance : public runtime_instance
{
public:
    server_instance(std::string_view name);
    ~server_instance() override;

    void set_mode(server_mode mode);
    server_mode get_mode() const;

    void set_udp(bool udp);
    bool is_udp() const override;

    void on_cqe(struct io_uring_cqe* cqe) override;
    bool setup(event_loop& loop) override;
    void teardown(event_loop& loop) override;

    size_t get_connection_count() const override;

    // Lua actions
    void lua_broadcast(std::string_view msg) override;
    void lua_send_to(int client_id, std::string_view msg) override;
    void        lua_disconnect(int client_fd);
    std::string lua_peer_ip(int client_fd);

    // Lua client enumeration + multicast
    std::vector<int> lua_clients() const;
    void lua_multicast(const std::vector<int>& fds, std::string_view msg);

    // Lua per-connection metadata
    void        lua_set_data(int fd, std::string_view key, std::string_view val);
    void        lua_del_data(int fd, std::string_view key);
    std::string lua_get_data(int fd, std::string_view key) const;

    struct ws_headers_result {
        bool is_websocket{false};
        std::string cookie, origin, protocol, auth;
    };
    ws_headers_result lua_ws_headers(int client_fd) const;

    // Stats
    std::string get_stats() const override;

    // Client routing
    bool route_client(int client_fd, std::string_view target_name);
    bool unroute_client(int client_fd);
    std::string_view get_client_route(int client_fd) const;
    void process_forwarded_message(int client_fd, std::string_view msg, std::string_view parent_name);
    void remove_forwarded_client(int client_fd);
    void send_to_client(int client_fd, std::string_view msg);

    // Owner-targeted sending (sub-server → owner's clients)
    bool owner_send(int client_fd, std::string_view msg);
    bool owner_broadcast(std::string_view msg);

    // Master mode
    void set_master_pw(std::string_view pw);
    std::string_view get_master_pw() const;
    void set_master_forward(bool fwd);
    bool get_master_forward() const;
    int get_master_fd() const;

    // HTTP static file serving
    void set_http_dir(std::string_view path);
    const std::filesystem::path& get_http_dir() const;
    void set_http_cache(bool enabled);
    bool get_http_cache() const;
    void rebuild_http_cache();

private:
    void handle_accept(struct io_uring_cqe* cqe);
    void handle_read(struct io_uring_cqe* cqe, io_request* req);
    void handle_write(struct io_uring_cqe* cqe, io_request* req);
    void invoke_on_websocket(int fd);
    void serve_http(server_connection* conn, std::string_view path);

    void process_message(server_connection* sender, std::string_view msg);
    void broadcast(const std::shared_ptr<const std::string>& msg, int exclude_fd);
    void send_to(server_connection* conn, const std::shared_ptr<const std::string>& msg);
    void flush_write_queue(server_connection* conn);

    // UDP helpers
    void handle_udp_read(struct io_uring_cqe* cqe);
    void udp_broadcast(std::string_view msg, const struct sockaddr_in* exclude);
    int find_or_add_peer(const struct sockaddr_in& addr);

    server_mode m_mode;
    bool m_udp{false};

    // Master mode
    int m_master_fd{-1};
    bool m_master_forward{false};
    std::string m_master_pw;
    int m_listen_fd;
    struct sockaddr_in m_accept_addr;
    socklen_t m_accept_addrlen;
    io_request m_accept_req;
    event_loop* m_loop;

    // EMFILE/ENFILE accept backoff
    io_request m_accept_backoff_req{};
    struct __kernel_timespec m_accept_backoff_ts{};

    // Idle connection sweep timer
    io_request m_idle_sweep_req{};
    struct __kernel_timespec m_idle_sweep_ts{};

    std::unordered_map<int, std::unique_ptr<server_connection>> m_clients;
    // O(1) fd→conn lookup for CQE dispatch (non-owning, m_clients owns)
    static constexpr int MAX_FDS = 8192;
    server_connection* m_conn_idx[MAX_FDS]{};
    bool m_multishot_active{false};

    uint64_t m_message_counter = 0;

    // Client routing: fd → target runtime name
    std::unordered_map<int, std::string> m_routes;
    // Forwarded clients: fd → source (parent) runtime name
    std::unordered_map<int, std::string> m_forwarded_clients;

    // Stats
    uint32_t m_stat_peak_connections{0};

    // Provided buffer ring
    static constexpr uint16_t BUF_GROUP_ID = 1;
    static constexpr uint32_t BUF_COUNT = 1024;
    static constexpr uint32_t BUF_SIZE = 4096;
    bool m_use_provided_bufs{false};

    // UDP mode
    static constexpr size_t MAX_UDP_PEERS = 10000;
    struct udp_peer { struct sockaddr_in addr; };
    int m_udp_fd{-1};
    char m_udp_recv_buf[65536];
    struct sockaddr_in m_udp_recv_addr{};
    struct iovec m_udp_recv_iov{};
    struct msghdr m_udp_recv_msg{};
    io_request m_udp_recv_req{};
    std::vector<udp_peer> m_udp_peers;

    // Per-IP auth failure tracking
    struct auth_ip_record {
        uint32_t failures{0};
        std::chrono::steady_clock::time_point last_failure{};
    };
    std::unordered_map<uint32_t, auth_ip_record> m_auth_ip_failures;

    // HTTP static file serving
    std::filesystem::path m_http_dir;
    std::filesystem::path m_http_base;  // canonical resolved path (set at setup/rebuild time)
    bool m_http_cache_enabled{false};
    struct cached_file { std::shared_ptr<const std::string> response; };
    std::unordered_map<std::string, cached_file> m_http_cache;
};

// ── socketley/runtime/client/client_instance.h ──



struct client_tcp_connection
{
    int fd;
    io_request read_req;
    io_request write_req;
    char read_buf[4096];
    std::string write_buf;
    std::string partial;

    static constexpr size_t MAX_PARTIAL_SIZE = 1 * 1024 * 1024;

    bool read_pending{false};
    bool write_pending{false};
    bool closing{false};
};

enum client_mode : uint8_t
{
    client_mode_inout = 0,
    client_mode_in    = 1,
    client_mode_out   = 2
};

class client_instance : public runtime_instance
{
public:
    client_instance(std::string_view name);
    ~client_instance() override;

    void set_mode(client_mode mode);
    client_mode get_mode() const;

    void set_udp(bool udp);
    bool is_udp() const override;

    void on_cqe(struct io_uring_cqe* cqe) override;
    bool setup(event_loop& loop) override;
    void teardown(event_loop& loop) override;

    size_t get_connection_count() const override;

    // Lua actions
    void lua_send(std::string_view msg) override;

private:
    void handle_read(struct io_uring_cqe* cqe);
    void handle_write(struct io_uring_cqe* cqe);
    void handle_timeout(struct io_uring_cqe* cqe);

    void process_message(std::string_view msg);
    void send_to_server(std::string_view msg);
    void schedule_reconnect();
    bool try_connect();

    client_mode m_mode;
    bool m_udp{false};
    client_tcp_connection m_conn;
    event_loop* m_loop;
    bool m_connected;

    // Reconnect state
    int m_reconnect_attempt{0};
    bool m_reconnect_pending{false};
    io_request m_timeout_req{};
    struct __kernel_timespec m_timeout_ts{};

    // Provided buffer ring
    static constexpr uint16_t BUF_GROUP_ID = 4;
    static constexpr uint32_t BUF_COUNT = 64;
    static constexpr uint32_t BUF_SIZE = 4096;
    bool m_use_provided_bufs{false};
};

// ── socketley/runtime/proxy/proxy_instance.h ──



class runtime_manager;

enum proxy_protocol : uint8_t { protocol_http = 0, protocol_tcp = 1 };
enum proxy_strategy : uint8_t { strategy_round_robin = 0, strategy_random = 1, strategy_lua = 2 };

struct backend_info
{
    std::string address;
    std::string resolved_host;
    uint16_t resolved_port = 0;
    bool is_group = false;
};

struct resolved_backend
{
    std::string host;
    uint16_t port = 0;
};

struct proxy_client_connection
{
    static constexpr size_t MAX_WRITE_BATCH = 16;
    static constexpr size_t MAX_WRITE_QUEUE = 4096;
    static constexpr size_t MAX_PARTIAL_SIZE = 1 * 1024 * 1024;

    int fd;
    io_request read_req;
    io_request write_req;
    char read_buf[8192];
    std::string partial;
    int backend_fd = -1;
    bool header_parsed = false;
    std::string method;
    std::string path;
    std::string version;

    std::queue<std::shared_ptr<const std::string>> write_queue;
    std::shared_ptr<const std::string> write_batch[MAX_WRITE_BATCH];
    struct iovec write_iovs[MAX_WRITE_BATCH];
    uint32_t write_batch_count{0};

    bool read_pending{false};
    bool write_pending{false};
    bool closing{false};

    // Idle connection tracking
    std::chrono::steady_clock::time_point last_activity{};
};

struct proxy_backend_connection
{
    static constexpr size_t MAX_WRITE_BATCH = 16;
    static constexpr size_t MAX_WRITE_QUEUE = 4096;
    static constexpr size_t MAX_PARTIAL_SIZE = 1 * 1024 * 1024;

    int fd;
    io_request read_req;
    io_request write_req;
    char read_buf[8192];
    std::string partial;
    int client_fd;

    std::queue<std::shared_ptr<const std::string>> write_queue;
    std::shared_ptr<const std::string> write_batch[MAX_WRITE_BATCH];
    struct iovec write_iovs[MAX_WRITE_BATCH];
    uint32_t write_batch_count{0};

    bool read_pending{false};
    bool write_pending{false};
    bool closing{false};
};

class proxy_instance : public runtime_instance
{
public:
    proxy_instance(std::string_view name);
    ~proxy_instance() override;

    void add_backend(std::string_view addr);
    void clear_backends();
    void set_protocol(proxy_protocol p);
    void set_strategy(proxy_strategy s);
    void set_runtime_manager(runtime_manager* mgr);

    proxy_protocol get_protocol() const;
    proxy_strategy get_strategy() const;
    const std::vector<backend_info>& get_backends() const;

    void on_cqe(struct io_uring_cqe* cqe) override;
    bool setup(event_loop& loop) override;
    void teardown(event_loop& loop) override;

    size_t get_connection_count() const override;

    // Stats
    std::string get_stats() const override;

private:
    void handle_accept(struct io_uring_cqe* cqe);
    void handle_client_read(struct io_uring_cqe* cqe, io_request* req);
    void handle_backend_read(struct io_uring_cqe* cqe, io_request* req);
    void handle_client_write(struct io_uring_cqe* cqe, io_request* req);
    void handle_backend_write(struct io_uring_cqe* cqe, io_request* req);

    bool parse_http_request_line(proxy_client_connection* conn);
    std::string rewrite_http_request(proxy_client_connection* conn,
                                     std::string_view new_path);

    bool resolve_backend(backend_info& b);
    resolved_backend select_and_resolve_backend(proxy_client_connection* conn);
    bool connect_to_backend(proxy_client_connection* conn, const resolved_backend& target);
    void close_pair(int client_fd, int backend_fd);

    void forward_to_backend(proxy_client_connection* conn, std::string_view data);
    void forward_to_client(proxy_backend_connection* conn, std::string_view data);
    void send_error(proxy_client_connection* conn, std::string_view status, std::string_view body);
    void flush_client_write_queue(proxy_client_connection* conn);
    void flush_backend_write_queue(proxy_backend_connection* conn);

    proxy_protocol m_protocol = protocol_http;
    proxy_strategy m_strategy = strategy_round_robin;
    std::vector<backend_info> m_backends;
    std::string m_prefix;  // pre-built "/<name>/" to avoid repeated allocation

    int m_listen_fd = -1;
    sockaddr_in m_accept_addr{};
    socklen_t m_accept_addrlen = sizeof(sockaddr_in);
    io_request m_accept_req{};
    event_loop* m_loop = nullptr;
    bool m_multishot_active = false;

    // EMFILE/ENFILE accept backoff
    io_request m_accept_backoff_req{};
    struct __kernel_timespec m_accept_backoff_ts{};

    // Idle connection sweep timer
    io_request m_idle_sweep_req{};
    struct __kernel_timespec m_idle_sweep_ts{};

    std::unordered_map<int, std::unique_ptr<proxy_client_connection>> m_clients;
    std::unordered_map<int, std::unique_ptr<proxy_backend_connection>> m_backend_conns;

    size_t m_rr_index = 0;
    std::mt19937 m_rng{std::random_device{}()};

    // Provided buffer ring
    static constexpr uint16_t BUF_GROUP_ID = 2;
    static constexpr uint32_t BUF_COUNT = 256;
    static constexpr uint32_t BUF_SIZE = 8192;
    bool m_use_provided_bufs{false};
};

// ── socketley/runtime/cache/cache_instance.h ──



struct client_connection
{
    static constexpr size_t MAX_WRITE_BATCH = 16;
    static constexpr size_t MAX_WRITE_QUEUE = 4096;
    static constexpr size_t MAX_PARTIAL_SIZE = 1 * 1024 * 1024;

    int fd;
    io_request read_req;
    io_request write_req;
    char read_buf[4096];
    std::string partial;
    std::string response_buf;
    // write_queue holds owned strings — no shared_ptr overhead per flush
    std::queue<std::string> write_queue;

    std::string write_batch[MAX_WRITE_BATCH];
    struct iovec write_iovs[MAX_WRITE_BATCH];
    uint32_t write_batch_count{0};

    bool read_pending{false};
    bool write_pending{false};
    bool closing{false};

    // RESP protocol mode (auto-detected or forced)
    bool resp_mode{false};
    bool resp_detected{false};  // true once first byte examined

    // Rate limiting (token bucket)
    double rl_tokens{0.0};
    double rl_max{0.0};
    std::chrono::steady_clock::time_point rl_last{};

    // Idle connection tracking
    std::chrono::steady_clock::time_point last_activity{};
};

enum cache_mode : uint8_t
{
    cache_mode_readonly  = 0,  // GET, SIZE
    cache_mode_readwrite = 1,  // GET, SET, DEL, SIZE (default)
    cache_mode_admin     = 2   // all incl. FLUSH, LOAD
};

class cache_instance : public runtime_instance
{
public:
    cache_instance(std::string_view name);
    ~cache_instance() override;

    void set_persistent(std::string_view path);
    std::string_view get_persistent() const;

    void set_mode(cache_mode mode);
    cache_mode get_mode() const;

    void on_cqe(struct io_uring_cqe* cqe) override;
    bool setup(event_loop& loop) override;
    void teardown(event_loop& loop) override;

    size_t get_connection_count() const override;

    // Lua cache access — strings
    std::string lua_get(std::string_view key);
    bool lua_set(std::string_view key, std::string_view value);
    bool lua_del(std::string_view key);

    // Lua cache access — lists
    bool lua_lpush(std::string_view key, std::string_view val);
    bool lua_rpush(std::string_view key, std::string_view val);
    std::string lua_lpop(std::string_view key);
    std::string lua_rpop(std::string_view key);
    int lua_llen(std::string_view key);
#ifndef SOCKETLEY_NO_LUA
    sol::table lua_lrange(std::string_view key, int start, int stop);
#endif

    // Lua cache access — sets
    int lua_sadd(std::string_view key, std::string_view member);
    bool lua_srem(std::string_view key, std::string_view member);
    bool lua_sismember(std::string_view key, std::string_view member);
    int lua_scard(std::string_view key);
#ifndef SOCKETLEY_NO_LUA
    sol::table lua_smembers(std::string_view key);
#endif

    // Lua cache access — hashes
    bool lua_hset(std::string_view key, std::string_view field, std::string_view val);
    std::string lua_hget(std::string_view key, std::string_view field);
    bool lua_hdel(std::string_view key, std::string_view field);
    int lua_hlen(std::string_view key);
#ifndef SOCKETLEY_NO_LUA
    sol::table lua_hgetall(std::string_view key);
#endif

    // Lua cache access — TTL
    bool lua_expire(std::string_view key, int seconds);
    int lua_ttl(std::string_view key);
    bool lua_persist(std::string_view key);

    // Virtual overrides for Lua API
    std::string lua_cache_get(std::string_view key) override { return lua_get(key); }
    bool lua_cache_set(std::string_view key, std::string_view value) override { return lua_set(key, value); }
    bool lua_cache_del(std::string_view key) override { return lua_del(key); }
    bool lua_cache_lpush(std::string_view key, std::string_view val) override { return lua_lpush(key, val); }
    bool lua_cache_rpush(std::string_view key, std::string_view val) override { return lua_rpush(key, val); }
    std::string lua_cache_lpop(std::string_view key) override { return lua_lpop(key); }
    std::string lua_cache_rpop(std::string_view key) override { return lua_rpop(key); }
    int lua_cache_llen(std::string_view key) override { return lua_llen(key); }
    int lua_cache_sadd(std::string_view key, std::string_view member) override { return lua_sadd(key, member); }
    bool lua_cache_srem(std::string_view key, std::string_view member) override { return lua_srem(key, member); }
    bool lua_cache_sismember(std::string_view key, std::string_view member) override { return lua_sismember(key, member); }
    int lua_cache_scard(std::string_view key) override { return lua_scard(key); }
    bool lua_cache_hset(std::string_view key, std::string_view field, std::string_view val) override { return lua_hset(key, field, val); }
    std::string lua_cache_hget(std::string_view key, std::string_view field) override { return lua_hget(key, field); }
    bool lua_cache_hdel(std::string_view key, std::string_view field) override { return lua_hdel(key, field); }
    int lua_cache_hlen(std::string_view key) override { return lua_hlen(key); }
    bool lua_cache_expire(std::string_view key, int seconds) override { return lua_expire(key, seconds); }
    int lua_cache_ttl(std::string_view key) override { return lua_ttl(key); }
    bool lua_cache_persist(std::string_view key) override { return lua_persist(key); }
    int lua_cache_publish(std::string_view channel, std::string_view message) override { return publish(channel, message); }

    // Interactive mode: execute a command and return response
    std::string execute(std::string_view line);

    // Maxmemory / Eviction
    void set_max_memory(size_t bytes);
    size_t get_max_memory() const;
    void set_eviction(eviction_policy policy);
    eviction_policy get_eviction() const;

    // RESP mode
    void set_resp_forced(bool enabled);
    bool get_resp_forced() const;

    // Pub/Sub
    int publish(std::string_view channel, std::string_view message);

    // Replication
    enum repl_role : uint8_t { repl_none = 0, repl_leader = 1, repl_follower = 2 };
    void set_replicate_target(std::string_view host_port);
    std::string_view get_replicate_target() const;
    repl_role get_repl_role() const;

    // Stats
    std::string get_stats() const override;
    uint64_t m_stat_commands{0};
    uint64_t m_stat_get_hits{0};
    uint64_t m_stat_get_misses{0};
    uint64_t m_stat_keys_expired{0};

    // Direct store access (for server --cache integration)
    bool store_direct(std::string_view key, std::string_view value);

    // Cache management (for cmd_action)
    uint32_t get_size() const;
    size_t store_memory_used() const;
    bool flush_to(std::string_view path);
    bool load_from(std::string_view path);

private:
    void handle_accept(struct io_uring_cqe* cqe);
    void handle_read(struct io_uring_cqe* cqe, io_request* req);
    void handle_write(struct io_uring_cqe* cqe, io_request* req);

    void process_command(client_connection* conn, std::string_view line);
    void process_resp(client_connection* conn);
    void process_resp_command(client_connection* conn, std::string_view* args, int argc);
    void flush_responses(client_connection* conn);
    void flush_write_queue(client_connection* conn);

    int m_listen_fd;
    struct sockaddr_in m_accept_addr;
    socklen_t m_accept_addrlen;
    io_request m_accept_req;
    bool m_multishot_active{false};

    cache_store m_store;
    std::unordered_map<int, std::unique_ptr<client_connection>> m_clients;

    // O(1) fd→connection lookup (avoids hash map on every CQE)
    static constexpr int MAX_FDS = 8192;
    client_connection* m_conn_idx[MAX_FDS]{};

    event_loop* m_loop;

    // EMFILE/ENFILE accept backoff
    io_request m_accept_backoff_req{};
    struct __kernel_timespec m_accept_backoff_ts{};

    // Idle connection sweep timer
    io_request m_idle_sweep_req{};
    struct __kernel_timespec m_idle_sweep_ts{};

    std::string m_persistent_path;
    cache_mode m_mode = cache_mode_readwrite;
    bool m_resp_forced{false};

    // Replication
    std::string m_replicate_target;
    repl_role m_repl_role{repl_none};
    std::vector<int> m_follower_fds;
    int m_master_fd{-1};
    io_request m_master_read_req{};
    char m_master_read_buf[4096]{};
    std::string m_master_partial;

    void replicate_command(std::string_view cmd);
    void handle_replicate_request(client_connection* conn);
    void send_full_dump(int fd);
    bool connect_to_master();
    void handle_master_read(struct io_uring_cqe* cqe);

    // Provided buffer ring
    static constexpr uint16_t BUF_GROUP_ID = 3;
    static constexpr uint32_t BUF_COUNT = 512;
    static constexpr uint32_t BUF_SIZE = 4096;
    bool m_use_provided_bufs{false};

    // Periodic TTL sweep timer
    io_request m_ttl_req{};
    struct __kernel_timespec m_ttl_ts{};
};

#ifdef SOCKETLEY_IMPLEMENTATION

// ════════════════════════════════════════════════════════════════════
//  IMPLEMENTATION
// ════════════════════════════════════════════════════════════════════

namespace fs = std::filesystem;

// ── socketley/shared/paths.cpp ──



static fs::path get_home()
{
    const char* home = std::getenv("HOME");
    if (home && home[0])
        return home;

    struct passwd* pw = getpwuid(getuid());
    if (pw && pw->pw_dir)
        return pw->pw_dir;

    return {};
}

socketley_paths socketley_paths::resolve()
{
    socketley_paths p;

    // SOCKETLEY_SOCKET env var overrides socket path (used by cluster multi-daemon setups)
    const char* env_socket = std::getenv("SOCKETLEY_SOCKET");

    bool installed = access("/usr/bin/socketley", X_OK) == 0;
    uid_t uid = getuid();

    // System mode: only for root or dedicated socketley system user
    bool is_privileged = (uid == 0);
    if (!is_privileged && installed)
    {
        struct passwd* pw = getpwnam("socketley");
        if (pw && pw->pw_uid == uid)
            is_privileged = true;
    }

    if (installed && is_privileged)
    {
        p.system_mode = true;
        p.socket_path = "/run/socketley/socketley.sock";
        p.state_dir   = "/var/lib/socketley/runtimes";
        p.config_path = "/etc/socketley/config.lua";

        std::error_code ec;
        fs::create_directories("/run/socketley", ec);
        fs::create_directories(p.state_dir, ec);
    }
    else
    {
        p.system_mode = false;
        p.socket_path = "/tmp/socketley.sock";

        fs::path home = get_home();
        if (!home.empty())
        {
            p.state_dir   = home / ".local" / "share" / "socketley" / "runtimes";
            p.config_path = home / ".config" / "socketley" / "config.lua";
        }
        else
        {
            p.state_dir   = "/tmp/socketley-runtimes";
            p.config_path.clear();
        }

        std::error_code ec;
        fs::create_directories(p.state_dir, ec);

        // If system daemon is running and socket is accessible, prefer it
        if (installed && access("/run/socketley/socketley.sock", R_OK | W_OK) == 0)
        {
            p.socket_path = "/run/socketley/socketley.sock";
            p.system_mode = true;
        }
    }

    // Override socket path if SOCKETLEY_SOCKET is set
    if (env_socket && env_socket[0])
        p.socket_path = env_socket;

    return p;
}

// ── socketley/shared/tls_context.cpp ──


// Conditionally compile TLS support only if OpenSSL is available
#if __has_include(<openssl/ssl.h>)
#define SOCKETLEY_HAS_TLS 1
#else
#define SOCKETLEY_HAS_TLS 0
#endif


tls_context::tls_context() = default;

tls_context::~tls_context()
{
#if SOCKETLEY_HAS_TLS
    if (m_ctx)
        SSL_CTX_free(m_ctx);
#endif
}

bool tls_context::init_server(std::string_view cert_path, std::string_view key_path)
{
#if SOCKETLEY_HAS_TLS
    m_ctx = SSL_CTX_new(TLS_server_method());
    if (!m_ctx)
    {
        std::cerr << "[tls] failed to create SSL context\n";
        return false;
    }
    SSL_CTX_set_min_proto_version(m_ctx, TLS1_2_VERSION);

    if (SSL_CTX_use_certificate_file(m_ctx, std::string(cert_path).c_str(), SSL_FILETYPE_PEM) <= 0)
    {
        std::cerr << "[tls] failed to load certificate: " << cert_path << "\n";
        SSL_CTX_free(m_ctx);
        m_ctx = nullptr;
        return false;
    }

    if (SSL_CTX_use_PrivateKey_file(m_ctx, std::string(key_path).c_str(), SSL_FILETYPE_PEM) <= 0)
    {
        std::cerr << "[tls] failed to load private key: " << key_path << "\n";
        SSL_CTX_free(m_ctx);
        m_ctx = nullptr;
        return false;
    }

    if (!SSL_CTX_check_private_key(m_ctx))
    {
        std::cerr << "[tls] private key does not match certificate\n";
        SSL_CTX_free(m_ctx);
        m_ctx = nullptr;
        return false;
    }

    return true;
#else
    std::cerr << "[tls] OpenSSL not available — rebuild with OpenSSL development headers\n";
    return false;
#endif
}

bool tls_context::init_client(std::string_view ca_path)
{
#if SOCKETLEY_HAS_TLS
    m_ctx = SSL_CTX_new(TLS_client_method());
    if (!m_ctx)
    {
        std::cerr << "[tls] failed to create SSL context\n";
        return false;
    }
    SSL_CTX_set_min_proto_version(m_ctx, TLS1_2_VERSION);

    if (!ca_path.empty())
    {
        if (SSL_CTX_load_verify_locations(m_ctx, std::string(ca_path).c_str(), nullptr) <= 0)
        {
            std::cerr << "[tls] failed to load CA file: " << ca_path << "\n";
            SSL_CTX_free(m_ctx);
            m_ctx = nullptr;
            return false;
        }
        SSL_CTX_set_verify(m_ctx, SSL_VERIFY_PEER, nullptr);
    }

    return true;
#else
    std::cerr << "[tls] OpenSSL not available — rebuild with OpenSSL development headers\n";
    return false;
#endif
}

SSL* tls_context::create_ssl() const
{
#if SOCKETLEY_HAS_TLS
    if (!m_ctx)
        return nullptr;

    SSL* ssl = SSL_new(m_ctx);
    if (!ssl)
        return nullptr;

    // Create BIO memory pair for non-blocking I/O
    BIO* rbio = BIO_new(BIO_s_mem());
    BIO* wbio = BIO_new(BIO_s_mem());

    BIO_set_nbio(rbio, 1);
    BIO_set_nbio(wbio, 1);

    SSL_set_bio(ssl, rbio, wbio);

    return ssl;
#else
    return nullptr;
#endif
}

int tls_context::do_handshake(SSL* ssl)
{
#if SOCKETLEY_HAS_TLS
    int ret = SSL_do_handshake(ssl);
    if (ret == 1)
        return 1;

    int err = SSL_get_error(ssl, ret);
    if (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE)
        return 0;

    return -1;
#else
    return -1;
#endif
}

int tls_context::ssl_read(SSL* ssl, char* buf, int len)
{
#if SOCKETLEY_HAS_TLS
    int ret = SSL_read(ssl, buf, len);
    if (ret > 0)
        return ret;

    int err = SSL_get_error(ssl, ret);
    if (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE)
        return 0;

    return -1;
#else
    return -1;
#endif
}

int tls_context::ssl_write(SSL* ssl, const char* buf, int len)
{
#if SOCKETLEY_HAS_TLS
    int ret = SSL_write(ssl, buf, len);
    if (ret > 0)
        return ret;

    int err = SSL_get_error(ssl, ret);
    if (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE)
        return 0;

    return -1;
#else
    return -1;
#endif
}

int tls_context::bio_read_out(SSL* ssl, char* buf, int len)
{
#if SOCKETLEY_HAS_TLS
    BIO* wbio = SSL_get_wbio(ssl);
    if (!wbio)
        return -1;

    int ret = BIO_read(wbio, buf, len);
    if (ret > 0)
        return ret;
    if (BIO_should_retry(wbio))
        return 0;
    return -1;
#else
    return -1;
#endif
}

int tls_context::bio_write_in(SSL* ssl, const char* buf, int len)
{
#if SOCKETLEY_HAS_TLS
    BIO* rbio = SSL_get_rbio(ssl);
    if (!rbio)
        return -1;

    int ret = BIO_write(rbio, buf, len);
    if (ret > 0)
        return ret;
    if (BIO_should_retry(rbio))
        return 0;
    return -1;
#else
    return -1;
#endif
}

bool tls_context::has_pending_out(SSL* ssl)
{
#if SOCKETLEY_HAS_TLS
    BIO* wbio = SSL_get_wbio(ssl);
    return wbio && BIO_ctrl_pending(wbio) > 0;
#else
    return false;
#endif
}

void tls_context::free_ssl(SSL* ssl)
{
#if SOCKETLEY_HAS_TLS
    if (ssl)
        SSL_free(ssl);
#endif
}

// ── socketley/shared/event_loop.cpp ──


event_loop::event_loop(uint32_t queue_depth)
    : m_running(false), m_queue_depth(queue_depth), m_pending_submissions(0)
{
}

event_loop::~event_loop()
{
    for (auto& [gid, pool] : m_buf_rings)
    {
        if (pool.ring)
            io_uring_free_buf_ring(&m_ring, pool.ring, pool.buf_count, gid);
        free(pool.base);
    }
    m_buf_rings.clear();

    if (m_signal_pipe[0] >= 0) close(m_signal_pipe[0]);
    if (m_signal_pipe[1] >= 0) close(m_signal_pipe[1]);
}

bool event_loop::supports_multishot_accept()
{
    struct io_uring ring;
    if (io_uring_queue_init(2, &ring, 0) < 0)
        return false;

    struct io_uring_probe* probe = io_uring_get_probe_ring(&ring);
    bool supported = false;
    if (probe)
    {
        supported = io_uring_opcode_supported(probe, IORING_OP_ACCEPT);
        io_uring_free_probe(probe);
    }
    io_uring_queue_exit(&ring);
    return supported;
}

void event_loop::setup_signal_pipe()
{
    if (pipe(m_signal_pipe) < 0)
        return;

    m_signal_req = { op_read, m_signal_pipe[0], &m_signal_buf, 1, nullptr };

    struct io_uring_sqe* sqe = io_uring_get_sqe(&m_ring);
    if (sqe)
    {
        io_uring_prep_read(sqe, m_signal_pipe[0], &m_signal_buf, 1, 0);
        io_uring_sqe_set_data(sqe, &m_signal_req);
        io_uring_submit(&m_ring);
    }
}

bool event_loop::init()
{
    bool initialized = false;

    // Priority 1: SQPOLL + SINGLE_ISSUER (avoids submit syscalls, needs root)
    {
        struct io_uring_params params{};
        params.flags = IORING_SETUP_SQPOLL | IORING_SETUP_SINGLE_ISSUER;
        params.sq_thread_idle = 1000;
        if (io_uring_queue_init_params(m_queue_depth, &m_ring, &params) == 0)
        {
            m_sqpoll_enabled = true;
            initialized = true;
        }
    }

    // Priority 3: Plain mode
    if (!initialized)
    {
        if (io_uring_queue_init(m_queue_depth, &m_ring, 0) < 0)
            return false;
    }

    m_multishot_supported = supports_multishot_accept();
    setup_signal_pipe();

    return true;
}

void event_loop::flush()
{
    if (m_pending_submissions > 0)
    {
        io_uring_submit(&m_ring);
        m_pending_submissions = 0;
    }
}

void event_loop::run()
{
    m_running.store(true, std::memory_order_release);

    struct io_uring_cqe* cqe;

    while (m_running.load(std::memory_order_acquire))
    {
        // Flush any pending submissions, then ensure at least one CQE is ready.
        // Peek first — if CQEs from the previous iteration's submitted SQEs already
        // landed (common at high throughput), skip the blocking wait entirely.
        if (m_pending_submissions > 0)
        {
            io_uring_submit_and_wait(&m_ring, 1);
            m_pending_submissions = 0;
        }
        else if (io_uring_peek_cqe(&m_ring, &cqe) != 0)
        {
            // Ring is empty: block until at least one CQE arrives
            if (io_uring_wait_cqe(&m_ring, &cqe) < 0)
                break;
        }

        // Batch-drain all available CQEs in one pass — single io_uring_cq_advance
        unsigned head;
        unsigned count = 0;
        bool got_signal = false;

        io_uring_for_each_cqe(&m_ring, head, cqe)
        {
            count++;

            auto* req = static_cast<io_request*>(io_uring_cqe_get_data(cqe));

            if (req == &m_signal_req)
            {
                got_signal = true;
                break;
            }

            if (req && req->owner)
                req->owner->on_cqe(cqe);
        }

        io_uring_cq_advance(&m_ring, count);

        if (got_signal)
        {
            m_running.store(false, std::memory_order_release);
            break;
        }
    }

    io_uring_queue_exit(&m_ring);
}

void event_loop::request_stop()
{
    m_running.store(false, std::memory_order_release);

    if (m_signal_pipe[1] >= 0)
    {
        char c = 1;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-result"
        write(m_signal_pipe[1], &c, 1);
#pragma GCC diagnostic pop
    }
}

int event_loop::get_signal_write_fd() const
{
    return m_signal_pipe[1];
}

struct io_uring* event_loop::get_ring()
{
    return &m_ring;
}

void event_loop::submit_accept(int listen_fd, struct sockaddr_in* addr, socklen_t* addrlen, io_request* req)
{
    struct io_uring_sqe* sqe = io_uring_get_sqe(&m_ring);
    if (!sqe)
    {
        flush();
        sqe = io_uring_get_sqe(&m_ring);
        if (!sqe) return;
    }

    io_uring_prep_accept(sqe, listen_fd, reinterpret_cast<struct sockaddr*>(addr), addrlen, 0);
    io_uring_sqe_set_data(sqe, req);
    m_pending_submissions++;
}

void event_loop::submit_multishot_accept(int listen_fd, io_request* req)
{
    struct io_uring_sqe* sqe = io_uring_get_sqe(&m_ring);
    if (!sqe)
    {
        flush();
        sqe = io_uring_get_sqe(&m_ring);
        if (!sqe) return;
    }

    if (m_multishot_supported)
    {
        // Multishot: one SQE handles ALL incoming connections
        io_uring_prep_multishot_accept(sqe, listen_fd, nullptr, nullptr, 0);
    }
    else
    {
        io_uring_prep_accept(sqe, listen_fd, nullptr, nullptr, 0);
    }
    io_uring_sqe_set_data(sqe, req);
    m_pending_submissions++;
}

void event_loop::submit_read(int fd, char* buf, uint32_t len, io_request* req)
{
    struct io_uring_sqe* sqe = io_uring_get_sqe(&m_ring);
    if (!sqe)
    {
        // Queue full, flush and retry
        flush();
        sqe = io_uring_get_sqe(&m_ring);
        if (!sqe) return;
    }

    io_uring_prep_read(sqe, fd, buf, len, 0);
    io_uring_sqe_set_data(sqe, req);
    m_pending_submissions++;
}

void event_loop::submit_write(int fd, const char* buf, uint32_t len, io_request* req)
{
    struct io_uring_sqe* sqe = io_uring_get_sqe(&m_ring);
    if (!sqe)
    {
        // Queue full, flush and retry
        flush();
        sqe = io_uring_get_sqe(&m_ring);
        if (!sqe) return;
    }

    io_uring_prep_write(sqe, fd, buf, len, 0);
    io_uring_sqe_set_data(sqe, req);
    m_pending_submissions++;
}

void event_loop::submit_writev(int fd, struct iovec* iovs, uint32_t count, io_request* req)
{
    struct io_uring_sqe* sqe = io_uring_get_sqe(&m_ring);
    if (!sqe)
    {
        flush();
        sqe = io_uring_get_sqe(&m_ring);
        if (!sqe) return;
    }

    io_uring_prep_writev(sqe, fd, iovs, count, 0);
    io_uring_sqe_set_data(sqe, req);
    m_pending_submissions++;
}

void event_loop::submit_recvmsg(int fd, struct msghdr* msg, io_request* req)
{
    struct io_uring_sqe* sqe = io_uring_get_sqe(&m_ring);
    if (!sqe)
    {
        flush();
        sqe = io_uring_get_sqe(&m_ring);
        if (!sqe) return;
    }

    io_uring_prep_recvmsg(sqe, fd, msg, 0);
    io_uring_sqe_set_data(sqe, req);
    m_pending_submissions++;
}

void event_loop::submit_timeout(struct __kernel_timespec* ts, io_request* req)
{
    struct io_uring_sqe* sqe = io_uring_get_sqe(&m_ring);
    if (!sqe)
    {
        flush();
        sqe = io_uring_get_sqe(&m_ring);
        if (!sqe) return;
    }

    io_uring_prep_timeout(sqe, ts, 0, 0);
    io_uring_sqe_set_data(sqe, req);
    m_pending_submissions++;
}

void event_loop::submit_cancel_fd(int fd)
{
    struct io_uring_sqe* sqe = io_uring_get_sqe(&m_ring);
    if (!sqe)
    {
        flush();
        sqe = io_uring_get_sqe(&m_ring);
        if (!sqe) return;
    }

    // IORING_ASYNC_CANCEL_ALL cancels ALL pending ops for this fd in one shot.
    // Without it, only one op is cancelled per SQE — leaving the second CQE
    // (e.g. a write when read is also pending) to arrive after the deferred-
    // delete timeout fires and the owning object is freed.
    io_uring_prep_cancel_fd(sqe, fd, IORING_ASYNC_CANCEL_ALL);
    // Null user_data so the cancel-result CQE is silently discarded by event_loop::run()
    io_uring_sqe_set_data(sqe, nullptr);
    m_pending_submissions++;
}

bool event_loop::setup_buf_ring(uint16_t group_id, uint32_t buf_count, uint32_t buf_size)
{
    // Already registered — reuse
    if (m_buf_rings.count(group_id))
        return true;

    int ret;
    struct io_uring_buf_ring* br = io_uring_setup_buf_ring(&m_ring, buf_count, group_id, 0, &ret);
    if (!br)
        return false;

    char* base = static_cast<char*>(malloc(static_cast<size_t>(buf_count) * buf_size));
    if (!base)
    {
        io_uring_free_buf_ring(&m_ring, br, buf_count, group_id);
        return false;
    }

    // Register all buffers
    for (uint32_t i = 0; i < buf_count; i++)
    {
        io_uring_buf_ring_add(br, base + (i * buf_size), buf_size, static_cast<uint16_t>(i),
            io_uring_buf_ring_mask(buf_count), static_cast<int>(i));
    }
    io_uring_buf_ring_advance(br, buf_count);

    m_buf_rings[group_id] = { br, base, buf_count, buf_size };
    return true;
}

void event_loop::submit_read_provided(int fd, uint16_t group_id, io_request* req)
{
    auto it = m_buf_rings.find(group_id);
    if (it == m_buf_rings.end())
        return;

    struct io_uring_sqe* sqe = io_uring_get_sqe(&m_ring);
    if (!sqe)
    {
        flush();
        sqe = io_uring_get_sqe(&m_ring);
        if (!sqe) return;
    }

    io_uring_prep_read(sqe, fd, nullptr, it->second.buf_size, 0);
    sqe->flags |= IOSQE_BUFFER_SELECT;
    sqe->buf_group = group_id;
    io_uring_sqe_set_data(sqe, req);
    req->type = op_read_provided;
    m_pending_submissions++;
}

char* event_loop::get_buf_ptr(uint16_t group_id, uint16_t buf_id)
{
    auto it = m_buf_rings.find(group_id);
    if (it == m_buf_rings.end())
        return nullptr;

    auto& pool = it->second;
    if (buf_id >= pool.buf_count)
        return nullptr;

    return pool.base + (static_cast<size_t>(buf_id) * pool.buf_size);
}

void event_loop::return_buf(uint16_t group_id, uint16_t buf_id)
{
    auto it = m_buf_rings.find(group_id);
    if (it == m_buf_rings.end())
        return;

    auto& pool = it->second;
    io_uring_buf_ring_add(pool.ring,
        pool.base + (static_cast<size_t>(buf_id) * pool.buf_size),
        pool.buf_size, buf_id,
        io_uring_buf_ring_mask(pool.buf_count), 0);
    io_uring_buf_ring_advance(pool.ring, 1);
}

bool event_loop::has_buf_ring(uint16_t group_id) const
{
    return m_buf_rings.count(group_id) > 0;
}

// ── socketley/shared/daemon_client.cpp ──


namespace socketley {

static std::string g_attached_name;

// Send one command to the daemon, return daemon exit code (or -1 on IPC error).
static int daemon_ipc(const char* cmd)
{
    auto paths = socketley_paths::resolve();
    std::string sock_path = paths.socket_path.string();

    int fd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (fd < 0) return -1;

    struct sockaddr_un addr{};
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, sock_path.c_str(), sizeof(addr.sun_path) - 1);

    if (connect(fd, reinterpret_cast<struct sockaddr*>(&addr), sizeof(addr)) < 0)
    {
        close(fd);
        return -1;
    }

    std::string msg = std::string(cmd) + "\n";
    if (write(fd, msg.data(), msg.size()) < 0)
    {
        close(fd);
        return -1;
    }

    char buf[512];
    int  ec = -1;
    ssize_t n = read(fd, buf, sizeof(buf));
    if (n >= 1)
        ec = static_cast<unsigned char>(buf[0]);

    close(fd);
    return ec;
}

bool daemon_attach(std::string_view name, std::string_view type, uint16_t port)
{
    char cmd[256];
    snprintf(cmd, sizeof(cmd),
             "attach %.*s %.*s %u --pid %d",
             static_cast<int>(type.size()), type.data(),
             static_cast<int>(name.size()), name.data(),
             static_cast<unsigned>(port),
             static_cast<int>(getpid()));

    int rc = daemon_ipc(cmd);
    if (rc == 0)
    {
        g_attached_name = std::string(name);
        atexit([]{ daemon_detach(); });
        return true;
    }
    return false;
}

void daemon_detach()
{
    if (g_attached_name.empty()) return;
    std::string cmd = "remove " + g_attached_name;
    daemon_ipc(cmd.c_str());
    g_attached_name.clear();
}

} // namespace socketley

// ── socketley/shared/lua_context.cpp ──


#ifndef SOCKETLEY_NO_LUA

#ifndef SOCKETLEY_NO_HTTPS
#endif

lua_context::lua_context()
{
    m_lua.open_libraries(sol::lib::base, sol::lib::string, sol::lib::table,
                         sol::lib::math, sol::lib::os, sol::lib::io);
}

lua_context::~lua_context()
{
    *m_alive = false;
}

// ─── lua_timer: heap-allocated one-shot / repeating timer via op_timeout ───
struct lua_timer : io_handler
{
    std::shared_ptr<bool> alive;
    sol::function         fn;
    event_loop*           loop{};
    struct __kernel_timespec ts{};
    io_request            req{};
    bool                  repeat{false};

    void on_cqe(struct io_uring_cqe* cqe) override
    {
        if (!*alive || cqe->res == -ECANCELED) { delete this; return; }
        try { fn(); } catch (const sol::error& e) {
            fprintf(stderr, "[lua] timer error: %s\n", e.what());
        }
        if (repeat && *alive)
            loop->submit_timeout(&ts, &req);
        else
            delete this;
    }
};

static const char* state_to_string(runtime_state s)
{
    switch (s)
    {
        case runtime_created: return "created";
        case runtime_running: return "running";
        case runtime_stopped: return "stopped";
        case runtime_failed:  return "failed";
    }
    return "unknown";
}

bool lua_context::load_script(std::string_view path, runtime_instance* owner)
{
    register_bindings(owner);

    auto result = m_lua.safe_script_file(std::string(path), sol::script_pass_on_error);
    if (!result.valid())
    {
        sol::error err = result;
        std::cerr << "[lua] script error: " << err.what() << std::endl;
        return false;
    }

    m_on_start = m_lua["on_start"];
    m_on_stop = m_lua["on_stop"];
    m_on_message = m_lua["on_message"];
    m_on_send = m_lua["on_send"];
    m_on_connect = m_lua["on_connect"];
    m_on_disconnect = m_lua["on_disconnect"];
    m_on_route = m_lua["on_route"];
    m_on_master_auth = m_lua["on_master_auth"];
    m_on_client_message = m_lua["on_client_message"];
    m_on_tick = m_lua["on_tick"];
    if (m_on_tick.valid()) {
        sol::optional<int> tms = m_lua["tick_ms"];
        m_tick_ms = (tms && *tms >= 10) ? static_cast<uint32_t>(*tms) : 100;
    }
    m_on_miss   = m_lua["on_miss"];
    m_on_write  = m_lua["on_write"];
    m_on_delete = m_lua["on_delete"];
    m_on_expire = m_lua["on_expire"];
    m_on_auth       = m_lua["on_auth"];
    m_on_websocket  = m_lua["on_websocket"];
    m_on_proxy_request  = m_lua["on_proxy_request"];
    m_on_proxy_response = m_lua["on_proxy_response"];
    m_on_cluster_join   = m_lua["on_cluster_join"];
    m_on_cluster_leave  = m_lua["on_cluster_leave"];
    m_on_group_change   = m_lua["on_group_change"];

    return true;
}

bool lua_context::has_on_start() const { return m_on_start.valid(); }
bool lua_context::has_on_stop() const { return m_on_stop.valid(); }
bool lua_context::has_on_message() const { return m_on_message.valid(); }
bool lua_context::has_on_send() const { return m_on_send.valid(); }
bool lua_context::has_on_connect() const { return m_on_connect.valid(); }
bool lua_context::has_on_disconnect() const { return m_on_disconnect.valid(); }
bool lua_context::has_on_route() const { return m_on_route.valid(); }
bool lua_context::has_on_master_auth() const { return m_on_master_auth.valid(); }
bool lua_context::has_on_client_message() const { return m_on_client_message.valid(); }
bool lua_context::has_on_tick() const { return m_on_tick.valid(); }
bool lua_context::has_on_miss()   const { return m_on_miss.valid(); }
bool lua_context::has_on_write()  const { return m_on_write.valid(); }
bool lua_context::has_on_delete() const { return m_on_delete.valid(); }
bool lua_context::has_on_expire() const { return m_on_expire.valid(); }
bool lua_context::has_on_auth()            const { return m_on_auth.valid(); }
bool lua_context::has_on_websocket()       const { return m_on_websocket.valid(); }
bool lua_context::has_on_proxy_request()   const { return m_on_proxy_request.valid(); }
bool lua_context::has_on_proxy_response()  const { return m_on_proxy_response.valid(); }
bool lua_context::has_on_cluster_join()    const { return m_on_cluster_join.valid(); }
bool lua_context::has_on_cluster_leave()   const { return m_on_cluster_leave.valid(); }
bool lua_context::has_on_group_change()    const { return m_on_group_change.valid(); }

void lua_context::dispatch_publish(std::string_view cache_name, std::string_view channel, std::string_view message)
{
    auto key = std::string(cache_name) + '\0' + std::string(channel);
    auto it = m_subscriptions.find(key);
    if (it == m_subscriptions.end()) return;
    for (auto& fn : it->second)
    {
        try { fn(std::string(channel), std::string(message)); }
        catch (const sol::error& e)
        {
            fprintf(stderr, "[lua] subscribe callback error: %s\n", e.what());
        }
    }
}

void lua_context::update_self_state(const char* state_str)
{
    sol::optional<sol::table> self = m_lua["self"];
    if (self)
        (*self)["state"] = state_str;
}

// ---------------------------------------------------------------------------
// socketley.http(opts) — synchronous HTTP/HTTPS client for Lua scripts
// opts = { url, method="GET", body="", headers={}, timeout_ms=5000 }
// Returns { ok=bool, status=int, body=string, error=string }
// WARNING: Blocks the event loop thread. Use only in on_start/on_stop or
// low-frequency on_tick callbacks. For HTTPS, cert verification is skipped
// (SSL_VERIFY_NONE) — suitable for trusted internal services.
// ---------------------------------------------------------------------------
static sol::table socketley_http_call(sol::state& lua, sol::table opts)
{
    sol::table result = lua.create_table();
    result["ok"]     = false;
    result["status"] = 0;
    result["body"]   = std::string{};
    result["error"]  = std::string{};

    sol::optional<std::string> url_opt = opts["url"];
    if (!url_opt || url_opt->empty()) { result["error"] = "url required"; return result; }

    std::string method  = sol::optional<std::string>(opts["method"]).value_or("GET");
    std::string url     = *url_opt;
    std::string body    = sol::optional<std::string>(opts["body"]).value_or("");
    int timeout_ms      = sol::optional<int>(opts["timeout_ms"]).value_or(5000);

    // Parse scheme
    bool is_https = false;
    if (url.rfind("https://", 0) == 0)      { is_https = true;  url = url.substr(8); }
    else if (url.rfind("http://", 0) == 0)  {                   url = url.substr(7); }
    else { result["error"] = "unsupported scheme (use http:// or https://)"; return result; }

#ifdef SOCKETLEY_NO_HTTPS
    if (is_https) {
        result["error"] = "HTTPS not supported in this build; use io.popen(\"curl -s https://...\")";
        return result;
    }
#endif

    // Parse host:port/path
    int port = is_https ? 443 : 80;
    std::string host, path;
    auto slash = url.find('/');
    std::string host_port = (slash != std::string::npos) ? url.substr(0, slash) : url;
    path = (slash != std::string::npos) ? url.substr(slash) : "/";
    auto colon = host_port.rfind(':');
    if (colon != std::string::npos) {
        host = host_port.substr(0, colon);
        {
            auto ps = host_port.substr(colon + 1);
            std::from_chars(ps.data(), ps.data() + ps.size(), port);
        }
    } else {
        host = host_port;
    }

    // DNS resolve
    struct addrinfo hints{}, *addrs = nullptr;
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    std::string port_str = std::to_string(port);
    if (getaddrinfo(host.c_str(), port_str.c_str(), &hints, &addrs) != 0 || !addrs) {
        result["error"] = "DNS resolution failed for: " + host;
        return result;
    }

    // Connect
    int sock = ::socket(addrs->ai_family, SOCK_STREAM, 0);
    if (sock < 0) { freeaddrinfo(addrs); result["error"] = "socket() failed"; return result; }

    struct timeval tv;
    tv.tv_sec  = timeout_ms / 1000;
    tv.tv_usec = (timeout_ms % 1000) * 1000;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));

    if (::connect(sock, addrs->ai_addr, addrs->ai_addrlen) != 0) {
        freeaddrinfo(addrs); ::close(sock);
        result["error"] = "connect() failed";
        return result;
    }
    freeaddrinfo(addrs);

    // Build HTTP/1.0 request
    std::string req;
    req.reserve(256 + body.size());
    req += method + " " + path + " HTTP/1.0\r\n";
    req += "Host: " + host + "\r\n";
    if (!body.empty())
        req += "Content-Length: " + std::to_string(body.size()) + "\r\n";
    sol::optional<sol::table> hdrs = opts["headers"];
    if (hdrs) {
        (*hdrs).for_each([&](sol::object k, sol::object v) {
            if (k.is<std::string>() && v.is<std::string>())
                req += k.as<std::string>() + ": " + v.as<std::string>() + "\r\n";
        });
    }
    req += "Connection: close\r\n\r\n";
    req += body;

    // Send + receive
    std::string response;
    std::string send_err;

#ifndef SOCKETLEY_NO_HTTPS
    if (is_https) {
        SSL_CTX* ctx = SSL_CTX_new(TLS_client_method());
        if (!ctx) { ::close(sock); result["error"] = "SSL_CTX_new failed"; return result; }
        SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, nullptr);
        SSL* ssl = SSL_new(ctx);
        if (!ssl) { SSL_CTX_free(ctx); ::close(sock); result["error"] = "SSL_new failed"; return result; }
        SSL_set_fd(ssl, sock);
        SSL_set_tlsext_host_name(ssl, host.c_str());
        if (SSL_connect(ssl) != 1) {
            SSL_free(ssl); SSL_CTX_free(ctx); ::close(sock);
            result["error"] = "TLS handshake failed"; return result;
        }
        if (SSL_write(ssl, req.c_str(), static_cast<int>(req.size())) <= 0) {
            send_err = "SSL_write failed";
        } else {
            char buf[4096]; int n;
            while ((n = SSL_read(ssl, buf, sizeof(buf))) > 0)
                response.append(buf, n);
        }
        SSL_shutdown(ssl);
        SSL_free(ssl); SSL_CTX_free(ctx);
        ::close(sock);
    } else
#endif
    {
        if (::send(sock, req.c_str(), req.size(), 0) < 0) {
            send_err = "send() failed";
        } else {
            char buf[4096]; ssize_t n;
            while ((n = ::recv(sock, buf, sizeof(buf), 0)) > 0)
                response.append(buf, n);
        }
        ::close(sock);
    }

    if (!send_err.empty()) { result["error"] = send_err; return result; }

    // Parse HTTP status line: "HTTP/1.x NNN Reason"
    int status = 0;
    auto sp1 = response.find(' ');
    if (sp1 != std::string::npos) {
        auto sp2 = response.find(' ', sp1 + 1);
        {
            auto ss = response.substr(sp1 + 1, sp2 - sp1 - 1);
            std::from_chars(ss.data(), ss.data() + ss.size(), status);
        }
    }
    auto body_start = response.find("\r\n\r\n");
    result["status"] = status;
    result["body"]   = (body_start != std::string::npos) ? response.substr(body_start + 4) : "";
    result["ok"]     = (status >= 200 && status < 300);
    return result;
}

void lua_context::register_bindings(runtime_instance* owner)
{
    // Register socketley.log() and management API
    sol::table sk = m_lua.create_table();
    sk["log"] = [](std::string msg) {
        std::cerr << "[lua] " << msg << std::endl;
    };

    // socketley.create(type, name, config_table) → bool
    sk["create"] = [owner, this](std::string type_str, std::string name, sol::optional<sol::table> config) -> bool {
        auto* mgr = owner->get_runtime_manager();
        auto* loop = owner->get_event_loop();
        if (!mgr || !loop) return false;

        runtime_type type;
        if (!parse_runtime_type(type_str, type)) return false;

        if (!mgr->create(type, name)) return false;

        auto* inst = mgr->get(name);
        if (!inst) return false;

        inst->set_runtime_manager(mgr);
        inst->set_event_loop(loop);
        inst->set_owner(owner->get_name());
        inst->set_lua_created(true);

        if (config) {
            sol::optional<int> port = (*config)["port"];
            if (port) inst->set_port(static_cast<uint16_t>(*port));

            sol::optional<std::string> lua_script = (*config)["config"];
            if (!lua_script) lua_script = (*config)["lua"];
            if (lua_script && !lua_script->empty())
                inst->load_lua_script(*lua_script);

            sol::optional<std::string> target = (*config)["target"];
            if (target) inst->set_target(*target);

            sol::optional<std::string> mode_str = (*config)["mode"];
            if (mode_str && type == runtime_server) {
                auto* srv = static_cast<server_instance*>(inst);
                switch (fnv1a(*mode_str)) {
                    case fnv1a("in"):     srv->set_mode(mode_in);     break;
                    case fnv1a("out"):    srv->set_mode(mode_out);    break;
                    case fnv1a("master"): srv->set_mode(mode_master); break;
                    default:              srv->set_mode(mode_inout);  break;
                }
            }

            if (type == runtime_server) {
                auto* srv = static_cast<server_instance*>(inst);
                sol::optional<std::string> http_dir = (*config)["http"];
                if (http_dir && !http_dir->empty())
                    srv->set_http_dir(*http_dir);
                sol::optional<bool> http_cache = (*config)["http_cache"];
                if (http_cache && *http_cache)
                    srv->set_http_cache(true);
            }

            sol::optional<std::string> group = (*config)["group"];
            if (group && !group->empty())
                inst->set_group(*group);

            sol::optional<std::string> on_stop_str = (*config)["on_parent_stop"];
            if (on_stop_str && fnv1a(*on_stop_str) == fnv1a("remove"))
                inst->set_child_policy(runtime_instance::child_policy::remove);

            sol::optional<bool> start = (*config)["start"];
            if (start && *start)
                mgr->run(name, *loop);
        }

        return true;
    };

    // socketley.start(name) → bool
    sk["start"] = [owner](std::string name) -> bool {
        auto* mgr = owner->get_runtime_manager();
        auto* loop = owner->get_event_loop();
        if (!mgr || !loop) return false;
        return mgr->run(name, *loop);
    };

    // socketley.stop(name) → bool
    sk["stop"] = [owner](std::string name) -> bool {
        auto* mgr = owner->get_runtime_manager();
        auto* loop = owner->get_event_loop();
        if (!mgr || !loop) return false;
        return mgr->stop(name, *loop);
    };

    // socketley.remove(name) → bool
    sk["remove"] = [owner](std::string name) -> bool {
        auto* mgr = owner->get_runtime_manager();
        auto* loop = owner->get_event_loop();
        if (!mgr || !loop) return false;
        auto* inst = mgr->get(name);
        if (inst && inst->get_state() == runtime_running)
            mgr->stop(name, *loop);
        return mgr->remove(name);
    };

    // socketley.send(name, msg) → bool
    sk["send"] = [owner](std::string name, std::string msg) -> bool {
        auto* mgr = owner->get_runtime_manager();
        if (!mgr) return false;
        auto* inst = mgr->get(name);
        if (!inst || inst->get_state() != runtime_running) return false;
        if (inst->get_type() == runtime_server)
            inst->lua_broadcast(msg);
        else
            inst->lua_send(msg);
        return true;
    };

    // socketley.list() → table of names
    sk["list"] = [owner, this]() -> sol::table {
        sol::table result = m_lua.create_table();
        auto* mgr = owner->get_runtime_manager();
        if (!mgr) return result;
        std::shared_lock lock(mgr->mutex);
        int i = 1;
        for (const auto& [name, _] : mgr->list())
            result[i++] = name;
        return result;
    };

    // socketley.get(name) → table {name, type, state, port, connections, owner} or nil
    sk["get"] = [owner, this](std::string name) -> sol::object {
        auto* mgr = owner->get_runtime_manager();
        if (!mgr) return sol::nil;
        auto* inst = mgr->get(name);
        if (!inst) return sol::nil;
        sol::table info = m_lua.create_table();
        info["name"] = std::string(inst->get_name());
        info["type"] = type_to_string(inst->get_type());
        info["state"] = state_to_string(inst->get_state());
        info["port"] = inst->get_port();
        info["connections"] = inst->get_connection_count();
        auto ow = inst->get_owner();
        info["owner"] = ow.empty() ? sol::object(sol::nil) : sol::make_object(m_lua, std::string(ow));
        return info;
    };

    sk["http"] = [this](sol::table opts) -> sol::table {
        return socketley_http_call(m_lua, opts);
    };

    // socketley.set_timeout(ms, fn) — fires fn once after ms milliseconds
    sk["set_timeout"] = [this, owner](int ms, sol::function fn) {
        auto* loop = owner->get_event_loop();
        if (!loop || ms <= 0) return;
        auto* t  = new lua_timer{};
        t->alive  = m_alive;
        t->fn     = std::move(fn);
        t->loop   = loop;
        t->ts     = { (long long)ms / 1000, ((long long)ms % 1000) * 1'000'000LL };
        t->req    = { op_timeout, -1, nullptr, 0, t };
        t->repeat = false;
        loop->submit_timeout(&t->ts, &t->req);
    };

    // socketley.set_interval(ms, fn) — fires fn every ms milliseconds
    sk["set_interval"] = [this, owner](int ms, sol::function fn) {
        auto* loop = owner->get_event_loop();
        if (!loop || ms <= 0) return;
        auto* t  = new lua_timer{};
        t->alive  = m_alive;
        t->fn     = std::move(fn);
        t->loop   = loop;
        t->ts     = { (long long)ms / 1000, ((long long)ms % 1000) * 1'000'000LL };
        t->req    = { op_timeout, -1, nullptr, 0, t };
        t->repeat = true;
        loop->submit_timeout(&t->ts, &t->req);
    };

    // socketley.subscribe(cache_name, channel, fn) — receive published messages
    sk["subscribe"] = [this](std::string cache_name, std::string channel, sol::function fn) {
        m_subscriptions[cache_name + '\0' + channel].push_back(std::move(fn));
    };

    // ─── socketley.cluster.* — cluster introspection API ───
    sol::table cluster_tbl = m_lua.create_table();

    // socketley.cluster.daemons() → array of {name, host, runtimes}
    cluster_tbl["daemons"] = [owner, this]() -> sol::table {
        sol::table result = m_lua.create_table();
        auto* mgr = owner->get_runtime_manager();
        if (!mgr) return result;
        auto* cd = mgr->get_cluster_discovery();
        if (!cd) return result;

        int i = 1;
        // Local daemon entry
        {
            sol::table d = m_lua.create_table();
            d["name"] = std::string(cd->get_daemon_name());
            d["host"] = std::string(cd->get_cluster_addr());
            size_t count = 0;
            {
                std::shared_lock lock(mgr->mutex);
                count = mgr->list().size();
            }
            d["runtimes"] = static_cast<int>(count);
            result[i++] = d;
        }
        // Remote daemons
        auto daemons = cd->get_all_daemons();
        for (const auto& rd : daemons)
        {
            sol::table d = m_lua.create_table();
            d["name"] = rd.name;
            d["host"] = rd.host;
            d["runtimes"] = static_cast<int>(rd.runtimes.size());
            result[i++] = d;
        }
        return result;
    };

    // socketley.cluster.runtimes() → array of {daemon, name, type, port, group, state, connections}
    cluster_tbl["runtimes"] = [owner, this]() -> sol::table {
        sol::table result = m_lua.create_table();
        auto* mgr = owner->get_runtime_manager();
        if (!mgr) return result;
        auto* cd = mgr->get_cluster_discovery();
        if (!cd) return result;

        int i = 1;
        // Local runtimes
        {
            std::shared_lock lock(mgr->mutex);
            for (const auto& [name, inst] : mgr->list())
            {
                sol::table r = m_lua.create_table();
                r["daemon"] = std::string(cd->get_daemon_name());
                r["name"] = std::string(name);
                r["type"] = type_to_string(inst->get_type());
                r["port"] = inst->get_port();
                r["group"] = std::string(inst->get_group());
                r["state"] = state_to_string(inst->get_state());
                r["connections"] = static_cast<int>(inst->get_connection_count());
                result[i++] = r;
            }
        }
        // Remote runtimes
        auto daemons = cd->get_all_daemons();
        for (const auto& rd : daemons)
        {
            for (const auto& rt : rd.runtimes)
            {
                sol::table r = m_lua.create_table();
                r["daemon"] = rt.daemon_name;
                r["name"] = rt.name;
                r["type"] = rt.type;
                r["port"] = rt.port;
                r["group"] = rt.group;
                r["state"] = rt.state;
                r["connections"] = static_cast<int>(rt.connections);
                result[i++] = r;
            }
        }
        return result;
    };

    // socketley.cluster.group(name) → array of {daemon, host, port, connections}
    cluster_tbl["group"] = [owner, this](std::string group_name) -> sol::table {
        sol::table result = m_lua.create_table();
        auto* mgr = owner->get_runtime_manager();
        if (!mgr) return result;
        auto* cd = mgr->get_cluster_discovery();
        if (!cd) return result;

        int i = 1;
        // Local group members
        {
            std::shared_lock lock(mgr->mutex);
            for (const auto& [_, inst] : mgr->list())
            {
                if (inst->get_group() == group_name &&
                    inst->get_state() == runtime_running &&
                    inst->get_port() > 0)
                {
                    sol::table m = m_lua.create_table();
                    m["daemon"] = std::string(cd->get_daemon_name());
                    m["host"] = std::string(cd->get_cluster_addr());
                    m["port"] = inst->get_port();
                    m["connections"] = static_cast<int>(inst->get_connection_count());
                    result[i++] = m;
                }
            }
        }
        // Remote group members
        auto daemons = cd->get_all_daemons();
        for (const auto& rd : daemons)
        {
            for (const auto& rt : rd.runtimes)
            {
                if (rt.group == group_name && rt.state == "running" && rt.port > 0)
                {
                    sol::table m = m_lua.create_table();
                    m["daemon"] = rt.daemon_name;
                    m["host"] = rt.host;
                    m["port"] = rt.port;
                    m["connections"] = static_cast<int>(rt.connections);
                    result[i++] = m;
                }
            }
        }
        return result;
    };

    // socketley.cluster.stats() → {daemons, runtimes, running, groups={name=count}}
    cluster_tbl["stats"] = [owner, this]() -> sol::table {
        sol::table result = m_lua.create_table();
        auto* mgr = owner->get_runtime_manager();
        if (!mgr) return result;
        auto* cd = mgr->get_cluster_discovery();
        if (!cd) return result;

        int daemon_count = 1;  // include local
        int rt_total = 0;
        int rt_running = 0;
        std::unordered_map<std::string, int> groups;

        // Local runtimes
        {
            std::shared_lock lock(mgr->mutex);
            for (const auto& [_, inst] : mgr->list())
            {
                ++rt_total;
                if (inst->get_state() == runtime_running) ++rt_running;
                auto g = inst->get_group();
                if (!g.empty()) ++groups[std::string(g)];
            }
        }

        // Remote daemons
        auto daemons = cd->get_all_daemons();
        for (const auto& rd : daemons)
        {
            ++daemon_count;
            for (const auto& rt : rd.runtimes)
            {
                ++rt_total;
                if (rt.state == "running") ++rt_running;
                if (!rt.group.empty()) ++groups[rt.group];
            }
        }

        result["daemons"] = daemon_count;
        result["runtimes"] = rt_total;
        result["running"] = rt_running;

        sol::table grp_tbl = m_lua.create_table();
        for (const auto& [name, count] : groups)
            grp_tbl[name] = count;
        result["groups"] = grp_tbl;

        return result;
    };

    sk["cluster"] = cluster_tbl;

    m_lua["socketley"] = sk;

    // Register "self" table with runtime properties and actions
    sol::table self = m_lua.create_table();
    self["name"] = std::string(owner->get_name());
    self["port"] = owner->get_port();
    self["type"] = type_to_string(owner->get_type());
    self["state"] = state_to_string(owner->get_state());

    // Register type-specific action methods
    switch (owner->get_type())
    {
        case runtime_server:
            register_server_table(owner, self);
            break;
        case runtime_client:
            register_client_table(owner, self);
            break;
        case runtime_cache:
            register_cache_table(owner, self);
            break;
        case runtime_proxy:
            register_proxy_table(owner, self);
            break;
    }

    m_lua["self"] = self;

    // Also register type-specific alias (server/client/cache/proxy) pointing to same table
    m_lua[type_to_string(owner->get_type())] = self;
}

void lua_context::register_server_table(runtime_instance* owner, sol::table& self)
{
    self["broadcast"] = [owner](std::string msg) {
        owner->lua_broadcast(msg);
    };
    self["send"] = [owner](int client_id, std::string msg) {
        owner->lua_send_to(client_id, msg);
    };
    self["connections"] = [owner]() -> size_t {
        return owner->get_connection_count();
    };
    self["protocol"] = owner->is_udp() ? "udp" : "tcp";

    // Client routing
    self["route"] = [owner](int client_id, std::string target) -> bool {
        return static_cast<server_instance*>(owner)->route_client(client_id, target);
    };
    self["unroute"] = [owner](int client_id) -> bool {
        return static_cast<server_instance*>(owner)->unroute_client(client_id);
    };
    self["get_route"] = [owner, this](int client_id) -> sol::object {
        auto route = static_cast<server_instance*>(owner)->get_client_route(client_id);
        if (route.empty()) return sol::nil;
        return sol::make_object(m_lua, std::string(route));
    };

    // Owner-targeted sending (sub-server → owner's clients)
    self["owner_send"] = [owner](int client_id, std::string msg) -> bool {
        return static_cast<server_instance*>(owner)->owner_send(client_id, msg);
    };
    self["owner_broadcast"] = [owner](std::string msg) -> bool {
        return static_cast<server_instance*>(owner)->owner_broadcast(msg);
    };

    // Connection control
    self["disconnect"] = [owner](int client_id) {
        static_cast<server_instance*>(owner)->lua_disconnect(client_id);
    };
    self["peer_ip"] = [owner](int client_id) -> std::string {
        return static_cast<server_instance*>(owner)->lua_peer_ip(client_id);
    };
    self["ws_headers"] = [owner, this](int client_id) -> sol::object {
        auto h = static_cast<server_instance*>(owner)->lua_ws_headers(client_id);
        if (!h.is_websocket) return sol::nil;
        sol::table t = m_lua.create_table();
        if (!h.cookie.empty())   t["cookie"]        = h.cookie;
        if (!h.origin.empty())   t["origin"]        = h.origin;
        if (!h.protocol.empty()) t["protocol"]      = h.protocol;
        if (!h.auth.empty())     t["authorization"] = h.auth;
        return t;
    };

    // Client enumeration
    self["clients"] = [owner, this]() -> sol::table {
        sol::table t = m_lua.create_table();
        auto ids = static_cast<server_instance*>(owner)->lua_clients();
        for (int i = 0; i < (int)ids.size(); ++i) t[i + 1] = ids[i];
        return t;
    };

    // Targeted multicast to a subset of clients
    self["multicast"] = [owner](sol::table ids, std::string msg) {
        std::vector<int> fds;
        ids.for_each([&](sol::object, sol::object v) {
            if (v.is<int>()) fds.push_back(v.as<int>());
        });
        static_cast<server_instance*>(owner)->lua_multicast(fds, msg);
    };

    // Per-connection metadata: nil value deletes the key
    self["set_data"] = [owner](int id, std::string key, sol::optional<std::string> val) {
        if (val)
            static_cast<server_instance*>(owner)->lua_set_data(id, key, *val);
        else
            static_cast<server_instance*>(owner)->lua_del_data(id, key);
    };
    self["get_data"] = [owner, this](int id, std::string key) -> sol::object {
        auto v = static_cast<server_instance*>(owner)->lua_get_data(id, key);
        if (v.empty()) return sol::nil;
        return sol::make_object(m_lua, v);
    };
}

void lua_context::register_client_table(runtime_instance* owner, sol::table& self)
{
    self["send"] = [owner](std::string msg) {
        owner->lua_send(msg);
    };
    self["connections"] = [owner]() -> size_t {
        return owner->get_connection_count();
    };
    self["protocol"] = owner->is_udp() ? "udp" : "tcp";
}

void lua_context::register_cache_table(runtime_instance* owner, sol::table& self)
{
    // Strings
    self["get"] = [owner](std::string key) -> std::string {
        return owner->lua_cache_get(key);
    };
    self["set"] = [owner](std::string key, std::string value) -> bool {
        return owner->lua_cache_set(key, value);
    };
    self["del"] = [owner](std::string key) -> bool {
        return owner->lua_cache_del(key);
    };

    // Lists
    self["lpush"] = [owner](std::string key, std::string val) -> bool {
        return owner->lua_cache_lpush(key, val);
    };
    self["rpush"] = [owner](std::string key, std::string val) -> bool {
        return owner->lua_cache_rpush(key, val);
    };
    self["lpop"] = [owner](std::string key) -> std::string {
        return owner->lua_cache_lpop(key);
    };
    self["rpop"] = [owner](std::string key) -> std::string {
        return owner->lua_cache_rpop(key);
    };
    self["llen"] = [owner](std::string key) -> int {
        return owner->lua_cache_llen(key);
    };

    // Sets
    self["sadd"] = [owner](std::string key, std::string member) -> int {
        return owner->lua_cache_sadd(key, member);
    };
    self["srem"] = [owner](std::string key, std::string member) -> bool {
        return owner->lua_cache_srem(key, member);
    };
    self["sismember"] = [owner](std::string key, std::string member) -> bool {
        return owner->lua_cache_sismember(key, member);
    };
    self["scard"] = [owner](std::string key) -> int {
        return owner->lua_cache_scard(key);
    };

    // Hashes
    self["hset"] = [owner](std::string key, std::string field, std::string val) -> bool {
        return owner->lua_cache_hset(key, field, val);
    };
    self["hget"] = [owner](std::string key, std::string field) -> std::string {
        return owner->lua_cache_hget(key, field);
    };
    self["hdel"] = [owner](std::string key, std::string field) -> bool {
        return owner->lua_cache_hdel(key, field);
    };
    self["hlen"] = [owner](std::string key) -> int {
        return owner->lua_cache_hlen(key);
    };

    // TTL
    self["expire"] = [owner](std::string key, int seconds) -> bool {
        return owner->lua_cache_expire(key, seconds);
    };
    self["ttl"] = [owner](std::string key) -> int {
        return owner->lua_cache_ttl(key);
    };
    self["persist"] = [owner](std::string key) -> bool {
        return owner->lua_cache_persist(key);
    };

    // Pub/Sub
    self["publish"] = [owner](std::string channel, std::string message) -> int {
        return owner->lua_cache_publish(channel, message);
    };

    self["connections"] = [owner]() -> size_t {
        return owner->get_connection_count();
    };
}

void lua_context::register_proxy_table(runtime_instance* owner, sol::table& self)
{
    self["connections"] = [owner]() -> size_t {
        return owner->get_connection_count();
    };
}

#endif // SOCKETLEY_NO_LUA

// ── socketley/shared/runtime_instance.cpp ──


runtime_instance::runtime_instance(runtime_type type, std::string_view name)
    : m_name(name), m_id(generate_runtime_id()), m_type(type), m_state(runtime_created),
      m_created_time(std::chrono::system_clock::now())
{
}

runtime_instance::~runtime_instance() = default;

void runtime_instance::tick_handler::on_cqe(struct io_uring_cqe* cqe)
{
    if (!rt) { delete this; return; }
    rt->fire_tick(cqe->res);
}

void runtime_instance::start_tick_timer()
{
    uint32_t ms = m_cb_tick_ms > 0 ? m_cb_tick_ms
                : (m_lua ? m_lua->get_tick_ms() : 100);
    if (ms < 10) ms = 10;
    m_tick = new tick_handler();
    m_tick->rt = this;
    m_tick->req = { op_timeout, -1, nullptr, 0, m_tick };
    m_tick->ts = { static_cast<long long>(ms / 1000),
                   static_cast<long long>((ms % 1000) * 1000000LL) };
    m_tick->last = std::chrono::steady_clock::now();
    m_event_loop->submit_timeout(&m_tick->ts, &m_tick->req);
}

void runtime_instance::fire_tick(int res)
{
    if (res == -ECANCELED || !m_tick) return;
    auto now = std::chrono::steady_clock::now();
    double dt = std::chrono::duration<double, std::milli>(now - m_tick->last).count();
    m_tick->last = now;
    if (m_cb_on_tick) {
        m_cb_on_tick(dt);
    } else if (m_lua && m_lua->has_on_tick()) {
#ifndef SOCKETLEY_NO_LUA
        try { m_lua->on_tick()(dt); }
        catch (const sol::error& e) { std::cerr << "[lua] on_tick error: " << e.what() << "\n"; }
#endif
    }
    if (!m_tick || !m_event_loop) return;
    uint32_t ms = m_cb_tick_ms > 0 ? m_cb_tick_ms
                : (m_lua ? m_lua->get_tick_ms() : 100);
    if (ms < 10) ms = 10;
    m_tick->ts = { static_cast<long long>(ms / 1000),
                   static_cast<long long>((ms % 1000) * 1000000LL) };
    m_event_loop->submit_timeout(&m_tick->ts, &m_tick->req);
}

bool runtime_instance::start(event_loop& loop)
{
    runtime_state current = m_state.load(std::memory_order_acquire);

    if (current != runtime_created && current != runtime_stopped)
        return false;

    if (m_external)
    {
        m_state.store(runtime_running, std::memory_order_release);
        m_start_time = std::chrono::system_clock::now();
        return true;  // skip setup(), on_start, tick timer
    }

    if (!setup(loop))
    {
        m_state.store(runtime_failed, std::memory_order_release);
        return false;
    }

    m_state.store(runtime_running, std::memory_order_release);
    m_start_time = std::chrono::system_clock::now();
    invoke_on_start();
    if ((m_cb_on_tick || (m_lua && m_lua->has_on_tick())) && m_event_loop)
        start_tick_timer();
    return true;
}

bool runtime_instance::stop(event_loop& loop)
{
    if (m_state.load(std::memory_order_acquire) != runtime_running)
        return false;

    if (m_external)
    {
        if (m_pid > 0)
            kill(m_pid, SIGTERM);   // ask the external process to shut down
        m_state.store(runtime_stopped, std::memory_order_release);
        return true;  // skip teardown(), on_stop
    }

    if (m_tick) { m_tick->rt = nullptr; m_tick = nullptr; }
    invoke_on_stop();
    teardown(loop);
    m_state.store(runtime_stopped, std::memory_order_release);

    // Signal all interactive sessions that runtime has stopped
    for (int ifd : m_interactive_fds)
        if (::write(ifd, "\0", 1) < 0) {}
    m_interactive_fds.clear();

    return true;
}

runtime_state runtime_instance::get_state() const
{
    return m_state.load(std::memory_order_relaxed);
}

runtime_type runtime_instance::get_type() const
{
    return m_type;
}

std::string_view runtime_instance::get_name() const
{
    return m_name;
}

void runtime_instance::set_name(std::string_view name)
{
    m_name = std::string(name);
}

std::string_view runtime_instance::get_id() const
{
    return m_id;
}

void runtime_instance::set_id(std::string_view id)
{
    m_id = id;
}

std::chrono::system_clock::time_point runtime_instance::get_created_time() const
{
    return m_created_time;
}

std::chrono::system_clock::time_point runtime_instance::get_start_time() const
{
    return m_start_time;
}

void runtime_instance::set_port(uint16_t port)
{
    m_port = port;
}

uint16_t runtime_instance::get_port() const
{
    return m_port;
}

void runtime_instance::set_log_file(std::string_view path)
{
    m_log_file = path;
}

std::string_view runtime_instance::get_log_file() const
{
    return m_log_file;
}

void runtime_instance::set_write_file(std::string_view path)
{
    m_write_file = path;
}

std::string_view runtime_instance::get_write_file() const
{
    return m_write_file;
}

void runtime_instance::set_test_mode(bool enabled)
{
    m_test_mode = enabled;
}

bool runtime_instance::get_test_mode() const
{
    return m_test_mode;
}

void runtime_instance::set_target(std::string_view target)
{
    m_target = target;
}

std::string_view runtime_instance::get_target() const
{
    return m_target;
}

void runtime_instance::set_cache_name(std::string_view name)
{
    m_cache_name = name;
}

std::string_view runtime_instance::get_cache_name() const
{
    return m_cache_name;
}

void runtime_instance::set_bash_output(bool enabled)
{
    m_bash_output = enabled;
}

void runtime_instance::set_bash_prefix(bool enabled)
{
    m_bash_prefix = enabled;
}

void runtime_instance::set_bash_timestamp(bool enabled)
{
    m_bash_timestamp = enabled;
}

bool runtime_instance::get_bash_output() const
{
    return m_bash_output;
}

bool runtime_instance::get_bash_prefix() const
{
    return m_bash_prefix;
}

bool runtime_instance::get_bash_timestamp() const
{
    return m_bash_timestamp;
}

void runtime_instance::print_bash_message(std::string_view msg) const
{
    if (!m_bash_output)
        return;

    if (m_bash_timestamp)
    {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        std::tm tm{};
        localtime_r(&time, &tm);
        std::cout << "[" << std::put_time(&tm, "%H:%M:%S") << "] ";
    }

    if (m_bash_prefix)
        std::cout << "[" << m_name << "] ";

    // Sanitize control characters (terminal escape injection prevention)
    for (char c : msg)
    {
        unsigned char uc = static_cast<unsigned char>(c);
        if ((uc < 0x20 && uc != '\t') || uc == 0x7F)
            std::cout << '?';
        else
            std::cout << c;
    }
    std::cout << std::endl;
}

bool runtime_instance::load_lua_script(std::string_view path)
{
    m_lua = std::make_unique<lua_context>();

    if (!m_lua->load_script(path, this))
    {
        m_lua.reset();
        return false;
    }

    m_lua_script_path = path;
    return true;
}

bool runtime_instance::reload_lua_script()
{
    if (m_lua_script_path.empty())
        return false;

    if (m_state.load(std::memory_order_acquire) != runtime_running)
        return false;

    m_lua.reset();
    m_lua = std::make_unique<lua_context>();

    if (!m_lua->load_script(m_lua_script_path, this))
    {
        m_lua.reset();
        return false;
    }

#ifndef SOCKETLEY_NO_LUA
    m_lua->update_self_state("running");
#endif

    bool should_tick = m_lua->has_on_tick();
    if (!m_tick && should_tick)
        start_tick_timer();
    else if (m_tick && !should_tick) {
        m_tick->rt = nullptr;
        m_tick = nullptr;
    }

    return true;
}

std::string_view runtime_instance::get_lua_script_path() const
{
    return m_lua_script_path;
}

void runtime_instance::invoke_on_start()
{
    if (m_cb_on_start) { m_cb_on_start(); return; }
    if (!m_lua || !m_lua->has_on_start())
        return;

#ifndef SOCKETLEY_NO_LUA
    m_lua->update_self_state("running");

    try {
        m_lua->on_start()();
    } catch (const sol::error& e) {
        std::cerr << "[lua] on_start error: " << e.what() << std::endl;
    }
#endif
}

void runtime_instance::invoke_on_stop()
{
    if (m_cb_on_stop) { m_cb_on_stop(); return; }
    if (!m_lua || !m_lua->has_on_stop())
        return;

#ifndef SOCKETLEY_NO_LUA
    m_lua->update_self_state("stopped");

    try {
        m_lua->on_stop()();
    } catch (const sol::error& e) {
        std::cerr << "[lua] on_stop error: " << e.what() << std::endl;
    }
#endif
}

void runtime_instance::invoke_on_message(std::string_view msg)
{
    if (m_cb_on_message) { m_cb_on_message(msg); return; }
    if (!m_lua || !m_lua->has_on_message())
        return;

#ifndef SOCKETLEY_NO_LUA
    try {
        m_lua->on_message()(std::string(msg));
    } catch (const sol::error& e) {
        std::cerr << "[lua] on_message error: " << e.what() << std::endl;
    }
#endif
}

void runtime_instance::invoke_on_connect(int client_id)
{
    if (m_cb_on_connect) { m_cb_on_connect(client_id); return; }
    if (!m_lua || !m_lua->has_on_connect())
        return;

#ifndef SOCKETLEY_NO_LUA
    try {
        m_lua->on_connect()(client_id);
    } catch (const sol::error& e) {
        std::cerr << "[lua] on_connect error: " << e.what() << std::endl;
    }
#endif
}

void runtime_instance::invoke_on_disconnect(int client_id)
{
    if (m_cb_on_disconnect) { m_cb_on_disconnect(client_id); return; }
    if (!m_lua || !m_lua->has_on_disconnect())
        return;

#ifndef SOCKETLEY_NO_LUA
    try {
        m_lua->on_disconnect()(client_id);
    } catch (const sol::error& e) {
        std::cerr << "[lua] on_disconnect error: " << e.what() << std::endl;
    }
#endif
}

bool runtime_instance::invoke_on_auth(int client_id)
{
#ifndef SOCKETLEY_NO_LUA
    if (!m_lua || !m_lua->has_on_auth()) return true;  // no hook = allow
    try {
        sol::optional<bool> res = m_lua->on_auth()(client_id);
        return res.value_or(false);  // nil/non-bool → reject (fail-closed)
    } catch (const sol::error& e) {
        std::cerr << "[lua] on_auth error: " << e.what() << "\n";
        return false;  // Lua error → reject (fail-closed)
    }
#else
    return true;
#endif
}

void runtime_instance::invoke_on_send(std::string_view msg)
{
    if (!m_lua || !m_lua->has_on_send())
        return;

#ifndef SOCKETLEY_NO_LUA
    try {
        m_lua->on_send()(std::string(msg));
    } catch (const sol::error& e) {
        std::cerr << "[lua] on_send error: " << e.what() << std::endl;
    }
#endif
}

// ─── C++ callbacks ───

void runtime_instance::set_on_start(std::function<void()> cb)                            { m_cb_on_start = std::move(cb); }
void runtime_instance::set_on_stop(std::function<void()> cb)                             { m_cb_on_stop = std::move(cb); }
void runtime_instance::set_on_connect(std::function<void(int)> cb)                       { m_cb_on_connect = std::move(cb); }
void runtime_instance::set_on_disconnect(std::function<void(int)> cb)                    { m_cb_on_disconnect = std::move(cb); }
void runtime_instance::set_on_client_message(std::function<void(int, std::string_view)> cb) { m_cb_on_client_message = std::move(cb); }
void runtime_instance::set_on_message(std::function<void(std::string_view)> cb)          { m_cb_on_message = std::move(cb); }
void runtime_instance::set_on_tick(std::function<void(double)> cb)                       { m_cb_on_tick = std::move(cb); }
void runtime_instance::set_tick_interval(uint32_t ms)                                    { m_cb_tick_ms = ms; }

// ─── Group ───

void runtime_instance::set_group(std::string_view group) { m_group = std::string(group); }
std::string_view runtime_instance::get_group() const { return m_group; }

// ─── Ownership ───

void runtime_instance::set_owner(std::string_view owner_name) { m_owner = std::string(owner_name); }
std::string_view runtime_instance::get_owner() const { return m_owner; }
void runtime_instance::set_lua_created(bool v) { m_lua_created = v; }
bool runtime_instance::is_lua_created() const { return m_lua_created; }
void runtime_instance::mark_external() { m_external = true; }
bool runtime_instance::is_external() const { return m_external; }
void runtime_instance::set_pid(pid_t pid) { m_pid = pid; }
pid_t runtime_instance::get_pid() const { return m_pid; }
void runtime_instance::set_child_policy(child_policy p) { m_child_policy = p; }
runtime_instance::child_policy runtime_instance::get_child_policy() const { return m_child_policy; }

void runtime_instance::set_runtime_manager(runtime_manager* mgr) { m_runtime_manager = mgr; }
void runtime_instance::set_event_loop(event_loop* loop) { m_event_loop = loop; }
runtime_manager* runtime_instance::get_runtime_manager() const { return m_runtime_manager; }
event_loop* runtime_instance::get_event_loop() const { return m_event_loop; }

void runtime_instance::invoke_on_client_message(int client_id, std::string_view msg)
{
    if (m_cb_on_client_message) { m_cb_on_client_message(client_id, msg); return; }
    if (!m_lua || !m_lua->has_on_client_message())
        return;

#ifndef SOCKETLEY_NO_LUA
    try {
        m_lua->on_client_message()(client_id, std::string(msg));
    } catch (const sol::error& e) {
        std::cerr << "[lua] on_client_message error: " << e.what() << std::endl;
    }
#endif
}

// ─── Resource limits ───

void runtime_instance::set_max_connections(uint32_t max) { m_max_connections = max; }
uint32_t runtime_instance::get_max_connections() const { return m_max_connections; }

void runtime_instance::set_rate_limit(double rate) { m_rate_limit = rate; }
double runtime_instance::get_rate_limit() const { return m_rate_limit; }

void runtime_instance::set_global_rate_limit(double rate) { m_global_rate_limit = rate; m_global_tokens = rate; m_global_last = std::chrono::steady_clock::now(); }
double runtime_instance::get_global_rate_limit() const { return m_global_rate_limit; }

bool runtime_instance::check_global_rate_limit()
{
    if (m_global_rate_limit <= 0.0) return true;
    auto now = std::chrono::steady_clock::now();
    double elapsed = std::chrono::duration<double>(now - m_global_last).count();
    m_global_last = now;
    m_global_tokens = std::min(m_global_rate_limit, m_global_tokens + elapsed * m_global_rate_limit);
    if (m_global_tokens < 1.0) return false;
    m_global_tokens -= 1.0;
    return true;
}

void runtime_instance::set_idle_timeout(uint32_t seconds) { m_idle_timeout = seconds; }
uint32_t runtime_instance::get_idle_timeout() const { return m_idle_timeout; }

void runtime_instance::set_drain(bool enabled) { m_drain = enabled; }
bool runtime_instance::get_drain() const { return m_drain; }

void runtime_instance::set_reconnect(int max_attempts) { m_reconnect = max_attempts; }
int runtime_instance::get_reconnect() const { return m_reconnect; }

// ─── TLS ───

void runtime_instance::set_tls(bool enabled) { m_tls = enabled; }
bool runtime_instance::get_tls() const { return m_tls; }
void runtime_instance::set_cert_path(std::string_view path) { m_cert_path = path; }
std::string_view runtime_instance::get_cert_path() const { return m_cert_path; }
void runtime_instance::set_key_path(std::string_view path) { m_key_path = path; }
std::string_view runtime_instance::get_key_path() const { return m_key_path; }
void runtime_instance::set_ca_path(std::string_view path) { m_ca_path = path; }
std::string_view runtime_instance::get_ca_path() const { return m_ca_path; }

// ─── Stats ───

std::string runtime_instance::get_stats() const
{
    std::ostringstream out;
    out << "name:" << m_name << "\n"
        << "type:" << (m_type == runtime_server ? "server" :
                      m_type == runtime_client ? "client" :
                      m_type == runtime_proxy  ? "proxy"  :
                      m_type == runtime_cache  ? "cache"  : "unknown") << "\n"
        << "port:" << m_port << "\n"
        << "connections:" << get_connection_count() << "\n"
        << "total_connections:" << m_stat_total_connections.load(std::memory_order_relaxed) << "\n"
        << "total_messages:" << m_stat_total_messages.load(std::memory_order_relaxed) << "\n"
        << "bytes_in:" << m_stat_bytes_in.load(std::memory_order_relaxed) << "\n"
        << "bytes_out:" << m_stat_bytes_out.load(std::memory_order_relaxed) << "\n";
    return out.str();
}

// ─── Interactive mode ───

void runtime_instance::add_interactive_fd(int fd)
{
    m_interactive_fds.push_back(fd);
}

void runtime_instance::remove_interactive_fd(int fd)
{
    m_interactive_fds.erase(
        std::remove(m_interactive_fds.begin(), m_interactive_fds.end(), fd),
        m_interactive_fds.end());
}

void runtime_instance::notify_interactive(std::string_view msg) const
{
    if (m_interactive_fds.empty())
        return;

    std::string line;
    line.reserve(msg.size() + 1);
    line.append(msg.data(), msg.size());
    if (line.empty() || line.back() != '\n')
        line += '\n';

    for (size_t i = 0; i < m_interactive_fds.size(); )
    {
        ssize_t n = ::write(m_interactive_fds[i], line.data(), line.size());
        if (n < 0 && errno == EPIPE)
        {
            // Remove dead fd (const_cast is safe since we own the vector)
            auto& fds = const_cast<std::vector<int>&>(m_interactive_fds);
            fds.erase(fds.begin() + i);
        }
        else
            ++i;
    }
}

void runtime_instance::on_publish_dispatch(std::string_view cache_name, std::string_view channel, std::string_view message)
{
#ifndef SOCKETLEY_NO_LUA
    if (m_lua) m_lua->dispatch_publish(cache_name, channel, message);
#endif
}

// ── socketley/runtime/cache/cache_store.cpp ──


// ─── Type conflict checks (fast-path: empty() avoids hash lookups) ───

bool cache_store::has_type_conflict_for_string(std::string_view key) const
{
    if (!m_lists.empty() && m_lists.count(key)) return true;
    if (!m_sets.empty() && m_sets.count(key)) return true;
    if (!m_hashes.empty() && m_hashes.count(key)) return true;
    return false;
}

bool cache_store::has_type_conflict_for_list(std::string_view key) const
{
    if (!m_data.empty() && m_data.count(key)) return true;
    if (!m_sets.empty() && m_sets.count(key)) return true;
    if (!m_hashes.empty() && m_hashes.count(key)) return true;
    return false;
}

bool cache_store::has_type_conflict_for_set(std::string_view key) const
{
    if (!m_data.empty() && m_data.count(key)) return true;
    if (!m_lists.empty() && m_lists.count(key)) return true;
    if (!m_hashes.empty() && m_hashes.count(key)) return true;
    return false;
}

bool cache_store::has_type_conflict_for_hash(std::string_view key) const
{
    if (!m_data.empty() && m_data.count(key)) return true;
    if (!m_lists.empty() && m_lists.count(key)) return true;
    if (!m_sets.empty() && m_sets.count(key)) return true;
    return false;
}

// ─── Strings ───

bool cache_store::set(std::string_view key, std::string_view value)
{
    if (has_type_conflict_for_string(key))
        return false;

    if (auto it = m_data.find(key); it != m_data.end())
    {
        track_sub(it->second.size());
        it->second = value;
        track_add(value.size());
        touch_lru(key);
        return true;
    }

    if (!check_memory(key.size() + value.size()))
        return false;

    m_data.emplace(std::string(key), std::string(value));
    track_add(key.size() + value.size());
    touch_lru(key);
    return true;
}

bool cache_store::get(std::string_view key, std::string& out) const
{
    auto it = m_data.find(key);
    if (it == m_data.end())
        return false;

    out = it->second;
    return true;
}

const std::string* cache_store::get_ptr(std::string_view key) const
{
    auto it = m_data.find(key);
    if (it == m_data.end())
        return nullptr;
    const_cast<cache_store*>(this)->touch_lru(key);
    return &it->second;
}

// ─── Lists ───

bool cache_store::lpush(std::string_view key, std::string_view val)
{
    auto it = m_lists.find(key);
    if (it != m_lists.end())
    {
        if (!check_memory(val.size()))
            return false;
        it->second.emplace_front(val);
        track_add(val.size());
        touch_lru(key);
        return true;
    }

    if (has_type_conflict_for_list(key))
        return false;

    if (!check_memory(key.size() + val.size()))
        return false;

    m_lists.emplace(std::string(key), std::deque<std::string>{}).first->second.emplace_front(val);
    track_add(key.size() + val.size());
    touch_lru(key);
    return true;
}

bool cache_store::rpush(std::string_view key, std::string_view val)
{
    auto it = m_lists.find(key);
    if (it != m_lists.end())
    {
        if (!check_memory(val.size()))
            return false;
        it->second.emplace_back(val);
        track_add(val.size());
        touch_lru(key);
        return true;
    }

    if (has_type_conflict_for_list(key))
        return false;

    if (!check_memory(key.size() + val.size()))
        return false;

    m_lists.emplace(std::string(key), std::deque<std::string>{}).first->second.emplace_back(val);
    track_add(key.size() + val.size());
    touch_lru(key);
    return true;
}

bool cache_store::lpop(std::string_view key, std::string& out)
{
    auto it = m_lists.find(key);
    if (it == m_lists.end() || it->second.empty())
        return false;

    out = std::move(it->second.front());
    it->second.pop_front();
    track_sub(out.size());

    if (it->second.empty())
    {
        track_sub(key.size());
        m_lists.erase(it);
        m_expiry.erase(std::string(key));
        m_lru_map.erase(std::string(key));
    }
    return true;
}

bool cache_store::rpop(std::string_view key, std::string& out)
{
    auto it = m_lists.find(key);
    if (it == m_lists.end() || it->second.empty())
        return false;

    out = std::move(it->second.back());
    it->second.pop_back();
    track_sub(out.size());

    if (it->second.empty())
    {
        track_sub(key.size());
        m_lists.erase(it);
        m_expiry.erase(std::string(key));
        m_lru_map.erase(std::string(key));
    }
    return true;
}

int cache_store::llen(std::string_view key) const
{
    auto it = m_lists.find(key);
    if (it == m_lists.end())
        return 0;
    return static_cast<int>(it->second.size());
}

const std::deque<std::string>* cache_store::list_ptr(std::string_view key) const
{
    auto it = m_lists.find(key);
    if (it == m_lists.end())
        return nullptr;
    return &it->second;
}

const std::string* cache_store::lindex(std::string_view key, int idx) const
{
    auto it = m_lists.find(key);
    if (it == m_lists.end())
        return nullptr;

    const auto& deq = it->second;
    int len = static_cast<int>(deq.size());

    if (idx < 0)
        idx += len;
    if (idx < 0 || idx >= len)
        return nullptr;

    return &deq[static_cast<size_t>(idx)];
}

// ─── Sets ───

int cache_store::sadd(std::string_view key, std::string_view member)
{
    auto it = m_sets.find(key);
    if (it != m_sets.end())
    {
        if (!check_memory(member.size()))
            return -1;
        auto [_, inserted] = it->second.emplace(member);
        if (inserted)
        {
            track_add(member.size());
            touch_lru(key);
        }
        return inserted ? 1 : 0;
    }

    if (has_type_conflict_for_set(key))
        return -1;

    if (!check_memory(key.size() + member.size()))
        return -1;

    auto& s = m_sets.emplace(std::string(key), set_inner{}).first->second;
    s.emplace(member);
    track_add(key.size() + member.size());
    touch_lru(key);
    return 1;
}

bool cache_store::srem(std::string_view key, std::string_view member)
{
    auto it = m_sets.find(key);
    if (it == m_sets.end())
        return false;

    auto mit = it->second.find(member);
    if (mit == it->second.end())
        return false;

    track_sub(mit->size());
    it->second.erase(mit);

    if (it->second.empty())
    {
        track_sub(key.size());
        m_sets.erase(it);
        m_expiry.erase(std::string(key));
        m_lru_map.erase(std::string(key));
    }
    return true;
}

bool cache_store::sismember(std::string_view key, std::string_view member) const
{
    auto it = m_sets.find(key);
    if (it == m_sets.end())
        return false;
    return it->second.count(member) > 0;
}

int cache_store::scard(std::string_view key) const
{
    auto it = m_sets.find(key);
    if (it == m_sets.end())
        return 0;
    return static_cast<int>(it->second.size());
}

const set_inner* cache_store::set_ptr(std::string_view key) const
{
    auto it = m_sets.find(key);
    if (it == m_sets.end())
        return nullptr;
    return &it->second;
}

// ─── Hashes ───

bool cache_store::hset(std::string_view key, std::string_view field, std::string_view val)
{
    auto it = m_hashes.find(key);
    if (it != m_hashes.end())
    {
        auto fit = it->second.find(field);
        if (fit != it->second.end())
        {
            track_sub(fit->second.size());
            fit->second = val;
            track_add(val.size());
        }
        else
        {
            if (!check_memory(field.size() + val.size()))
                return false;
            it->second.emplace(std::string(field), std::string(val));
            track_add(field.size() + val.size());
        }
        touch_lru(key);
        return true;
    }

    if (has_type_conflict_for_hash(key))
        return false;

    if (!check_memory(key.size() + field.size() + val.size()))
        return false;

    auto& h = m_hashes.emplace(std::string(key), hash_inner{}).first->second;
    h.emplace(std::string(field), std::string(val));
    track_add(key.size() + field.size() + val.size());
    touch_lru(key);
    return true;
}

const std::string* cache_store::hget(std::string_view key, std::string_view field) const
{
    auto it = m_hashes.find(key);
    if (it == m_hashes.end())
        return nullptr;

    auto fit = it->second.find(field);
    if (fit == it->second.end())
        return nullptr;

    return &fit->second;
}

bool cache_store::hdel(std::string_view key, std::string_view field)
{
    auto it = m_hashes.find(key);
    if (it == m_hashes.end())
        return false;

    auto fit = it->second.find(field);
    if (fit == it->second.end())
        return false;

    track_sub(fit->first.size() + fit->second.size());
    it->second.erase(fit);

    if (it->second.empty())
    {
        track_sub(key.size());
        m_hashes.erase(it);
        m_expiry.erase(std::string(key));
        m_lru_map.erase(std::string(key));
    }
    return true;
}

int cache_store::hlen(std::string_view key) const
{
    auto it = m_hashes.find(key);
    if (it == m_hashes.end())
        return 0;
    return static_cast<int>(it->second.size());
}

const hash_inner* cache_store::hash_ptr(std::string_view key) const
{
    auto it = m_hashes.find(key);
    if (it == m_hashes.end())
        return nullptr;
    return &it->second;
}

// ─── TTL / Expiry ───

bool cache_store::set_expiry(std::string_view key, int seconds)
{
    if (!exists(key))
        return false;

    auto tp = std::chrono::steady_clock::now() + std::chrono::seconds(seconds);
    auto it = m_expiry.find(key);
    if (it != m_expiry.end())
        it->second = tp;
    else
        m_expiry.emplace(std::string(key), tp);
    return true;
}

int cache_store::get_ttl(std::string_view key) const
{
    if (!exists(key))
        return -2;

    auto it = m_expiry.find(key);
    if (it == m_expiry.end())
        return -1;

    auto remaining = std::chrono::duration_cast<std::chrono::seconds>(
        it->second - std::chrono::steady_clock::now());
    return static_cast<int>(remaining.count());
}

bool cache_store::persist(std::string_view key)
{
    auto it = m_expiry.find(key);
    if (it == m_expiry.end())
        return false;
    m_expiry.erase(it);
    return true;
}

void cache_store::check_expiry(std::string_view key)
{
    if (m_expiry.empty())
        return;

    auto it = m_expiry.find(key);
    if (it == m_expiry.end())
        return;

    if (std::chrono::steady_clock::now() < it->second)
        return;

    // Expired — remove from all containers
    m_expiry.erase(it);
    if (auto sit = m_data.find(key); sit != m_data.end()) { m_data.erase(sit); return; }
    if (auto lit = m_lists.find(key); lit != m_lists.end()) { m_lists.erase(lit); return; }
    if (auto eit = m_sets.find(key); eit != m_sets.end()) { m_sets.erase(eit); return; }
    if (auto hit = m_hashes.find(key); hit != m_hashes.end()) { m_hashes.erase(hit); return; }
}

std::vector<std::string> cache_store::sweep_expired()
{
    std::vector<std::string> expired_names;
    if (m_expiry.empty())
        return expired_names;

    auto now = std::chrono::steady_clock::now();
    std::vector<std::string> expired;
    for (const auto& [key, tp] : m_expiry)
    {
        if (now >= tp)
            expired.push_back(key);
    }
    for (const auto& key : expired)
    {
        expired_names.push_back(key);
        del(key);
    }
    return expired_names;
}

bool cache_store::set_expiry_ms(std::string_view key, int64_t ms)
{
    if (!exists(key))
        return false;

    auto tp = std::chrono::steady_clock::now() + std::chrono::milliseconds(ms);
    auto it = m_expiry.find(key);
    if (it != m_expiry.end())
        it->second = tp;
    else
        m_expiry.emplace(std::string(key), tp);
    return true;
}

int64_t cache_store::get_pttl(std::string_view key) const
{
    if (!exists(key))
        return -2;

    auto it = m_expiry.find(key);
    if (it == m_expiry.end())
        return -1;

    auto remaining = std::chrono::duration_cast<std::chrono::milliseconds>(
        it->second - std::chrono::steady_clock::now());
    return remaining.count();
}

bool cache_store::setnx(std::string_view key, std::string_view value)
{
    check_expiry(key);
    if (exists(key))
        return false;
    return set(key, value);
}

uint64_t cache_store::scan(uint64_t cursor, std::string_view pattern,
                            size_t count, std::vector<std::string_view>& out) const
{
    bool match_all = (pattern.empty() || pattern == "*");
    auto match = [&](std::string_view k) -> bool {
        if (match_all) return true;
        return fnmatch(std::string(pattern).c_str(), std::string(k).c_str(), 0) == 0;
    };

    uint64_t pos = 0;
    auto try_add = [&](std::string_view k) -> bool {
        if (pos++ < cursor) return true;  // skip already-seen
        if (match(k)) out.push_back(k);
        return out.size() < count;        // stop when count reached
    };

    for (const auto& [k, _] : m_data)   if (!try_add(k)) return pos;
    for (const auto& [k, _] : m_lists)  if (!try_add(k)) return pos;
    for (const auto& [k, _] : m_sets)   if (!try_add(k)) return pos;
    for (const auto& [k, _] : m_hashes) if (!try_add(k)) return pos;
    return 0;  // exhausted all keys
}

bool cache_store::incr(std::string_view key, int64_t delta, int64_t& result)
{
    check_expiry(key);
    if (has_type_conflict_for_string(key))
        return false;

    int64_t val = 0;
    auto it = m_data.find(key);
    if (it != m_data.end())
    {
        auto [ptr, ec] = std::from_chars(it->second.data(), it->second.data() + it->second.size(), val);
        if (ec != std::errc{} || ptr != it->second.data() + it->second.size())
            return false;  // not an integer
    }

    val += delta;
    result = val;

    char buf[24];
    auto [end, ec2] = std::to_chars(buf, buf + sizeof(buf), val);
    std::string_view sv(buf, static_cast<size_t>(end - buf));

    if (it != m_data.end())
    {
        track_sub(it->second.size());
        it->second.assign(sv.data(), sv.size());
        track_add(it->second.size());
    }
    else
    {
        if (!check_memory(key.size() + sv.size()))
            return false;
        m_data.emplace(std::string(key), std::string(sv));
        track_add(key.size() + sv.size());
    }
    touch_lru(key);
    return true;
}

size_t cache_store::append(std::string_view key, std::string_view suffix)
{
    check_expiry(key);
    if (has_type_conflict_for_string(key))
        return std::string::npos;  // type conflict

    auto it = m_data.find(key);
    if (it != m_data.end())
    {
        if (m_max_memory > 0 && !check_memory(suffix.size()))
            return it->second.size();
        it->second.append(suffix.data(), suffix.size());
        track_add(suffix.size());
        touch_lru(key);
        return it->second.size();
    }
    else
    {
        if (!check_memory(key.size() + suffix.size()))
            return 0;
        auto& str = m_data.emplace(std::string(key), std::string(suffix)).first->second;
        track_add(key.size() + suffix.size());
        touch_lru(key);
        return str.size();
    }
}

size_t cache_store::strlen_key(std::string_view key) const
{
    auto it = m_data.find(key);
    if (it == m_data.end())
        return 0;
    return it->second.size();
}

bool cache_store::getset(std::string_view key, std::string_view newval, std::string& oldval)
{
    check_expiry(key);
    if (has_type_conflict_for_string(key))
        return false;

    auto it = m_data.find(key);
    oldval = (it != m_data.end()) ? it->second : std::string{};
    return set(key, newval);
}

std::string_view cache_store::type(std::string_view key) const
{
    if (m_data.count(key)) return "string";
    if (!m_lists.empty() && m_lists.count(key)) return "list";
    if (!m_sets.empty() && m_sets.count(key)) return "set";
    if (!m_hashes.empty() && m_hashes.count(key)) return "hash";
    return "none";
}

void cache_store::keys(std::string_view pattern, std::vector<std::string_view>& out) const
{
    bool match_all = (pattern == "*");
    auto match = [&](std::string_view key) -> bool {
        if (match_all) return true;
        // fnmatch requires null-terminated strings
        std::string key_str(key);
        std::string pat_str(pattern);
        return fnmatch(pat_str.c_str(), key_str.c_str(), 0) == 0;
    };

    for (const auto& [key, _] : m_data)
        if (match(key)) out.push_back(key);
    for (const auto& [key, _] : m_lists)
        if (match(key)) out.push_back(key);
    for (const auto& [key, _] : m_sets)
        if (match(key)) out.push_back(key);
    for (const auto& [key, _] : m_hashes)
        if (match(key)) out.push_back(key);
}

// ─── General ───

bool cache_store::del(std::string_view key)
{
    m_expiry.erase(std::string(key));

    // Remove from LRU
    if (auto lit = m_lru_map.find(std::string(key)); lit != m_lru_map.end())
    {
        m_lru_order.erase(lit->second);
        m_lru_map.erase(lit);
    }

    if (auto it = m_data.find(key); it != m_data.end())
    {
        track_sub(it->first.size() + it->second.size());
        m_data.erase(it);
        return true;
    }
    if (auto it = m_lists.find(key); it != m_lists.end())
    {
        size_t mem = it->first.size();
        for (const auto& e : it->second) mem += e.size();
        track_sub(mem);
        m_lists.erase(it);
        return true;
    }
    if (auto it = m_sets.find(key); it != m_sets.end())
    {
        size_t mem = it->first.size();
        for (const auto& e : it->second) mem += e.size();
        track_sub(mem);
        m_sets.erase(it);
        return true;
    }
    if (auto it = m_hashes.find(key); it != m_hashes.end())
    {
        size_t mem = it->first.size();
        for (const auto& [f, v] : it->second) mem += f.size() + v.size();
        track_sub(mem);
        m_hashes.erase(it);
        return true;
    }
    return false;
}

uint32_t cache_store::size() const
{
    return static_cast<uint32_t>(m_data.size() + m_lists.size() + m_sets.size() + m_hashes.size());
}

bool cache_store::exists(std::string_view key) const
{
    if (m_data.count(key)) return true;
    if (!m_lists.empty() && m_lists.count(key)) return true;
    if (!m_sets.empty() && m_sets.count(key)) return true;
    if (!m_hashes.empty() && m_hashes.count(key)) return true;
    return false;
}

// ─── Persistence ───

static constexpr char MAGIC_V2[4] = {'S', 'K', 'V', '2'};

enum : uint8_t { TYPE_STRING = 0, TYPE_LIST = 1, TYPE_SET = 2, TYPE_HASH = 3 };

bool cache_store::save(std::string_view path) const
{
    return save_v2(path);
}

bool cache_store::save_v2(std::string_view path) const
{
    std::string tmp_path = std::string(path) + ".tmp";
    std::ofstream file(tmp_path, std::ios::binary | std::ios::trunc);
    if (!file)
        return false;

    auto now = std::chrono::steady_clock::now();

    file.write(MAGIC_V2, 4);

    auto write_key = [&](uint8_t type, std::string_view key) {
        file.write(reinterpret_cast<const char*>(&type), 1);
        uint32_t klen = static_cast<uint32_t>(key.size());
        file.write(reinterpret_cast<const char*>(&klen), sizeof(klen));
        file.write(key.data(), klen);
    };

    auto write_string = [&](std::string_view s) {
        uint32_t len = static_cast<uint32_t>(s.size());
        file.write(reinterpret_cast<const char*>(&len), sizeof(len));
        file.write(s.data(), len);
    };

    auto write_expiry = [&](std::string_view key) {
        auto eit = m_expiry.find(key);
        if (eit == m_expiry.end())
        {
            uint8_t has = 0;
            file.write(reinterpret_cast<const char*>(&has), 1);
        }
        else
        {
            uint8_t has = 1;
            file.write(reinterpret_cast<const char*>(&has), 1);
            int64_t remaining_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                eit->second - now).count();
            if (remaining_ms < 0) remaining_ms = 0;
            file.write(reinterpret_cast<const char*>(&remaining_ms), sizeof(remaining_ms));
        }
    };

    // Strings
    for (const auto& [key, value] : m_data)
    {
        write_key(TYPE_STRING, key);
        write_string(value);
        write_expiry(key);
    }

    // Lists
    for (const auto& [key, deq] : m_lists)
    {
        write_key(TYPE_LIST, key);
        uint32_t count = static_cast<uint32_t>(deq.size());
        file.write(reinterpret_cast<const char*>(&count), sizeof(count));
        for (const auto& elem : deq)
            write_string(elem);
        write_expiry(key);
    }

    // Sets
    for (const auto& [key, s] : m_sets)
    {
        write_key(TYPE_SET, key);
        uint32_t count = static_cast<uint32_t>(s.size());
        file.write(reinterpret_cast<const char*>(&count), sizeof(count));
        for (const auto& member : s)
            write_string(member);
        write_expiry(key);
    }

    // Hashes
    for (const auto& [key, h] : m_hashes)
    {
        write_key(TYPE_HASH, key);
        uint32_t count = static_cast<uint32_t>(h.size());
        file.write(reinterpret_cast<const char*>(&count), sizeof(count));
        for (const auto& [field, val] : h)
        {
            write_string(field);
            write_string(val);
        }
        write_expiry(key);
    }

    if (!file.good())
        return false;

    file.flush();
    file.close();

    // fsync then atomic rename
    int fd_raw = open(tmp_path.c_str(), O_RDONLY);
    if (fd_raw >= 0)
    {
        fsync(fd_raw);
        close(fd_raw);
    }

    return rename(tmp_path.c_str(), std::string(path).c_str()) == 0;
}

bool cache_store::load(std::string_view path)
{
    std::ifstream file(std::string(path), std::ios::binary);
    if (!file)
        return false;

    // Read first 4 bytes to detect format
    char header[4]{};
    file.read(header, 4);
    if (!file)
        return false;

    if (std::memcmp(header, MAGIC_V2, 4) == 0)
        return load_v2(file);

    // v1 format: first 4 bytes were key_len
    uint32_t first_key_len;
    std::memcpy(&first_key_len, header, sizeof(first_key_len));
    return load_v1(file, first_key_len);
}

bool cache_store::load_v2(std::ifstream& file)
{
    m_data.clear();
    m_lists.clear();
    m_sets.clear();
    m_hashes.clear();
    m_expiry.clear();
    m_current_memory = 0;
    m_lru_order.clear();
    m_lru_map.clear();

    auto now = std::chrono::steady_clock::now();

    auto read_string = [&](std::string& out) -> bool {
        uint32_t len = 0;
        file.read(reinterpret_cast<char*>(&len), sizeof(len));
        if (!file) return false;
        out.resize(len);
        file.read(out.data(), len);
        return file.good() || file.eof();
    };

    auto read_expiry = [&](const std::string& key) {
        uint8_t has = 0;
        file.read(reinterpret_cast<char*>(&has), 1);
        if (has)
        {
            int64_t remaining_ms = 0;
            file.read(reinterpret_cast<char*>(&remaining_ms), sizeof(remaining_ms));
            if (remaining_ms > 0)
                m_expiry[key] = now + std::chrono::milliseconds(remaining_ms);
            // If remaining_ms <= 0, key is already expired — don't restore
        }
    };

    while (file)
    {
        uint8_t type = 0;
        file.read(reinterpret_cast<char*>(&type), 1);
        if (!file) break;

        std::string key;
        if (!read_string(key)) break;

        bool expired = false;

        switch (type)
        {
            case TYPE_STRING:
            {
                std::string value;
                if (!read_string(value)) return false;
                // Read expiry first to check if expired
                uint8_t has = 0;
                file.read(reinterpret_cast<char*>(&has), 1);
                if (has)
                {
                    int64_t remaining_ms = 0;
                    file.read(reinterpret_cast<char*>(&remaining_ms), sizeof(remaining_ms));
                    if (remaining_ms > 0)
                        m_expiry[key] = now + std::chrono::milliseconds(remaining_ms);
                    else
                        expired = true;
                }
                if (!expired)
                    m_data[std::move(key)] = std::move(value);
                break;
            }
            case TYPE_LIST:
            {
                uint32_t count = 0;
                file.read(reinterpret_cast<char*>(&count), sizeof(count));
                if (!file) return false;
                std::deque<std::string> deq;
                for (uint32_t i = 0; i < count; i++)
                {
                    std::string elem;
                    if (!read_string(elem)) return false;
                    deq.push_back(std::move(elem));
                }
                read_expiry(key);
                if (!m_expiry.count(key) || m_expiry[key] > now)
                    m_lists[std::move(key)] = std::move(deq);
                break;
            }
            case TYPE_SET:
            {
                uint32_t count = 0;
                file.read(reinterpret_cast<char*>(&count), sizeof(count));
                if (!file) return false;
                set_inner s;
                for (uint32_t i = 0; i < count; i++)
                {
                    std::string member;
                    if (!read_string(member)) return false;
                    s.insert(std::move(member));
                }
                read_expiry(key);
                if (!m_expiry.count(key) || m_expiry[key] > now)
                    m_sets[std::move(key)] = std::move(s);
                break;
            }
            case TYPE_HASH:
            {
                uint32_t count = 0;
                file.read(reinterpret_cast<char*>(&count), sizeof(count));
                if (!file) return false;
                hash_inner h;
                for (uint32_t i = 0; i < count; i++)
                {
                    std::string field, val;
                    if (!read_string(field)) return false;
                    if (!read_string(val)) return false;
                    h[std::move(field)] = std::move(val);
                }
                read_expiry(key);
                if (!m_expiry.count(key) || m_expiry[key] > now)
                    m_hashes[std::move(key)] = std::move(h);
                break;
            }
            default:
                return false;
        }
    }

    return true;
}

bool cache_store::load_v1(std::ifstream& file, uint32_t first_key_len)
{
    m_data.clear();
    m_lists.clear();
    m_sets.clear();
    m_hashes.clear();
    m_expiry.clear();
    m_current_memory = 0;
    m_lru_order.clear();
    m_lru_map.clear();

    // Process the first entry (key_len already read)
    uint32_t key_len = first_key_len;

    while (true)
    {
        std::string key(key_len, '\0');
        file.read(key.data(), key_len);
        if (!file) break;

        uint32_t val_len = 0;
        file.read(reinterpret_cast<char*>(&val_len), sizeof(val_len));
        if (!file) break;

        std::string value(val_len, '\0');
        file.read(value.data(), val_len);
        if (!file) break;

        m_current_memory += key.size() + value.size();
        m_data[std::move(key)] = std::move(value);

        // Try reading next key_len
        file.read(reinterpret_cast<char*>(&key_len), sizeof(key_len));
        if (!file) break;
    }

    return true;
}

// ─── Eviction / Memory ───

void cache_store::set_max_memory(size_t bytes)
{
    m_max_memory = bytes;
}

void cache_store::set_eviction(eviction_policy policy)
{
    m_eviction = policy;
}

void cache_store::track_add(size_t bytes)
{
    m_current_memory += bytes;
}

void cache_store::track_sub(size_t bytes)
{
    if (bytes > m_current_memory)
        m_current_memory = 0;
    else
        m_current_memory -= bytes;
}

void cache_store::touch_lru(std::string_view key)
{
    if (m_max_memory == 0)
        return;  // No memory limit, skip LRU tracking

    std::string k(key);
    auto it = m_lru_map.find(k);
    if (it != m_lru_map.end())
    {
        m_lru_order.erase(it->second);
        m_lru_order.push_back(k);
        it->second = std::prev(m_lru_order.end());
    }
    else
    {
        m_lru_order.push_back(k);
        m_lru_map[k] = std::prev(m_lru_order.end());
    }
}

bool cache_store::try_evict(size_t needed)
{
    if (m_eviction == evict_none)
        return false;

    while (m_current_memory + needed > m_max_memory && !m_lru_order.empty())
    {
        if (m_eviction == evict_allkeys_lru)
        {
            // Evict least recently used (front of list)
            std::string victim = m_lru_order.front();
            m_lru_order.pop_front();
            m_lru_map.erase(victim);
            m_expiry.erase(victim);

            // Delete from whichever container holds it
            if (auto it = m_data.find(victim); it != m_data.end())
            {
                track_sub(it->first.size() + it->second.size());
                m_data.erase(it);
            }
            else if (auto it = m_lists.find(victim); it != m_lists.end())
            {
                size_t mem = it->first.size();
                for (const auto& e : it->second) mem += e.size();
                track_sub(mem);
                m_lists.erase(it);
            }
            else if (auto it = m_sets.find(victim); it != m_sets.end())
            {
                size_t mem = it->first.size();
                for (const auto& e : it->second) mem += e.size();
                track_sub(mem);
                m_sets.erase(it);
            }
            else if (auto it = m_hashes.find(victim); it != m_hashes.end())
            {
                size_t mem = it->first.size();
                for (const auto& [f, v] : it->second) mem += f.size() + v.size();
                track_sub(mem);
                m_hashes.erase(it);
            }
        }
        else // evict_allkeys_random
        {
            // Pick a random key from LRU order
            static thread_local std::mt19937 rng(std::random_device{}());
            auto dist = std::uniform_int_distribution<size_t>(0, m_lru_order.size() - 1);
            auto it = m_lru_order.begin();
            std::advance(it, dist(rng));
            std::string victim = *it;
            m_lru_order.erase(it);
            m_lru_map.erase(victim);
            m_expiry.erase(victim);

            if (auto dit = m_data.find(victim); dit != m_data.end())
            {
                track_sub(dit->first.size() + dit->second.size());
                m_data.erase(dit);
            }
            else if (auto lit = m_lists.find(victim); lit != m_lists.end())
            {
                size_t mem = lit->first.size();
                for (const auto& e : lit->second) mem += e.size();
                track_sub(mem);
                m_lists.erase(lit);
            }
            else if (auto sit = m_sets.find(victim); sit != m_sets.end())
            {
                size_t mem = sit->first.size();
                for (const auto& e : sit->second) mem += e.size();
                track_sub(mem);
                m_sets.erase(sit);
            }
            else if (auto hit = m_hashes.find(victim); hit != m_hashes.end())
            {
                size_t mem = hit->first.size();
                for (const auto& [f, v] : hit->second) mem += f.size() + v.size();
                track_sub(mem);
                m_hashes.erase(hit);
            }
        }
    }

    return m_current_memory + needed <= m_max_memory;
}

bool cache_store::check_memory(size_t needed)
{
    if (m_max_memory == 0)
        return true;  // No limit

    if (m_current_memory + needed <= m_max_memory)
        return true;

    return try_evict(needed);
}

// ─── Pub/Sub ───

void cache_store::subscribe(int fd, std::string_view channel)
{
    m_channels[std::string(channel)].insert(fd);
}

void cache_store::unsubscribe(int fd, std::string_view channel)
{
    auto it = m_channels.find(channel);
    if (it != m_channels.end())
    {
        it->second.erase(fd);
        if (it->second.empty())
            m_channels.erase(it);
    }
}

void cache_store::unsubscribe_all(int fd)
{
    for (auto it = m_channels.begin(); it != m_channels.end(); )
    {
        it->second.erase(fd);
        if (it->second.empty())
            it = m_channels.erase(it);
        else
            ++it;
    }
}

const std::unordered_set<int>* cache_store::get_subscribers(std::string_view channel) const
{
    auto it = m_channels.find(channel);
    if (it == m_channels.end())
        return nullptr;
    return &it->second;
}

// ── socketley/shared/state_persistence.cpp ──




// ─── Minimal JSON helpers ───

namespace sp_detail {

std::string json_escape(std::string_view s)
{
    std::string out;
    out.reserve(s.size() + 4);
    for (char c : s)
    {
        switch (c)
        {
            case '"':  out += "\\\""; break;
            case '\\': out += "\\\\"; break;
            case '\n': out += "\\n";  break;
            case '\r': out += "\\r";  break;
            case '\t': out += "\\t";  break;
            default:   out += c;      break;
        }
    }
    return out;
}

std::string json_unescape(std::string_view s)
{
    std::string out;
    out.reserve(s.size());
    for (size_t i = 0; i < s.size(); ++i)
    {
        if (s[i] == '\\' && i + 1 < s.size())
        {
            ++i;
            switch (s[i])
            {
                case '"':  out += '"';  break;
                case '\\': out += '\\'; break;
                case 'n':  out += '\n'; break;
                case 'r':  out += '\r'; break;
                case 't':  out += '\t'; break;
                default:   out += '\\'; out += s[i]; break;
            }
        }
        else
        {
            out += s[i];
        }
    }
    return out;
}

const char* type_str(runtime_type t)
{
    switch (t)
    {
        case runtime_server: return "server";
        case runtime_client: return "client";
        case runtime_proxy:  return "proxy";
        case runtime_cache:  return "cache";
        default:             return "unknown";
    }
}

runtime_type str_to_type(std::string_view s)
{
    switch (fnv1a(s))
    {
        case fnv1a("server"): return runtime_server;
        case fnv1a("client"): return runtime_client;
        case fnv1a("proxy"):  return runtime_proxy;
        case fnv1a("cache"):  return runtime_cache;
        default:              return runtime_server;
    }
}

const char* server_mode_str(uint8_t m)
{
    switch (m)
    {
        case 0: return "inout";
        case 1: return "in";
        case 2: return "out";
        case 3: return "master";
        default: return "inout";
    }
}

uint8_t str_to_server_mode(std::string_view s)
{
    switch (fnv1a(s))
    {
        case fnv1a("in"):     return 1;
        case fnv1a("out"):    return 2;
        case fnv1a("master"): return 3;
        default:              return 0;
    }
}

const char* proxy_protocol_str(uint8_t p)
{
    return p == 1 ? "tcp" : "http";
}

uint8_t str_to_proxy_protocol(std::string_view s)
{
    return fnv1a(s) == fnv1a("tcp") ? 1 : 0;
}

const char* proxy_strategy_str(uint8_t s)
{
    switch (s)
    {
        case 1: return "random";
        case 2: return "lua";
        default: return "round-robin";
    }
}

uint8_t str_to_proxy_strategy(std::string_view s)
{
    switch (fnv1a(s))
    {
        case fnv1a("random"): return 1;
        case fnv1a("lua"):    return 2;
        default:              return 0;
    }
}

const char* cache_mode_str(uint8_t m)
{
    switch (m)
    {
        case 0: return "readonly";
        case 2: return "admin";
        default: return "readwrite";
    }
}

uint8_t str_to_cache_mode(std::string_view s)
{
    switch (fnv1a(s))
    {
        case fnv1a("readonly"): return 0;
        case fnv1a("admin"):    return 2;
        default:                return 1;
    }
}

const char* eviction_str(uint8_t e)
{
    switch (e)
    {
        case 1: return "allkeys-lru";
        case 2: return "allkeys-random";
        default: return "noeviction";
    }
}

uint8_t str_to_eviction(std::string_view s)
{
    switch (fnv1a(s))
    {
        case fnv1a("allkeys-lru"):    return 1;
        case fnv1a("allkeys-random"): return 2;
        default:                      return 0;
    }
}

// Simple JSON value parser: extract string value for a key from JSON text
std::string json_get_string(const std::string& json, const std::string& key)
{
    std::string needle = "\"" + key + "\"";
    size_t pos = json.find(needle);
    if (pos == std::string::npos) return {};

    pos = json.find(':', pos + needle.size());
    if (pos == std::string::npos) return {};

    // Skip whitespace
    pos = json.find_first_not_of(" \t\n\r", pos + 1);
    if (pos == std::string::npos) return {};

    if (json[pos] == '"')
    {
        ++pos;
        std::string result;
        while (pos < json.size() && json[pos] != '"')
        {
            if (json[pos] == '\\' && pos + 1 < json.size())
            {
                result += json[pos];
                result += json[pos + 1];
                pos += 2;
            }
            else
            {
                result += json[pos];
                ++pos;
            }
        }
        return json_unescape(result);
    }

    // Not a string — extract until comma, ], or }
    size_t end = json.find_first_of(",]}", pos);
    if (end == std::string::npos) end = json.size();
    std::string val = json.substr(pos, end - pos);
    // Trim whitespace
    while (!val.empty() && (val.back() == ' ' || val.back() == '\n' || val.back() == '\r' || val.back() == '\t'))
        val.pop_back();
    return val;
}

bool json_get_bool(const std::string& json, const std::string& key, bool default_val = false)
{
    std::string v = json_get_string(json, key);
    if (v == "true")  return true;
    if (v == "false") return false;
    return default_val;
}

int json_get_int(const std::string& json, const std::string& key, int default_val = 0)
{
    std::string v = json_get_string(json, key);
    if (v.empty()) return default_val;
    try { return std::stoi(v); } catch (...) { return default_val; }
}

uint32_t json_get_uint32(const std::string& json, const std::string& key, uint32_t default_val = 0)
{
    std::string v = json_get_string(json, key);
    if (v.empty()) return default_val;
    try { return static_cast<uint32_t>(std::stoul(v)); } catch (...) { return default_val; }
}

double json_get_double(const std::string& json, const std::string& key, double default_val = 0.0)
{
    std::string v = json_get_string(json, key);
    if (v.empty()) return default_val;
    try { return std::stod(v); } catch (...) { return default_val; }
}

size_t json_get_size(const std::string& json, const std::string& key, size_t default_val = 0)
{
    std::string v = json_get_string(json, key);
    if (v.empty()) return default_val;
    try { return static_cast<size_t>(std::stoull(v)); } catch (...) { return default_val; }
}

std::vector<std::string> json_get_array(const std::string& json, const std::string& key)
{
    std::vector<std::string> result;
    std::string needle = "\"" + key + "\"";
    size_t pos = json.find(needle);
    if (pos == std::string::npos) return result;

    pos = json.find('[', pos + needle.size());
    if (pos == std::string::npos) return result;
    ++pos;

    size_t end = json.find(']', pos);
    if (end == std::string::npos) return result;

    std::string arr = json.substr(pos, end - pos);
    size_t i = 0;
    while (i < arr.size())
    {
        i = arr.find('"', i);
        if (i == std::string::npos) break;
        ++i;
        std::string val;
        while (i < arr.size() && arr[i] != '"')
        {
            if (arr[i] == '\\' && i + 1 < arr.size())
            {
                val += arr[i];
                val += arr[i + 1];
                i += 2;
            }
            else
            {
                val += arr[i];
                ++i;
            }
        }
        if (i < arr.size()) ++i; // skip closing quote
        result.push_back(json_unescape(val));
    }

    return result;
}

std::string resolve_absolute(std::string_view path)
{
    if (path.empty()) return {};
    std::error_code ec;
    auto canonical = fs::canonical(fs::path(path), ec);
    if (!ec)
        return canonical.string();
    // File doesn't exist yet — use absolute instead
    return fs::absolute(fs::path(path)).string();
}

} // namespace sp_detail

// ─── state_persistence ───

state_persistence::state_persistence(const fs::path& state_dir)
    : m_state_dir(state_dir)
{
}

fs::path state_persistence::config_path(std::string_view name) const
{
    // Reject path traversal characters in name
    for (char c : name)
    {
        if (c == '/' || c == '\\' || c == '\0')
            return m_state_dir / "invalid.json";
    }
    if (name.find("..") != std::string_view::npos)
        return m_state_dir / "invalid.json";

    return m_state_dir / (std::string(name) + ".json");
}

runtime_config state_persistence::read_from_instance(const runtime_instance* instance) const
{
    using namespace sp_detail;
    runtime_config cfg;
    cfg.name = instance->get_name();
    cfg.id = instance->get_id();
    cfg.type = instance->get_type();
    cfg.port = instance->get_port();
    cfg.was_running = (instance->get_state() == runtime_running);

    // Common
    cfg.log_file = instance->get_log_file();
    cfg.write_file = instance->get_write_file();
    cfg.lua_script = resolve_absolute(instance->get_lua_script_path());
    cfg.bash_output = instance->get_bash_output();
    cfg.bash_prefix = instance->get_bash_prefix();
    cfg.bash_timestamp = instance->get_bash_timestamp();
    cfg.max_connections = instance->get_max_connections();
    cfg.rate_limit = instance->get_rate_limit();
    cfg.global_rate_limit = instance->get_global_rate_limit();
    cfg.idle_timeout = instance->get_idle_timeout();
    cfg.drain = instance->get_drain();
    cfg.reconnect = instance->get_reconnect();
    cfg.tls = instance->get_tls();
    cfg.cert_path = instance->get_cert_path();
    cfg.key_path = instance->get_key_path();
    cfg.ca_path = instance->get_ca_path();
    cfg.target = instance->get_target();
    cfg.cache_name = instance->get_cache_name();
    cfg.group = instance->get_group();
    cfg.owner = instance->get_owner();
    cfg.child_policy = (instance->get_child_policy() == runtime_instance::child_policy::remove) ? 1 : 0;
    cfg.external_runtime = instance->is_external();
    if (cfg.external_runtime)
    {
        cfg.was_running = false;  // prevent daemon from trying to re-bind on restart
        cfg.pid = static_cast<int32_t>(instance->get_pid());
    }

    // Type-specific
    switch (cfg.type)
    {
        case runtime_server:
        {
            auto* srv = static_cast<const server_instance*>(instance);
            cfg.mode = static_cast<uint8_t>(srv->get_mode());
            cfg.udp = srv->is_udp();
            cfg.master_pw = std::string(srv->get_master_pw());
            cfg.master_forward = srv->get_master_forward();
            cfg.http_dir = srv->get_http_dir().string();
            cfg.http_cache = srv->get_http_cache();
            break;
        }
        case runtime_client:
        {
            auto* cli = static_cast<const client_instance*>(instance);
            cfg.mode = static_cast<uint8_t>(cli->get_mode());
            cfg.udp = cli->is_udp();
            break;
        }
        case runtime_proxy:
        {
            auto* prx = static_cast<const proxy_instance*>(instance);
            cfg.protocol = static_cast<uint8_t>(prx->get_protocol());
            cfg.strategy = static_cast<uint8_t>(prx->get_strategy());
            for (const auto& b : prx->get_backends())
                cfg.backends.push_back(b.address);
            break;
        }
        case runtime_cache:
        {
            auto* cache = static_cast<const cache_instance*>(instance);
            cfg.persistent_path = cache->get_persistent();
            cfg.cache_mode = static_cast<uint8_t>(cache->get_mode());
            cfg.resp_forced = cache->get_resp_forced();
            cfg.replicate_target = cache->get_replicate_target();
            cfg.max_memory = cache->get_max_memory();
            cfg.eviction = static_cast<uint8_t>(cache->get_eviction());
            break;
        }
    }

    return cfg;
}

std::string state_persistence::format_json_pretty(const runtime_config& cfg) const
{
    using namespace sp_detail;
    std::ostringstream out;
    out << "{\n";
    out << "    \"name\": \"" << json_escape(cfg.name) << "\",\n";
    out << "    \"id\": \"" << json_escape(cfg.id) << "\",\n";
    out << "    \"type\": \"" << type_str(cfg.type) << "\",\n";
    out << "    \"port\": " << cfg.port << ",\n";
    out << "    \"was_running\": " << (cfg.was_running ? "true" : "false") << ",\n";

    // Common fields (only write non-default)
    if (!cfg.log_file.empty())
        out << "    \"log_file\": \"" << json_escape(cfg.log_file) << "\",\n";
    if (!cfg.write_file.empty())
        out << "    \"write_file\": \"" << json_escape(cfg.write_file) << "\",\n";
    if (!cfg.lua_script.empty())
        out << "    \"lua_script\": \"" << json_escape(cfg.lua_script) << "\",\n";
    if (cfg.bash_output)
        out << "    \"bash_output\": true,\n";
    if (cfg.bash_prefix)
        out << "    \"bash_prefix\": true,\n";
    if (cfg.bash_timestamp)
        out << "    \"bash_timestamp\": true,\n";
    if (cfg.max_connections > 0)
        out << "    \"max_connections\": " << cfg.max_connections << ",\n";
    if (cfg.rate_limit > 0.0)
        out << "    \"rate_limit\": " << cfg.rate_limit << ",\n";
    if (cfg.global_rate_limit > 0.0)
        out << "    \"global_rate_limit\": " << cfg.global_rate_limit << ",\n";
    if (cfg.idle_timeout > 0)
        out << "    \"idle_timeout\": " << cfg.idle_timeout << ",\n";
    if (cfg.drain)
        out << "    \"drain\": true,\n";
    if (cfg.reconnect >= 0)
        out << "    \"reconnect\": " << cfg.reconnect << ",\n";
    if (cfg.tls)
        out << "    \"tls\": true,\n";
    if (!cfg.cert_path.empty())
        out << "    \"cert_path\": \"" << json_escape(cfg.cert_path) << "\",\n";
    if (!cfg.key_path.empty())
        out << "    \"key_path\": \"" << json_escape(cfg.key_path) << "\",\n";
    if (!cfg.ca_path.empty())
        out << "    \"ca_path\": \"" << json_escape(cfg.ca_path) << "\",\n";
    if (!cfg.target.empty())
        out << "    \"target\": \"" << json_escape(cfg.target) << "\",\n";
    if (!cfg.cache_name.empty())
        out << "    \"cache_name\": \"" << json_escape(cfg.cache_name) << "\",\n";
    if (!cfg.group.empty())
        out << "    \"group\": \"" << json_escape(cfg.group) << "\",\n";
    if (!cfg.owner.empty())
        out << "    \"owner\": \"" << json_escape(cfg.owner) << "\",\n";
    if (cfg.child_policy != 0)
        out << "    \"child_policy\": " << cfg.child_policy << ",\n";
    if (cfg.external_runtime)
    {
        out << "    \"external_runtime\": true,\n";
        if (cfg.pid > 0)
            out << "    \"pid\": " << cfg.pid << ",\n";
    }

    // Type-specific
    switch (cfg.type)
    {
        case runtime_server:
            out << "    \"mode\": \"" << server_mode_str(cfg.mode) << "\",\n";
            if (cfg.udp)
                out << "    \"udp\": true,\n";
            if (!cfg.master_pw.empty())
                out << "    \"master_pw\": \"" << json_escape(cfg.master_pw) << "\",\n";
            if (cfg.master_forward)
                out << "    \"master_forward\": true,\n";
            if (!cfg.http_dir.empty())
                out << "    \"http_dir\": \"" << json_escape(cfg.http_dir) << "\",\n";
            if (cfg.http_cache)
                out << "    \"http_cache\": true,\n";
            break;
        case runtime_client:
            out << "    \"mode\": \"" << server_mode_str(cfg.mode) << "\",\n";
            if (cfg.udp)
                out << "    \"udp\": true,\n";
            break;
        case runtime_proxy:
            out << "    \"protocol\": \"" << proxy_protocol_str(cfg.protocol) << "\",\n";
            out << "    \"strategy\": \"" << proxy_strategy_str(cfg.strategy) << "\",\n";
            if (!cfg.backends.empty())
            {
                out << "    \"backends\": [";
                for (size_t i = 0; i < cfg.backends.size(); ++i)
                {
                    if (i > 0) out << ", ";
                    out << "\"" << json_escape(cfg.backends[i]) << "\"";
                }
                out << "],\n";
            }
            break;
        case runtime_cache:
            if (!cfg.persistent_path.empty())
                out << "    \"persistent_path\": \"" << json_escape(cfg.persistent_path) << "\",\n";
            out << "    \"cache_mode\": \"" << cache_mode_str(cfg.cache_mode) << "\",\n";
            if (cfg.resp_forced)
                out << "    \"resp_forced\": true,\n";
            if (!cfg.replicate_target.empty())
                out << "    \"replicate_target\": \"" << json_escape(cfg.replicate_target) << "\",\n";
            if (cfg.max_memory > 0)
                out << "    \"max_memory\": " << cfg.max_memory << ",\n";
            out << "    \"eviction\": \"" << eviction_str(cfg.eviction) << "\",\n";
            break;
    }

    // Remove trailing comma+newline and close
    std::string json = out.str();
    if (json.size() >= 2 && json[json.size()-2] == ',' && json[json.size()-1] == '\n')
    {
        json[json.size()-2] = '\n';
        json.pop_back();
    }
    json += "}\n";

    return json;
}

bool state_persistence::parse_json_string(const std::string& json, runtime_config& cfg) const
{
    using namespace sp_detail;
    cfg.name = json_get_string(json, "name");
    cfg.id = json_get_string(json, "id");
    cfg.type = str_to_type(json_get_string(json, "type"));
    cfg.port = static_cast<uint16_t>(json_get_int(json, "port"));
    cfg.was_running = json_get_bool(json, "was_running");

    // Common
    cfg.log_file = json_get_string(json, "log_file");
    cfg.write_file = json_get_string(json, "write_file");
    cfg.lua_script = json_get_string(json, "lua_script");
    cfg.bash_output = json_get_bool(json, "bash_output");
    cfg.bash_prefix = json_get_bool(json, "bash_prefix");
    cfg.bash_timestamp = json_get_bool(json, "bash_timestamp");
    cfg.max_connections = json_get_uint32(json, "max_connections");
    cfg.rate_limit = json_get_double(json, "rate_limit");
    cfg.global_rate_limit = json_get_double(json, "global_rate_limit");
    cfg.idle_timeout = json_get_uint32(json, "idle_timeout");
    cfg.drain = json_get_bool(json, "drain");
    cfg.reconnect = json_get_int(json, "reconnect", -1);
    cfg.tls = json_get_bool(json, "tls");
    cfg.cert_path = json_get_string(json, "cert_path");
    cfg.key_path = json_get_string(json, "key_path");
    cfg.ca_path = json_get_string(json, "ca_path");
    cfg.target = json_get_string(json, "target");
    cfg.cache_name = json_get_string(json, "cache_name");
    cfg.group = json_get_string(json, "group");
    cfg.owner = json_get_string(json, "owner");
    cfg.child_policy = json_get_int(json, "child_policy");
    cfg.external_runtime = json_get_bool(json, "external_runtime");
    cfg.pid = static_cast<int32_t>(json_get_int(json, "pid"));

    // Type-specific
    switch (cfg.type)
    {
        case runtime_server:
            cfg.mode = str_to_server_mode(json_get_string(json, "mode"));
            cfg.udp = json_get_bool(json, "udp");
            cfg.master_pw = json_get_string(json, "master_pw");
            cfg.master_forward = json_get_bool(json, "master_forward");
            cfg.http_dir = json_get_string(json, "http_dir");
            cfg.http_cache = json_get_bool(json, "http_cache");
            break;
        case runtime_client:
            cfg.mode = str_to_server_mode(json_get_string(json, "mode"));
            cfg.udp = json_get_bool(json, "udp");
            break;
        case runtime_proxy:
            cfg.protocol = str_to_proxy_protocol(json_get_string(json, "protocol"));
            cfg.strategy = str_to_proxy_strategy(json_get_string(json, "strategy"));
            cfg.backends = json_get_array(json, "backends");
            break;
        case runtime_cache:
            cfg.persistent_path = json_get_string(json, "persistent_path");
            cfg.cache_mode = str_to_cache_mode(json_get_string(json, "cache_mode"));
            cfg.resp_forced = json_get_bool(json, "resp_forced");
            cfg.replicate_target = json_get_string(json, "replicate_target");
            cfg.max_memory = json_get_size(json, "max_memory");
            cfg.eviction = str_to_eviction(json_get_string(json, "eviction"));
            break;
    }

    return !cfg.name.empty();
}

bool state_persistence::write_json(const runtime_config& cfg) const
{
    std::string json = format_json_pretty(cfg);

    // Atomic write: write to .tmp then rename
    fs::path path = config_path(cfg.name);
    fs::path tmp_path = path;
    tmp_path += ".tmp";

    std::ofstream f(tmp_path, std::ios::trunc);
    if (!f.is_open())
        return false;

    f << json;
    f.close();

    if (f.fail())
    {
        fs::remove(tmp_path);
        return false;
    }

    std::error_code ec;
    fs::rename(tmp_path, path, ec);
    return !ec;
}

bool state_persistence::read_json(const fs::path& path, runtime_config& cfg) const
{
    std::ifstream f(path);
    if (!f.is_open())
        return false;

    std::ostringstream ss;
    ss << f.rdbuf();
    return parse_json_string(ss.str(), cfg);
}

void state_persistence::save_runtime(const runtime_instance* instance)
{
    if (instance->is_lua_created())
        return;
    runtime_config cfg = read_from_instance(instance);
    write_json(cfg);
}

void state_persistence::remove_runtime(std::string_view name)
{
    fs::remove(config_path(name));
}

void state_persistence::set_was_running(std::string_view name, bool running)
{
    fs::path path = config_path(name);

    runtime_config cfg;
    if (!read_json(path, cfg))
        return;

    cfg.was_running = running;
    write_json(cfg);
}

std::vector<runtime_config> state_persistence::load_all()
{
    std::vector<runtime_config> configs;

    std::error_code ec;
    for (const auto& entry : fs::directory_iterator(m_state_dir, ec))
    {
        if (!entry.is_regular_file())
            continue;
        if (entry.path().extension() != ".json")
            continue;

        runtime_config cfg;
        if (read_json(entry.path(), cfg))
            configs.push_back(std::move(cfg));
    }

    return configs;
}

// ── socketley/shared/cluster_discovery.cpp ──




// ─── Minimal JSON helpers (local to this TU) ───

namespace cd_detail {

std::string json_escape(std::string_view s)
{
    std::string out;
    out.reserve(s.size() + 4);
    for (char c : s)
    {
        switch (c)
        {
            case '"':  out += "\\\""; break;
            case '\\': out += "\\\\"; break;
            case '\n': out += "\\n";  break;
            default:   out += c;      break;
        }
    }
    return out;
}

// Extract a string value for a given key from a flat JSON object
// Simple parser — sufficient for our well-known format
std::string json_get_string(std::string_view json, std::string_view key)
{
    // Look for "key":"value"
    std::string needle = "\"";
    needle += key;
    needle += "\":\"";
    auto pos = json.find(needle);
    if (pos == std::string_view::npos)
        return {};

    pos += needle.size();
    auto end = json.find('"', pos);
    if (end == std::string_view::npos)
        return {};

    return std::string(json.substr(pos, end - pos));
}

// Extract a numeric value for a given key
int64_t json_get_number(std::string_view json, std::string_view key)
{
    std::string needle = "\"";
    needle += key;
    needle += "\":";
    auto pos = json.find(needle);
    if (pos == std::string_view::npos)
        return 0;

    pos += needle.size();
    // Skip whitespace
    while (pos < json.size() && (json[pos] == ' ' || json[pos] == '\t'))
        ++pos;

    int64_t val = 0;
    auto [ptr, ec] = std::from_chars(json.data() + pos,
        json.data() + json.size(), val);
    if (ec != std::errc{})
        return 0;
    return val;
}

// Parse the "runtimes" array from the JSON
// Returns vector of {start_pos, end_pos} for each object in the array
std::vector<std::string_view> json_get_array_objects(std::string_view json, std::string_view key)
{
    std::vector<std::string_view> result;

    std::string needle = "\"";
    needle += key;
    needle += "\":[";
    auto pos = json.find(needle);
    if (pos == std::string_view::npos)
        return result;

    pos += needle.size();

    while (pos < json.size())
    {
        // Skip whitespace
        while (pos < json.size() && (json[pos] == ' ' || json[pos] == '\t' ||
               json[pos] == '\n' || json[pos] == '\r' || json[pos] == ','))
            ++pos;

        if (pos >= json.size() || json[pos] == ']')
            break;

        if (json[pos] != '{')
            break;

        // Find matching closing brace (no nesting in our format)
        auto end = json.find('}', pos);
        if (end == std::string_view::npos)
            break;

        result.push_back(json.substr(pos, end - pos + 1));
        pos = end + 1;
    }

    return result;
}

const char* type_str(runtime_type t)
{
    switch (t)
    {
        case runtime_server: return "server";
        case runtime_client: return "client";
        case runtime_proxy:  return "proxy";
        case runtime_cache:  return "cache";
        default:             return "unknown";
    }
}

const char* state_str(runtime_state s)
{
    switch (s)
    {
        case runtime_created: return "created";
        case runtime_running: return "running";
        case runtime_stopped: return "stopped";
        case runtime_failed:  return "failed";
        default:              return "unknown";
    }
}

} // namespace cd_detail

// ─── cluster_discovery implementation ───

cluster_discovery::cluster_discovery(std::string_view daemon_name,
                                     std::string_view cluster_dir,
                                     runtime_manager& manager)
    : m_daemon_name(daemon_name)
    , m_cluster_dir(cluster_dir)
    , m_manager(manager)
{
    char buf[256];
    if (gethostname(buf, sizeof(buf)) == 0)
        m_cluster_addr = buf;
    else
        m_cluster_addr = daemon_name;
}

cluster_discovery::~cluster_discovery()
{
    stop();
}

bool cluster_discovery::start(event_loop& loop)
{
    using namespace cd_detail;
    m_loop = &loop;

    // Ensure cluster directory exists
    std::error_code ec;
    fs::create_directories(m_cluster_dir, ec);

    // Check for duplicate daemon name: if a file with our name already exists
    // and has a fresh heartbeat, another daemon is using this name.
    std::string our_path = m_cluster_dir + "/" + m_daemon_name + ".json";
    {
        std::ifstream f(our_path);
        if (f.is_open())
        {
            std::ostringstream ss;
            ss << f.rdbuf();
            std::string content = ss.str();

            int64_t hb = json_get_number(content, "heartbeat");
            if (hb > 0)
            {
                time_t now = std::time(nullptr);
                if ((now - static_cast<time_t>(hb)) <= STALE_THRESHOLD_SEC)
                {
                    LOG_ERROR("cluster: daemon name already in use");
                    m_loop = nullptr;
                    return false;
                }
            }
        }
    }

    // Do an initial publish + scan immediately
    publish();
    scan();

    // Start the timer cycle
    schedule_timer();
    return true;
}

void cluster_discovery::stop()
{
    m_loop = nullptr;
    unpublish();
}

void cluster_discovery::on_cqe(struct io_uring_cqe* cqe)
{
    if (!m_loop)
        return;

    // Timer fired — publish + scan, then reschedule
    publish();
    scan();
    schedule_timer();
}

void cluster_discovery::schedule_timer()
{
    if (!m_loop)
        return;

    m_timer_ts.tv_sec = PUBLISH_INTERVAL_SEC;
    m_timer_ts.tv_nsec = 0;
    m_timer_req = { op_timeout, -1, nullptr, 0, this };
    m_loop->submit_timeout(&m_timer_ts, &m_timer_req);
}

std::string cluster_discovery::build_publish_json() const
{
    using namespace cd_detail;
    std::string json;
    json.reserve(1024);

    json += "{\"daemon\":\"";
    json += json_escape(m_daemon_name);
    json += "\",\"host\":\"";
    json += json_escape(m_cluster_addr);
    json += "\",\"heartbeat\":";

    char ts_buf[24];
    auto now = static_cast<int64_t>(std::time(nullptr));
    auto [end, ec] = std::to_chars(ts_buf, ts_buf + sizeof(ts_buf), now);
    json.append(ts_buf, static_cast<size_t>(end - ts_buf));

    json += ",\"runtimes\":[";

    // Snapshot local runtimes under read lock
    bool first = true;
    {
        std::shared_lock lock(m_manager.mutex);
        const auto& runtimes = m_manager.list();
        for (const auto& [name, inst] : runtimes)
        {
            if (!first) json += ',';
            first = false;

            json += "{\"name\":\"";
            json += json_escape(name);
            json += "\",\"type\":\"";
            json += type_str(inst->get_type());
            json += "\",\"group\":\"";
            json += json_escape(inst->get_group());
            json += "\",\"port\":";

            char port_buf[8];
            auto [pend, pec] = std::to_chars(port_buf, port_buf + sizeof(port_buf),
                                              inst->get_port());
            json.append(port_buf, static_cast<size_t>(pend - port_buf));

            json += ",\"state\":\"";
            json += state_str(inst->get_state());
            json += "\",\"connections\":";

            char conn_buf[16];
            auto [cend, cec] = std::to_chars(conn_buf, conn_buf + sizeof(conn_buf),
                                              inst->get_connection_count());
            json.append(conn_buf, static_cast<size_t>(cend - conn_buf));

            json += '}';
        }
    }

    json += "]}";
    return json;
}

void cluster_discovery::publish()
{
    std::string json = build_publish_json();
    std::string path = m_cluster_dir + "/" + m_daemon_name + ".json";

    // Write atomically: write to tmp, then rename
    std::string tmp_path = path + ".tmp";
    {
        std::ofstream f(tmp_path, std::ios::trunc);
        if (!f.is_open())
        {
            LOG_WARN("cluster: could not write state file");
            return;
        }
        f << json;
    }

    if (std::rename(tmp_path.c_str(), path.c_str()) != 0)
        LOG_WARN("cluster: could not rename state file");
}

void cluster_discovery::scan()
{
    DIR* dir = opendir(m_cluster_dir.c_str());
    if (!dir)
        return;

    time_t now = std::time(nullptr);

    // Track which daemons we see in this scan (for removing stale entries)
    std::unordered_set<std::string> seen;

    struct dirent* entry;
    while ((entry = readdir(dir)) != nullptr)
    {
        std::string_view fname(entry->d_name);

        // Only process .json files
        if (fname.size() < 6 || fname.substr(fname.size() - 5) != ".json")
            continue;

        // Skip .tmp files
        if (fname.size() > 9 && fname.substr(fname.size() - 9) == ".tmp.json")
            continue;

        // Extract daemon name from filename (strip .json)
        std::string daemon_name(fname.substr(0, fname.size() - 5));

        // Skip our own file
        if (daemon_name == m_daemon_name)
            continue;

        seen.insert(daemon_name);

        // Check mtime — only re-read if file changed
        std::string full_path = m_cluster_dir + "/" + std::string(fname);
        struct stat st{};
        if (stat(full_path.c_str(), &st) != 0)
            continue;

        auto mit = m_mtime_cache.find(daemon_name);
        if (mit != m_mtime_cache.end() && mit->second == st.st_mtime)
        {
            // File unchanged — just check if the cached daemon is stale
            std::lock_guard lock(m_remote_mutex);
            auto dit = m_remote_daemons.find(daemon_name);
            if (dit != m_remote_daemons.end() &&
                (now - dit->second.heartbeat) > STALE_THRESHOLD_SEC)
            {
                m_remote_daemons.erase(dit);
            }
            continue;
        }

        // Read and parse the file
        std::ifstream f(full_path);
        if (!f.is_open())
            continue;

        std::ostringstream ss;
        ss << f.rdbuf();
        std::string content = ss.str();

        remote_daemon rd;
        if (!parse_daemon_json(content, rd))
            continue;

        // Check if stale
        if ((now - rd.heartbeat) > STALE_THRESHOLD_SEC)
        {
            std::lock_guard lock(m_remote_mutex);
            m_remote_daemons.erase(daemon_name);
            m_mtime_cache[daemon_name] = st.st_mtime;
            continue;
        }

        // Update cache
        m_mtime_cache[daemon_name] = st.st_mtime;
        {
            std::lock_guard lock(m_remote_mutex);
            m_remote_daemons[daemon_name] = std::move(rd);
        }
    }

    closedir(dir);

    // Remove entries for daemons whose files no longer exist
    {
        std::lock_guard lock(m_remote_mutex);
        for (auto it = m_remote_daemons.begin(); it != m_remote_daemons.end(); )
        {
            if (seen.find(it->first) == seen.end())
            {
                m_mtime_cache.erase(it->first);
                it = m_remote_daemons.erase(it);
            }
            else
            {
                ++it;
            }
        }
    }

    // ─── Change detection for event callbacks ───
    if (!m_event_callback)
        return;

    // Build current daemon name set and group counts under lock
    std::unordered_set<std::string> current_names;
    std::unordered_map<std::string, int> current_groups;
    {
        std::lock_guard lock(m_remote_mutex);
        for (const auto& [name, daemon] : m_remote_daemons)
        {
            current_names.insert(name);
            for (const auto& rt : daemon.runtimes)
            {
                if (!rt.group.empty() && rt.state == "running" && rt.port > 0)
                    ++current_groups[rt.group];
            }
        }
    }

    // Also count local group members
    {
        std::shared_lock lock(m_manager.mutex);
        for (const auto& [_, inst] : m_manager.list())
        {
            auto g = inst->get_group();
            if (!g.empty() && inst->get_state() == runtime_running && inst->get_port() > 0)
                ++current_groups[std::string(g)];
        }
    }

    // Diff against previous state
    std::vector<cluster_event> events;

    // New daemons = join events
    for (const auto& name : current_names)
    {
        if (m_previous_daemon_names.find(name) == m_previous_daemon_names.end())
            events.push_back({cluster_event::daemon_join, name, {}, 0});
    }

    // Missing daemons = leave events
    for (const auto& name : m_previous_daemon_names)
    {
        if (current_names.find(name) == current_names.end())
            events.push_back({cluster_event::daemon_leave, name, {}, 0});
    }

    // Changed group counts = group_change events
    for (const auto& [group, count] : current_groups)
    {
        auto it = m_previous_group_counts.find(group);
        if (it == m_previous_group_counts.end() || it->second != count)
            events.push_back({cluster_event::group_change, {}, group, count});
    }
    for (const auto& [group, _] : m_previous_group_counts)
    {
        if (current_groups.find(group) == current_groups.end())
            events.push_back({cluster_event::group_change, {}, group, 0});
    }

    // Update previous state
    m_previous_daemon_names = std::move(current_names);
    m_previous_group_counts = std::move(current_groups);

    // Fire callback
    if (!events.empty())
        m_event_callback(events);
}

void cluster_discovery::unpublish()
{
    std::string path = m_cluster_dir + "/" + m_daemon_name + ".json";
    unlink(path.c_str());
}

bool cluster_discovery::parse_daemon_json(const std::string& json, remote_daemon& out) const
{
    using namespace cd_detail;
    out.name = json_get_string(json, "daemon");
    out.host = json_get_string(json, "host");
    out.heartbeat = static_cast<time_t>(json_get_number(json, "heartbeat"));

    if (out.name.empty() || out.heartbeat == 0)
        return false;

    auto objects = json_get_array_objects(json, "runtimes");
    for (auto obj : objects)
    {
        remote_runtime rt;
        rt.daemon_name = out.name;
        rt.host = out.host;
        rt.name = json_get_string(obj, "name");
        rt.type = json_get_string(obj, "type");
        rt.group = json_get_string(obj, "group");
        rt.port = static_cast<uint16_t>(json_get_number(obj, "port"));
        rt.state = json_get_string(obj, "state");
        rt.connections = static_cast<size_t>(json_get_number(obj, "connections"));
        out.runtimes.push_back(std::move(rt));
    }

    return true;
}

std::vector<cluster_discovery::remote_endpoint>
cluster_discovery::get_remote_group(std::string_view group) const
{
    std::vector<remote_endpoint> result;

    std::lock_guard lock(m_remote_mutex);
    for (const auto& [_, daemon] : m_remote_daemons)
    {
        for (const auto& rt : daemon.runtimes)
        {
            if (rt.group == group && rt.state == "running" && rt.port > 0)
                result.push_back({rt.host, rt.port});
        }
    }

    return result;
}

void cluster_discovery::set_event_callback(event_callback_t cb)
{
    std::lock_guard lock(m_remote_mutex);
    m_event_callback = std::move(cb);
}

std::vector<remote_daemon> cluster_discovery::get_all_daemons() const
{
    std::vector<remote_daemon> result;

    std::lock_guard lock(m_remote_mutex);
    result.reserve(m_remote_daemons.size());
    for (const auto& [_, daemon] : m_remote_daemons)
        result.push_back(daemon);

    return result;
}

// ── socketley/shared/runtime_manager.cpp ──


bool runtime_manager::create(runtime_type type, std::string_view name)
{
    std::unique_lock lock(mutex);

    // Validate name: alphanumeric + -_. only, max 128 chars, no leading dot
    if (name.empty() || name.size() > 128 || name[0] == '.')
        return false;
    for (char c : name)
    {
        if (!std::isalnum(static_cast<unsigned char>(c)) && c != '-' && c != '_' && c != '.')
            return false;
    }

    if (runtimes.find(name) != runtimes.end())
        return false;

    auto instance = create_runtime(type, name);
    if (!instance)
        return false;

    runtimes.emplace(std::string(name), std::move(instance));
    return true;
}

bool runtime_manager::run(std::string_view name, event_loop& loop)
{
    std::shared_lock lock(mutex);

    auto it = runtimes.find(name);
    if (it == runtimes.end())
        return false;

    return it->second->start(loop);
}

bool runtime_manager::stop(std::string_view name, event_loop& loop)
{
    {
        std::shared_lock lock(mutex);
        auto it = runtimes.find(name);
        if (it == runtimes.end())
            return false;
        if (!it->second->stop(loop))
            return false;
    }

    // Cascade to children based on child_policy
    auto* inst = get(name);
    if (inst)
    {
        auto children = get_children(name);
        for (const auto& child : children)
        {
            auto* child_inst = get(child);
            if (!child_inst) continue;

            if (child_inst->get_child_policy() == runtime_instance::child_policy::remove)
                remove_children(child, loop);
            else
                stop_children(child, loop);

            if (child_inst->get_child_policy() == runtime_instance::child_policy::remove)
            {
                if (child_inst->get_state() == runtime_running)
                    stop(child, loop);
                remove(child);
            }
            else
            {
                if (child_inst->get_state() == runtime_running)
                    stop(child, loop);
            }
        }
    }

    return true;
}

bool runtime_manager::remove(std::string_view name)
{
    std::unique_lock lock(mutex);

    auto it = runtimes.find(name);
    if (it == runtimes.end())
        return false;

    runtimes.erase(it);
    return true;
}

std::unique_ptr<runtime_instance> runtime_manager::extract(std::string_view name)
{
    std::unique_lock lock(mutex);

    auto it = runtimes.find(name);
    if (it == runtimes.end())
        return nullptr;

    auto ptr = std::move(it->second);
    runtimes.erase(it);
    return ptr;
}

bool runtime_manager::rename(std::string_view old_name, std::string_view new_name)
{
    std::unique_lock lock(mutex);

    auto it = runtimes.find(old_name);
    if (it == runtimes.end())
        return false;

    if (runtimes.find(new_name) != runtimes.end())
        return false;

    auto instance = std::move(it->second);
    runtimes.erase(it);
    instance->set_name(new_name);
    runtimes.emplace(std::string(new_name), std::move(instance));
    return true;
}

std::vector<std::string> runtime_manager::get_children(std::string_view parent_name) const
{
    std::shared_lock lock(mutex);
    std::vector<std::string> children;
    for (const auto& [name, instance] : runtimes)
    {
        if (instance->get_owner() == parent_name)
            children.push_back(name);
    }
    return children;
}

void runtime_manager::stop_children(std::string_view parent_name, event_loop& loop)
{
    auto children = get_children(parent_name);
    for (const auto& child : children)
    {
        // Recurse: stop grandchildren first
        stop_children(child, loop);
        stop(child, loop);
    }
}

void runtime_manager::remove_children(std::string_view parent_name, event_loop& loop)
{
    auto children = get_children(parent_name);
    for (const auto& child : children)
    {
        // Recurse: remove grandchildren first
        remove_children(child, loop);
        auto* inst = get(child);
        if (inst && inst->get_state() == runtime_running)
            stop(child, loop);
        remove(child);
    }
}

void runtime_manager::stop_all(event_loop& loop)
{
    std::unique_lock lock(mutex);

    for (auto& [name, instance] : runtimes)
    {
        if (instance->get_state() == runtime_running)
            instance->stop(loop);
    }
}

void runtime_manager::dispatch_publish(std::string_view cache_name, std::string_view channel, std::string_view message)
{
    // Snapshot under read lock — do NOT hold the lock during callbacks.
    // A Lua subscribe callback may call socketley.stop/remove which needs a write lock,
    // which would deadlock if we held the read lock here.
    std::vector<runtime_instance*> targets;
    {
        std::shared_lock lock(mutex);
        targets.reserve(runtimes.size());
        for (auto& [_, inst] : runtimes)
            targets.push_back(inst.get());
    }
    for (auto* inst : targets)
        inst->on_publish_dispatch(cache_name, channel, message);
}

void runtime_manager::dispatch_cluster_events(const std::vector<cluster_event>& events)
{
    // Snapshot under read lock — same pattern as dispatch_publish()
    std::vector<runtime_instance*> targets;
    {
        std::shared_lock lock(mutex);
        targets.reserve(runtimes.size());
        for (auto& [_, inst] : runtimes)
            targets.push_back(inst.get());
    }

#ifndef SOCKETLEY_NO_LUA
    for (auto* inst : targets)
    {
        auto* lua = inst->lua();
        if (!lua) continue;

        for (const auto& ev : events)
        {
            try {
                switch (ev.kind)
                {
                    case cluster_event::daemon_join:
                        if (lua->has_on_cluster_join())
                        {
                            sol::table dt = lua->state().create_table();
                            dt["name"] = ev.daemon_name;
                            // Look up host from remote daemons
                            if (m_cluster)
                            {
                                auto daemons = m_cluster->get_all_daemons();
                                for (const auto& rd : daemons)
                                {
                                    if (rd.name == ev.daemon_name)
                                    {
                                        dt["host"] = rd.host;
                                        break;
                                    }
                                }
                            }
                            lua->on_cluster_join()(dt);
                        }
                        break;

                    case cluster_event::daemon_leave:
                        if (lua->has_on_cluster_leave())
                        {
                            sol::table dt = lua->state().create_table();
                            dt["name"] = ev.daemon_name;
                            lua->on_cluster_leave()(dt);
                        }
                        break;

                    case cluster_event::group_change:
                        if (lua->has_on_group_change())
                        {
                            // Build members table
                            sol::table members = lua->state().create_table();
                            int mi = 1;
                            if (m_cluster)
                            {
                                // Local group members
                                {
                                    std::shared_lock lock(mutex);
                                    for (const auto& [_, rinst] : runtimes)
                                    {
                                        if (rinst->get_group() == ev.group_name &&
                                            rinst->get_state() == runtime_running &&
                                            rinst->get_port() > 0)
                                        {
                                            sol::table m = lua->state().create_table();
                                            m["daemon"] = std::string(m_cluster->get_daemon_name());
                                            m["host"] = std::string(m_cluster->get_cluster_addr());
                                            m["port"] = rinst->get_port();
                                            members[mi++] = m;
                                        }
                                    }
                                }
                                // Remote group members
                                auto daemons = m_cluster->get_all_daemons();
                                for (const auto& rd : daemons)
                                {
                                    for (const auto& rt : rd.runtimes)
                                    {
                                        if (rt.group == ev.group_name &&
                                            rt.state == "running" && rt.port > 0)
                                        {
                                            sol::table m = lua->state().create_table();
                                            m["daemon"] = rt.daemon_name;
                                            m["host"] = rt.host;
                                            m["port"] = rt.port;
                                            members[mi++] = m;
                                        }
                                    }
                                }
                            }
                            lua->on_group_change()(ev.group_name, members);
                        }
                        break;
                }
            } catch (const sol::error& e) {
                fprintf(stderr, "[lua] cluster event callback error: %s\n", e.what());
            }
        }
    }
#endif
}

std::vector<runtime_instance*> runtime_manager::get_by_group(std::string_view group) const
{
    std::shared_lock lock(mutex);
    std::vector<runtime_instance*> result;
    for (const auto& [_, inst] : runtimes)
    {
        if (inst->get_group() == group && inst->get_state() == runtime_running)
            result.push_back(inst.get());
    }
    return result;
}

const runtime_manager::runtime_map& runtime_manager::list() const
{
    return runtimes;
}

runtime_instance* runtime_manager::get(std::string_view name)
{
    std::shared_lock lock(mutex);

    auto it = runtimes.find(name);
    if (it != runtimes.end())
        return it->second.get();
    return nullptr;
}

void runtime_manager::set_cluster_discovery(cluster_discovery* cd)
{
    m_cluster = cd;
}

cluster_discovery* runtime_manager::get_cluster_discovery() const
{
    return m_cluster;
}

// ── socketley/shared/runtime_factory.cpp ──


std::unique_ptr<runtime_instance> create_runtime(runtime_type type, std::string_view name)
{
    switch (type)
    {
        case runtime_cache:
            return std::make_unique<cache_instance>(name);
        case runtime_server:
            return std::make_unique<server_instance>(name);
        case runtime_client:
            return std::make_unique<client_instance>(name);
        case runtime_proxy:
            return std::make_unique<proxy_instance>(name);
        default:
            return nullptr;
    }
}

// ── socketley/runtime/server/server_instance.cpp ──



server_instance::server_instance(std::string_view name)
    : runtime_instance(runtime_server, name), m_mode(mode_inout), m_listen_fd(-1), m_loop(nullptr)
{
    std::memset(&m_accept_addr, 0, sizeof(m_accept_addr));
    m_accept_addrlen = sizeof(m_accept_addr);
    m_accept_req = { op_accept, -1, nullptr, 0, this };
}

server_instance::~server_instance()
{
    if (m_listen_fd >= 0)
        close(m_listen_fd);
    if (m_udp_fd >= 0)
        close(m_udp_fd);
}

void server_instance::set_mode(server_mode mode)
{
    m_mode = mode;
}

server_mode server_instance::get_mode() const
{
    return m_mode;
}

void server_instance::set_udp(bool udp)
{
    m_udp = udp;
}

bool server_instance::is_udp() const
{
    return m_udp;
}

// Routing: get_runtime_manager() from base class replaces per-type get_runtime_manager()

void server_instance::set_master_pw(std::string_view pw)
{
    m_master_pw = std::string(pw);
}

std::string_view server_instance::get_master_pw() const
{
    return m_master_pw;
}

void server_instance::set_master_forward(bool fwd)
{
    m_master_forward = fwd;
}

bool server_instance::get_master_forward() const
{
    return m_master_forward;
}

int server_instance::get_master_fd() const
{
    return m_master_fd;
}

void server_instance::set_http_dir(std::string_view path)
{
    m_http_dir = std::filesystem::path(path);
}

const std::filesystem::path& server_instance::get_http_dir() const
{
    return m_http_dir;
}

void server_instance::set_http_cache(bool enabled)
{
    m_http_cache_enabled = enabled;
}

bool server_instance::get_http_cache() const
{
    return m_http_cache_enabled;
}

static std::string_view http_content_type(std::string_view ext)
{
    switch (fnv1a(ext))
    {
        case fnv1a(".html"): case fnv1a(".htm"):
            return "text/html; charset=utf-8";
        case fnv1a(".css"):  return "text/css; charset=utf-8";
        case fnv1a(".js"):   return "application/javascript; charset=utf-8";
        case fnv1a(".json"): return "application/json; charset=utf-8";
        case fnv1a(".png"):  return "image/png";
        case fnv1a(".jpg"):  case fnv1a(".jpeg"):
            return "image/jpeg";
        case fnv1a(".gif"):  return "image/gif";
        case fnv1a(".svg"):  return "image/svg+xml";
        case fnv1a(".ico"):  return "image/x-icon";
        case fnv1a(".woff2"): return "font/woff2";
        case fnv1a(".woff"): return "font/woff";
        case fnv1a(".ttf"):  return "font/ttf";
        case fnv1a(".txt"):  return "text/plain; charset=utf-8";
        case fnv1a(".xml"):  return "application/xml";
        case fnv1a(".wasm"): return "application/wasm";
        case fnv1a(".webp"): return "image/webp";
        case fnv1a(".mp4"):  return "video/mp4";
        case fnv1a(".webm"): return "video/webm";
        case fnv1a(".mp3"):  return "audio/mpeg";
        case fnv1a(".ogg"):  return "audio/ogg";
        case fnv1a(".pdf"):  return "application/pdf";
        default:             return "application/octet-stream";
    }
}

static constexpr std::string_view WS_INJECT_SCRIPT =
    "<script>const socketley=new WebSocket("
    "`ws${location.protocol==='https:'?'s':''}://${location.host}`);</script>";

static std::string inject_ws_script(std::string_view content)
{
    std::string result(content);

    // Try </head> first
    auto pos = result.find("</head>");
    if (pos == std::string::npos)
        pos = result.find("</HEAD>");
    if (pos != std::string::npos)
    {
        result.insert(pos, WS_INJECT_SCRIPT);
        return result;
    }

    // Try </body>
    pos = result.find("</body>");
    if (pos == std::string::npos)
        pos = result.find("</BODY>");
    if (pos != std::string::npos)
    {
        result.insert(pos, WS_INJECT_SCRIPT);
        return result;
    }

    // Append at end
    result.append(WS_INJECT_SCRIPT);
    return result;
}

static std::string build_http_response(std::string_view content_type, std::string_view body)
{
    std::string resp;
    resp.reserve(128 + body.size());
    resp.append("HTTP/1.1 200 OK\r\nContent-Type: ");
    resp.append(content_type);
    resp.append("\r\nContent-Length: ");
    char len_buf[24];
    auto [len_end, len_ec] = std::to_chars(len_buf, len_buf + sizeof(len_buf), body.size());
    resp.append(len_buf, len_end - len_buf);
    resp.append("\r\nConnection: close\r\n\r\n");
    resp.append(body);
    return resp;
}

static const std::shared_ptr<const std::string>& http_404_response()
{
    static const auto resp = std::make_shared<const std::string>(
        "HTTP/1.1 404 Not Found\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: 13\r\n"
        "Connection: close\r\n\r\n"
        "404 Not Found");
    return resp;
}

void server_instance::rebuild_http_cache()
{
    m_http_cache.clear();
    if (m_http_dir.empty())
        return;

    std::error_code ec;

    // Resolve canonical base path (also cached for disk-mode serve_http)
    m_http_base = fs::canonical(m_http_dir, ec);
    if (ec)
        return;

    for (const auto& entry : fs::recursive_directory_iterator(m_http_base, ec))
    {
        if (!entry.is_regular_file())
            continue;

        // Compute URL path relative to base dir
        auto rel = fs::relative(entry.path(), m_http_base, ec);
        if (ec)
            continue;
        std::string url_path = "/" + rel.string();

        // Read file content
        std::ifstream f(entry.path(), std::ios::binary);
        if (!f.is_open())
            continue;
        std::string content((std::istreambuf_iterator<char>(f)),
                             std::istreambuf_iterator<char>());

        // Detect content type
        std::string ext = entry.path().extension().string();
        for (auto& c : ext) c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
        uint32_t ext_hash = fnv1a(ext);
        auto ct = http_content_type(ext);

        // Inject WebSocket script into HTML files
        if (ext_hash == fnv1a(".html") || ext_hash == fnv1a(".htm"))
            content = inject_ws_script(content);

        // Store pre-built response as shared_ptr (zero-copy on cache hit)
        m_http_cache[url_path] = {
            std::make_shared<const std::string>(build_http_response(ct, content))
        };
    }
}

void server_instance::serve_http(server_connection* conn, std::string_view path)
{
    // Normalize: "/" → "/index.html"
    std::string url_path(path);
    if (url_path == "/")
        url_path = "/index.html";

    // Percent-decode the path to catch %2e%2e → .. traversal
    auto percent_decode = [](std::string& s) {
        std::string out;
        out.reserve(s.size());
        for (size_t i = 0; i < s.size(); i++)
        {
            if (s[i] == '%' && i + 2 < s.size())
            {
                auto hex = [](char c) -> int {
                    if (c >= '0' && c <= '9') return c - '0';
                    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
                    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
                    return -1;
                };
                int h = hex(s[i+1]), l = hex(s[i+2]);
                if (h >= 0 && l >= 0)
                {
                    out += static_cast<char>((h << 4) | l);
                    i += 2;
                    continue;
                }
            }
            out += s[i];
        }
        s = std::move(out);
    };
    percent_decode(url_path);

    // Security: reject path traversal and null bytes
    if (url_path.find("..") != std::string::npos ||
        url_path.find('\0') != std::string::npos)
    {
        conn->write_queue.push(http_404_response());
        if (!conn->write_pending)
            flush_write_queue(conn);
        conn->closing = true;
        return;
    }

    // Strip query string
    auto qpos = url_path.find('?');
    if (qpos != std::string::npos)
        url_path.erase(qpos);

    if (m_http_cache_enabled && !m_http_cache.empty())
    {
        // Cached mode: zero-copy lookup — just bump shared_ptr refcount
        auto it = m_http_cache.find(url_path);
        conn->write_queue.push(it != m_http_cache.end()
            ? it->second.response : http_404_response());
    }
    else
    {
        // Disk mode: read file on each request
        std::error_code ec;

        // Resolve base once if not yet done (dev mode, no rebuild_http_cache call)
        if (m_http_base.empty())
        {
            m_http_base = fs::canonical(m_http_dir, ec);
            if (ec)
            {
                conn->write_queue.push(http_404_response());
                if (!conn->write_pending)
                    flush_write_queue(conn);
                conn->closing = true;
                return;
            }
        }

        fs::path file_path = m_http_base / url_path.substr(1); // strip leading /
        fs::path resolved = fs::canonical(file_path, ec);

        // Verify the resolved path is within the base directory (symlink escape check)
        auto base_str = m_http_base.native();
        auto resolved_str = resolved.native();
        if (ec || resolved_str.size() < base_str.size() ||
            resolved_str.compare(0, base_str.size(), base_str) != 0)
        {
            conn->write_queue.push(http_404_response());
            if (!conn->write_pending)
                flush_write_queue(conn);
            conn->closing = true;
            return;
        }

        std::ifstream f(resolved, std::ios::binary);
        if (!f.is_open())
        {
            conn->write_queue.push(http_404_response());
        }
        else
        {
            std::string content((std::istreambuf_iterator<char>(f)),
                                 std::istreambuf_iterator<char>());
            std::string ext = resolved.extension().string();
            for (auto& c : ext)
                c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
            uint32_t ext_hash = fnv1a(ext);
            auto ct = http_content_type(ext);

            if (ext_hash == fnv1a(".html") || ext_hash == fnv1a(".htm"))
                content = inject_ws_script(content);

            conn->write_queue.push(
                std::make_shared<const std::string>(build_http_response(ct, content)));
        }
    }

    if (!conn->write_pending)
        flush_write_queue(conn);
    conn->closing = true;
}

size_t server_instance::get_connection_count() const
{
    if (m_udp)
        return m_udp_peers.size();
    return m_clients.size() + m_forwarded_clients.size();
}

bool server_instance::setup(event_loop& loop)
{
    // Clear any connections left over from a previous stop() — their fds are
    // already closed, but we deferred freeing them so that in-flight io_uring
    // CQEs could reference their io_request members safely.  Now that setup()
    // is starting a fresh run it is safe to destroy them.
    m_clients.clear();

    m_loop = &loop;

    // Internal-only server (port=0, used for Lua-managed sub-servers)
    if (get_port() == 0 && !get_owner().empty())
        return true;

    uint16_t port = get_port();
    if (port == 0)
        port = 8000;

    if (m_udp)
    {
        m_udp_fd = socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK, 0);
        if (m_udp_fd < 0)
            return false;

        int opt = 1;
        setsockopt(m_udp_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
        setsockopt(m_udp_fd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));

        struct sockaddr_in addr{};
        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = INADDR_ANY;
        addr.sin_port = htons(port);

        if (bind(m_udp_fd, reinterpret_cast<struct sockaddr*>(&addr), sizeof(addr)) < 0)
        {
            close(m_udp_fd);
            m_udp_fd = -1;
            return false;
        }

        // Setup recvmsg structures
        std::memset(&m_udp_recv_addr, 0, sizeof(m_udp_recv_addr));
        m_udp_recv_iov.iov_base = m_udp_recv_buf;
        m_udp_recv_iov.iov_len = sizeof(m_udp_recv_buf);
        std::memset(&m_udp_recv_msg, 0, sizeof(m_udp_recv_msg));
        m_udp_recv_msg.msg_name = &m_udp_recv_addr;
        m_udp_recv_msg.msg_namelen = sizeof(m_udp_recv_addr);
        m_udp_recv_msg.msg_iov = &m_udp_recv_iov;
        m_udp_recv_msg.msg_iovlen = 1;

        m_udp_recv_req = { op_recvmsg, m_udp_fd, nullptr, 0, this };
        loop.submit_recvmsg(m_udp_fd, &m_udp_recv_msg, &m_udp_recv_req);

        return true;
    }

    // TCP mode
    m_listen_fd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);
    if (m_listen_fd < 0)
        return false;

    int opt = 1;
    setsockopt(m_listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    setsockopt(m_listen_fd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));
    setsockopt(m_listen_fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));

    struct sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(port);

    if (bind(m_listen_fd, reinterpret_cast<struct sockaddr*>(&addr), sizeof(addr)) < 0)
    {
        close(m_listen_fd);
        m_listen_fd = -1;
        return false;
    }

    if (listen(m_listen_fd, 4096) < 0)
    {
        close(m_listen_fd);
        m_listen_fd = -1;
        return false;
    }

    // Setup provided buffer ring for zero-copy reads
    m_use_provided_bufs = loop.setup_buf_ring(BUF_GROUP_ID, BUF_COUNT, BUF_SIZE);

    // Use multishot accept if supported (kernel 5.19+)
    if (event_loop::supports_multishot_accept())
    {
        m_accept_req.type = op_multishot_accept;
        loop.submit_multishot_accept(m_listen_fd, &m_accept_req);
        m_multishot_active = true;
    }
    else
    {
        m_accept_req.type = op_accept;
        loop.submit_accept(m_listen_fd, &m_accept_addr, &m_accept_addrlen, &m_accept_req);
        m_multishot_active = false;
    }

    // Build HTTP file cache if enabled
    if (m_http_cache_enabled && !m_http_dir.empty())
        rebuild_http_cache();

    if (get_idle_timeout() > 0)
    {
        m_idle_sweep_ts.tv_sec = 30;
        m_idle_sweep_ts.tv_nsec = 0;
        m_idle_sweep_req = { op_timeout, -1, nullptr, 0, this };
        m_loop->submit_timeout(&m_idle_sweep_ts, &m_idle_sweep_req);
    }

    return true;
}

void server_instance::teardown(event_loop& loop)
{
    if (m_udp)
    {
        if (m_udp_fd >= 0)
        {
            close(m_udp_fd);
            m_udp_fd = -1;
        }
        m_udp_peers.clear();
        m_loop = nullptr;
        return;
    }

    // Shutdown the listen socket before closing it.  This causes the kernel to
    // complete any pending io_uring accept ops immediately (via the socket wait
    // queue), placing their CQEs in the ring synchronously within the syscall.
    // Using shutdown() instead of a cancel SQE avoids the race where close(fd)
    // is called before the SQPOLL thread processes the cancel SQE: after close,
    // fget(fd) returns NULL so the cancel fails with ENOENT, leaving the accept
    // in-flight and its CQE arriving after server_instance is freed → SIGSEGV.
    if (m_listen_fd >= 0)
        shutdown(m_listen_fd, SHUT_RDWR);

    // Close listener to stop new connections
    if (m_listen_fd >= 0)
    {
        close(m_listen_fd);
        m_listen_fd = -1;
    }

    // Drain: flush pending write queues with blocking writes before closing
    if (get_drain())
    {
        for (auto& [fd, conn] : m_clients)
        {
            while (!conn->write_queue.empty())
            {
                auto& msg = conn->write_queue.front();
                if (::write(fd, msg->data(), msg->size()) < 0) break;
                conn->write_queue.pop();
            }
        }
    }

    for (auto& [fd, conn] : m_clients)
    {
        if (fd >= 0 && fd < MAX_FDS)
            m_conn_idx[fd] = nullptr;

        // Shutdown the connection before closing it.  Like for the listen fd,
        // shutdown() completes any pending io_uring read/write ops synchronously
        // (the kernel wakes up the socket wait queue, completing the ops and
        // placing their CQEs in the ring before we return from shutdown()).
        // This avoids the cancel-SQE fd-closed race described above.
        shutdown(fd, SHUT_RDWR);
        close(fd);

        // Release shared_ptr message refs now so memory is freed promptly, but
        // keep the server_connection structs alive — their embedded io_request
        // members are still referenced by in-flight CQEs until the cancellations
        // complete and the deferred-delete timeout fires.
        while (!conn->write_queue.empty())
            conn->write_queue.pop();
        for (size_t i = 0; i < conn->write_batch_count; i++)
            conn->write_batch[i].reset();
        conn->write_batch_count = 0;
    }

    // Do NOT call m_clients.clear() here.  The server_connection objects must
    // stay alive until the server_instance itself is destroyed (see setup() for
    // when they are freed on a restart, or the destructor for the remove case).
    m_idle_sweep_req.owner = nullptr;
    m_loop = nullptr;
    m_multishot_active = false;
    m_master_fd = -1;

    // Clean up forwarded client entries on parent servers
    for (auto& [fwd_fd, parent_name] : m_forwarded_clients)
    {
        auto* mgr = get_runtime_manager();
        if (mgr)
        {
            auto* parent = mgr->get(parent_name);
            if (parent && parent->get_type() == runtime_server)
            {
                auto* psrv = static_cast<server_instance*>(parent);
                psrv->m_routes.erase(fwd_fd);
            }
        }
    }
    m_forwarded_clients.clear();
    m_routes.clear();

    // Zeroize password memory
    if (!m_master_pw.empty())
    {
        volatile char* p = m_master_pw.data();
        for (size_t i = 0; i < m_master_pw.size(); i++)
            p[i] = 0;
    }
}

void server_instance::on_cqe(struct io_uring_cqe* cqe)
{
    auto* req = static_cast<io_request*>(io_uring_cqe_get_data(cqe));
    if (!req || !m_loop)
        return;

    switch (req->type)
    {
        case op_accept:
        case op_multishot_accept:
            handle_accept(cqe);
            break;
        case op_recvmsg:
            handle_udp_read(cqe);
            break;
        case op_read:
        case op_read_provided:
        case op_write:
        case op_writev:
            if (req->fd < 0 || req->fd >= MAX_FDS || !m_conn_idx[req->fd])
                return;
            if (req->type == op_read || req->type == op_read_provided)
                handle_read(cqe, req);
            else
                handle_write(cqe, req);
            break;
        case op_timeout:
            if (req == &m_idle_sweep_req)
            {
                auto now = std::chrono::steady_clock::now();
                auto timeout = std::chrono::seconds(get_idle_timeout());
                for (auto& [cfd, cconn] : m_clients)
                {
                    if (!cconn->closing && (now - cconn->last_activity) > timeout)
                    {
                        cconn->closing = true;
                        shutdown(cfd, SHUT_RD);
                    }
                }
                m_loop->submit_timeout(&m_idle_sweep_ts, &m_idle_sweep_req);
            }
            // Accept backoff expired — resubmit accept
            else if (req == &m_accept_backoff_req && m_listen_fd >= 0)
            {
                if (m_multishot_active)
                    m_loop->submit_multishot_accept(m_listen_fd, &m_accept_req);
                else
                {
                    m_accept_addrlen = sizeof(m_accept_addr);
                    m_loop->submit_accept(m_listen_fd, &m_accept_addr, &m_accept_addrlen, &m_accept_req);
                }
            }
            break;
        default:
            break;
    }
}

void server_instance::handle_accept(struct io_uring_cqe* cqe)
{
    int client_fd = cqe->res;

    if (client_fd >= 0)
    {
        // Reject fds beyond our O(1) lookup table — they'd become zombie connections
        if (client_fd >= MAX_FDS)
        {
            close(client_fd);
            goto resubmit_accept;
        }

        // Max connections check
        if (get_max_connections() > 0 && m_clients.size() >= get_max_connections())
        {
            close(client_fd);
            goto resubmit_accept;
        }

        int opt = 1;
        setsockopt(client_fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));

        auto conn = std::make_unique<server_connection>();
        conn->fd = client_fd;
        conn->partial.reserve(8192);
        conn->read_req = { op_read, client_fd, conn->read_buf, sizeof(conn->read_buf), this };
        conn->write_req = { op_write, client_fd, nullptr, 0, this };

        auto* ptr = conn.get();
        m_clients[client_fd] = std::move(conn);
        if (client_fd < MAX_FDS)
            m_conn_idx[client_fd] = ptr;

        ptr->last_activity = std::chrono::steady_clock::now();

        m_stat_total_connections.fetch_add(1, std::memory_order_relaxed);
        if (m_clients.size() > m_stat_peak_connections)
            m_stat_peak_connections = static_cast<uint32_t>(m_clients.size());

        // Initialize rate limiting
        double rl = get_rate_limit();
        if (rl > 0)
        {
            ptr->rl_max = rl;
            ptr->rl_tokens = rl;
            ptr->rl_last = std::chrono::steady_clock::now();
        }

        // Check per-IP auth failure rate (master mode only)
        if (!m_master_pw.empty())
        {
            uint32_t ip = m_accept_addr.sin_addr.s_addr;
            auto it = m_auth_ip_failures.find(ip);
            if (it != m_auth_ip_failures.end())
            {
                auto elapsed = std::chrono::steady_clock::now() - it->second.last_failure;
                if (elapsed > std::chrono::seconds(60))
                {
                    m_auth_ip_failures.erase(it);
                }
                else if (it->second.failures >= 10)
                {
                    if (client_fd < MAX_FDS) m_conn_idx[client_fd] = nullptr;
                    m_clients.erase(client_fd);
                    shutdown(client_fd, SHUT_RDWR);
                    close(client_fd);
                    goto resubmit_accept;
                }
            }
        }

        // on_auth fires before on_connect; a rejected client never triggers on_connect
        if (!invoke_on_auth(client_fd))
        {
            if (client_fd < MAX_FDS) m_conn_idx[client_fd] = nullptr;
            m_clients.erase(client_fd);
            shutdown(client_fd, SHUT_RDWR);
            close(client_fd);
            goto resubmit_accept;
        }

        invoke_on_connect(client_fd);

        ptr->read_pending = true;
        if (m_use_provided_bufs)
            m_loop->submit_read_provided(client_fd, BUF_GROUP_ID, &ptr->read_req);
        else
            m_loop->submit_read(client_fd, ptr->read_buf, sizeof(ptr->read_buf), &ptr->read_req);
    }

    // EMFILE/ENFILE: backoff 100ms to avoid CPU spin when fd limit is hit
    if (client_fd == -EMFILE || client_fd == -ENFILE)
    {
        m_accept_backoff_ts.tv_sec = 0;
        m_accept_backoff_ts.tv_nsec = 100000000LL;
        m_accept_backoff_req = { op_timeout, -1, nullptr, 0, this };
        m_loop->submit_timeout(&m_accept_backoff_ts, &m_accept_backoff_req);
        return;
    }

resubmit_accept:
    // Resubmit accept if needed
    if (m_multishot_active)
    {
        // Multishot: only resubmit if IORING_CQE_F_MORE is NOT set
        if (!(cqe->flags & IORING_CQE_F_MORE))
        {
            if (m_listen_fd >= 0)
                m_loop->submit_multishot_accept(m_listen_fd, &m_accept_req);
        }
    }
    else
    {
        // Regular accept: always resubmit
        if (m_listen_fd >= 0)
        {
            m_accept_addrlen = sizeof(m_accept_addr);
            m_loop->submit_accept(m_listen_fd, &m_accept_addr, &m_accept_addrlen, &m_accept_req);
        }
    }
}

void server_instance::handle_read(struct io_uring_cqe* cqe, io_request* req)
{
    int fd = req->fd;
    auto* conn = m_conn_idx[fd];
    if (!conn)
        return;

    conn->read_pending = false;  // Read operation completed

    bool is_provided = (req->type == op_read_provided);

    if (cqe->res <= 0)
    {
        // Return provided buffer if kernel allocated one before error
        if (is_provided && (cqe->flags & IORING_CQE_F_BUFFER))
        {
            uint16_t buf_id = cqe->flags >> IORING_CQE_BUFFER_SHIFT;
            m_loop->return_buf(BUF_GROUP_ID, buf_id);
        }

        // ENOBUFS: buffer pool exhausted — fall back to regular read
        if (is_provided && cqe->res == -ENOBUFS)
        {
            conn->read_pending = true;
            m_loop->submit_read(fd, conn->read_buf, sizeof(conn->read_buf), &conn->read_req);
            return;
        }

        // Connection closed or error
        if (fd == m_master_fd)
            m_master_fd = -1;
        if (conn->write_pending)
        {
            conn->closing = true;
        }
        else
        {
            unroute_client(fd);
            invoke_on_disconnect(fd);
            m_conn_idx[fd] = nullptr;
            close(fd);
            m_clients.erase(fd);
        }
        return;
    }

    conn->last_activity = std::chrono::steady_clock::now();
    m_stat_bytes_in.fetch_add(static_cast<uint64_t>(cqe->res), std::memory_order_relaxed);

    if (is_provided)
    {
        // Extract buffer ID from CQE flags
        uint16_t buf_id = cqe->flags >> IORING_CQE_BUFFER_SHIFT;
        char* buf_ptr = m_loop->get_buf_ptr(BUF_GROUP_ID, buf_id);
        if (buf_ptr)
        {
            conn->partial.append(buf_ptr, cqe->res);
            m_loop->return_buf(BUF_GROUP_ID, buf_id);
        }
    }
    else
    {
        conn->partial.append(conn->read_buf, cqe->res);
    }

    if (conn->partial.size() > server_connection::MAX_PARTIAL_SIZE)
    {
        conn->closing = true;
        goto submit_next_read;
    }

    // WebSocket auto-detection
    if (conn->ws == ws_unknown)
    {
        if (conn->partial.size() < 4)
            goto submit_next_read;
        if (conn->partial[0] == 'G' && conn->partial[1] == 'E' &&
            conn->partial[2] == 'T' && conn->partial[3] == ' ')
            conn->ws = ws_upgrading;
        else
            conn->ws = ws_tcp;
    }

    if (conn->ws == ws_upgrading)
    {
        auto hdr_end = conn->partial.find("\r\n\r\n");
        if (hdr_end == std::string::npos)
        {
            // Reject oversized upgrade requests (belt-and-suspenders for F1 partial limit)
            if (conn->partial.size() > 16384)
            {
                conn->closing = true;
                goto submit_next_read;
            }
            goto submit_next_read; // Incomplete headers
        }

        // Single-pass header scan: find Upgrade + Sec-WebSocket-Key without allocation
        {
            std::string_view hdrs(conn->partial.data(), hdr_end + 4);
            bool has_upgrade = false;
            size_t ws_key_pos = std::string_view::npos;
            size_t ws_key_end = std::string_view::npos;

            // Walk headers line by line
            size_t line_start = hdrs.find("\r\n"); // skip request line
            if (line_start != std::string_view::npos)
                line_start += 2;

            while (line_start < hdr_end)
            {
                size_t line_end = hdrs.find("\r\n", line_start);
                if (line_end == std::string_view::npos || line_end > hdr_end)
                    break;

                std::string_view line = hdrs.substr(line_start, line_end - line_start);
                auto colon = line.find(':');
                if (colon != std::string_view::npos)
                {
                    std::string_view hdr_name = line.substr(0, colon);
                    uint32_t h = fnv1a_lower(hdr_name);

                    switch (h)
                    {
                        case fnv1a("upgrade"):
                        {
                            // Value after ": "
                            size_t val_start = colon + 1;
                            while (val_start < line.size() && line[val_start] == ' ')
                                ++val_start;
                            std::string_view val = line.substr(val_start);
                            if (fnv1a_lower(val) == fnv1a("websocket"))
                                has_upgrade = true;
                            break;
                        }
                        case fnv1a("sec-websocket-key"):
                        {
                            size_t val_start = colon + 1;
                            while (val_start < line.size() && line[val_start] == ' ')
                                ++val_start;
                            ws_key_pos = line_start + val_start;
                            ws_key_end = line_end;
                            break;
                        }
                        case fnv1a("cookie"):
                        case fnv1a("origin"):
                        case fnv1a("sec-websocket-protocol"):
                        case fnv1a("authorization"):
                        {
                            size_t vs = colon + 1;
                            while (vs < line.size() && line[vs] == ' ') ++vs;
                            std::string val(line.substr(vs));
                            switch (h) {
                                case fnv1a("cookie"):                 conn->ws_cookie   = std::move(val); break;
                                case fnv1a("origin"):                 conn->ws_origin   = std::move(val); break;
                                case fnv1a("sec-websocket-protocol"): conn->ws_protocol = std::move(val); break;
                                case fnv1a("authorization"):          conn->ws_auth     = std::move(val); break;
                            }
                            break;
                        }
                    }
                }

                line_start = line_end + 2;
            }

            if (!has_upgrade || ws_key_pos == std::string_view::npos)
            {
                if (!m_http_dir.empty())
                {
                    // Extract request path from "GET /path HTTP/1.1"
                    std::string_view req_line(conn->partial.data(),
                        std::min(conn->partial.find("\r\n"), conn->partial.size()));
                    auto sp1 = req_line.find(' ');
                    auto sp2 = (sp1 != std::string_view::npos)
                                ? req_line.find(' ', sp1 + 1) : std::string_view::npos;
                    if (sp1 != std::string_view::npos && sp2 != std::string_view::npos)
                    {
                        std::string_view path = req_line.substr(sp1 + 1, sp2 - sp1 - 1);
                        conn->partial.clear();
                        serve_http(conn, path);
                        goto submit_next_read;
                    }
                }
                conn->ws = ws_tcp;
                conn->partial.clear();
                goto submit_next_read;
            }

            std::string_view ws_key = hdrs.substr(ws_key_pos, ws_key_end - ws_key_pos);

            // Send 101 response
            std::string response = ws_handshake_response(ws_key);
            auto resp_msg = std::make_shared<const std::string>(std::move(response));
            conn->write_queue.push(resp_msg);
            if (!conn->write_pending)
                flush_write_queue(conn);

            conn->ws = ws_active;
            invoke_on_websocket(conn->fd);
            conn->partial.erase(0, hdr_end + 4);
        }
    }

    if (conn->ws == ws_active)
    {
        // Parse WebSocket frames
        ws_frame frame;
        while (ws_parse_frame(conn->partial.data(), conn->partial.size(), frame))
        {
            conn->partial.erase(0, frame.consumed);
            switch (frame.opcode)
            {
                case WS_OP_TEXT:
                    if (!frame.payload.empty())
                        process_message(conn, frame.payload);
                    break;
                case WS_OP_PING:
                {
                    auto pong = std::make_shared<const std::string>(ws_frame_pong(frame.payload));
                    conn->write_queue.push(pong);
                    if (!conn->write_pending)
                        flush_write_queue(conn);
                    break;
                }
                case WS_OP_CLOSE:
                {
                    auto close_frame = std::make_shared<const std::string>(ws_frame_close());
                    conn->write_queue.push(close_frame);
                    if (!conn->write_pending)
                        flush_write_queue(conn);
                    conn->closing = true;
                    break;
                }
                default:
                    break;
            }
        }
        goto submit_next_read;
    }

    // ws_tcp: existing newline-delimited parsing
    {
        size_t scan_from = 0;
        size_t pos;
        while ((pos = conn->partial.find('\n', scan_from)) != std::string::npos)
        {
            std::string_view line(conn->partial.data() + scan_from, pos - scan_from);

            if (!line.empty() && line.back() == '\r')
                line.remove_suffix(1);

            if (!line.empty())
                process_message(conn, line);

            scan_from = pos + 1;
        }

        if (scan_from > 0)
        {
            if (scan_from >= conn->partial.size())
                conn->partial.clear();
            else
                conn->partial.erase(0, scan_from);
        }
    }

submit_next_read:
    // Only submit next read if connection is not closing
    if (m_loop && !conn->closing)
    {
        conn->read_pending = true;
        if (m_use_provided_bufs)
            m_loop->submit_read_provided(fd, BUF_GROUP_ID, &conn->read_req);
        else
            m_loop->submit_read(fd, conn->read_buf, sizeof(conn->read_buf), &conn->read_req);
    }
    else if (conn->closing && !conn->write_pending)
    {
        // No write in flight and closing — clean up now.
        // (If write_pending, handle_write will clean up when write completes.)
        unroute_client(fd);
        invoke_on_disconnect(fd);
        if (fd >= 0 && fd < MAX_FDS) m_conn_idx[fd] = nullptr;
        close(fd);
        m_clients.erase(fd);
    }
}

// Constant-time string compare to prevent timing attacks on password
static bool constant_time_eq(std::string_view a, std::string_view b)
{
    volatile uint8_t diff = static_cast<uint8_t>(a.size() != b.size());
    size_t max_len = std::max(a.size(), b.size());
    for (size_t i = 0; i < max_len; i++)
    {
        uint8_t ca = (i < a.size()) ? static_cast<uint8_t>(a[i]) : 0;
        uint8_t cb = (i < b.size()) ? static_cast<uint8_t>(b[i]) : 0;
        diff |= ca ^ cb;
    }
    return diff == 0;
}

static constexpr uint8_t MAX_AUTH_FAILURES = 5;

static bool check_rate_limit(server_connection* conn)
{
    if (conn->rl_max <= 0)
        return true;

    auto now = std::chrono::steady_clock::now();
    double elapsed = std::chrono::duration<double>(now - conn->rl_last).count();
    conn->rl_last = now;
    conn->rl_tokens += elapsed * conn->rl_max;
    if (conn->rl_tokens > conn->rl_max)
        conn->rl_tokens = conn->rl_max;

    if (conn->rl_tokens < 1.0)
        return false;

    conn->rl_tokens -= 1.0;
    return true;
}

void server_instance::process_message(server_connection* sender, std::string_view msg)
{
    // Rate limit check (per-connection)
    if (sender && !check_rate_limit(sender))
        return;

    // Global rate limit check (across all connections)
    if (!check_global_rate_limit())
        return;

    // Check if this client is routed to a sub-server
    if (sender)
    {
        auto rit = m_routes.find(sender->fd);
        if (rit != m_routes.end())
        {
            auto* mgr = get_runtime_manager();
            if (mgr)
            {
                auto* target = mgr->get(rit->second);
                if (target && target->get_type() == runtime_server &&
                    target->get_state() == runtime_running)
                {
                    auto* sub = static_cast<server_instance*>(target);
                    sub->process_forwarded_message(sender->fd, msg, get_name());
                }
            }
            return;
        }
    }

    m_stat_total_messages.fetch_add(1, std::memory_order_relaxed);
    print_bash_message(msg);
    notify_interactive(msg);

    // Fire on_client_message callback (sender-aware)
    if (sender)
        invoke_on_client_message(sender->fd, msg);

    // Cache command interception: "cache <cmd>" → execute against linked cache, respond to sender only
    if (sender && msg.size() > 6 && msg.starts_with("cache "))
    {
        auto cname = get_cache_name();
        if (!cname.empty() && get_runtime_manager())
        {
            auto* cache_rt = get_runtime_manager()->get(cname);
            if (cache_rt && cache_rt->get_type() == runtime_cache &&
                cache_rt->get_state() == runtime_running)
            {
                auto* cache = static_cast<cache_instance*>(cache_rt);
                std::string resp = cache->execute(msg.substr(6));
                if (!resp.empty())
                {
                    if (resp.back() != '\n')
                        resp += '\n';
                    auto resp_msg = std::make_shared<const std::string>(std::move(resp));
                    send_to(sender, resp_msg);
                }
            }
        }
        return; // Cache commands are never broadcast
    }

    // Store in cache if configured
    auto cache_name = get_cache_name();
    if (!cache_name.empty() && get_runtime_manager())
    {
        auto* cache_rt = get_runtime_manager()->get(cache_name);
        if (cache_rt && cache_rt->get_type() == runtime_cache &&
            cache_rt->get_state() == runtime_running)
        {
            auto* cache = static_cast<cache_instance*>(cache_rt);
            char key_buf[24];
            auto [key_end, key_ec] = std::to_chars(key_buf, key_buf + sizeof(key_buf), ++m_message_counter);
            cache->store_direct(std::string_view(key_buf, key_end - key_buf), msg);
        }
    }

    switch (m_mode)
    {
        case mode_inout:
        {
            invoke_on_message(msg);

            if (lua() && lua()->has_on_message())
                break;

            if (m_udp)
            {
                // UDP: broadcast to all peers (exclude handled by caller via addr)
                udp_broadcast(msg, nullptr);
            }
            else
            {
                std::string relay_str;
                relay_str.reserve(msg.size() + 1);
                relay_str.append(msg.data(), msg.size());
                relay_str += '\n';
                auto relay_msg = std::make_shared<const std::string>(std::move(relay_str));
                broadcast(relay_msg, sender ? sender->fd : -1);
            }
            break;
        }
        case mode_in:
        {
            invoke_on_message(msg);
            break;
        }
        case mode_out:
            break;
        case mode_master:
        {
            // Master authentication: "master <password>"
            if (msg.size() > 7 && msg.starts_with("master "))
            {
                // Auth attempt limit — disconnect after too many failures
                if (sender->auth_failures >= MAX_AUTH_FAILURES)
                {
                    sender->closing = true;
                    break;
                }

                std::string_view pw = msg.substr(7);
                bool auth_ok = false;

                // Try Lua on_master_auth callback first
                auto* lctx = lua();
                if (lctx && lctx->has_on_master_auth())
                {
#ifndef SOCKETLEY_NO_LUA
                    try {
                        sol::protected_function_result result =
                            lctx->on_master_auth()(sender->fd, std::string(pw));
                        if (result.valid())
                            auth_ok = result.get<bool>();
                    } catch (...) {}
#endif
                }
                else if (!m_master_pw.empty())
                {
                    auth_ok = constant_time_eq(pw, m_master_pw);
                }

                if (auth_ok)
                {
                    m_master_fd = sender->fd;
                    sender->auth_failures = 0;
                    auto ok_msg = std::make_shared<const std::string>("master: ok\n");
                    send_to(sender, ok_msg);
                }
                else
                {
                    sender->auth_failures++;

                    // Record per-IP failure
                    {
                        struct sockaddr_in peer_addr{};
                        socklen_t peer_len = sizeof(peer_addr);
                        if (getpeername(sender->fd, reinterpret_cast<struct sockaddr*>(&peer_addr), &peer_len) == 0)
                        {
                            auto& rec = m_auth_ip_failures[peer_addr.sin_addr.s_addr];
                            rec.failures++;
                            rec.last_failure = std::chrono::steady_clock::now();
                        }
                    }

                    auto deny_msg = std::make_shared<const std::string>("master: denied\n");
                    send_to(sender, deny_msg);
                }
                break;
            }

            // If sender is master: broadcast to all except sender
            if (sender && sender->fd == m_master_fd)
            {
                invoke_on_message(msg);

                if (!(lua() && lua()->has_on_message()))
                {
                    std::string relay_str;
                    relay_str.reserve(msg.size() + 1);
                    relay_str.append(msg.data(), msg.size());
                    relay_str += '\n';
                    auto relay_msg = std::make_shared<const std::string>(std::move(relay_str));
                    broadcast(relay_msg, sender->fd);
                }
                break;
            }

            // Non-master: forward to master if master_forward is set
            if (sender && m_master_forward && m_master_fd >= 0 &&
                m_master_fd < MAX_FDS && m_conn_idx[m_master_fd])
            {
                char fd_buf[16];
                auto [fd_end, fd_ec] = std::to_chars(fd_buf, fd_buf + sizeof(fd_buf), sender->fd);
                auto fwd_msg = std::make_shared<std::string>();
                fwd_msg->reserve(msg.size() + 16);
                fwd_msg->push_back('[');
                fwd_msg->append(fd_buf, fd_end - fd_buf);
                fwd_msg->append("] ", 2);
                fwd_msg->append(msg.data(), msg.size());
                fwd_msg->push_back('\n');
                send_to(m_conn_idx[m_master_fd], fwd_msg);
            }
            // Non-master messages are silently dropped (not broadcast)
            break;
        }
        default:
            break;
    }
}

void server_instance::lua_broadcast(std::string_view msg)
{
    if (!m_loop)
        return;

    invoke_on_send(msg);

    if (m_udp)
    {
        udp_broadcast(msg, nullptr);
        return;
    }

    std::string full_str;
    full_str.reserve(msg.size() + 1);
    full_str.append(msg.data(), msg.size());
    if (full_str.empty() || full_str.back() != '\n')
        full_str += '\n';

    auto full_msg = std::make_shared<const std::string>(std::move(full_str));
    broadcast(full_msg, -1);  // -1 = don't exclude anyone

    // Also send to forwarded clients through their parent servers
    for (auto& [fwd_fd, parent_name] : m_forwarded_clients)
    {
        auto* mgr = get_runtime_manager();
        if (mgr)
        {
            auto* parent = mgr->get(parent_name);
            if (parent && parent->get_type() == runtime_server &&
                parent->get_state() == runtime_running)
            {
                static_cast<server_instance*>(parent)->send_to_client(fwd_fd, msg);
            }
        }
    }
}

void server_instance::broadcast(const std::shared_ptr<const std::string>& msg, int exclude_fd)
{
    if (!m_loop)
        return;

    std::shared_ptr<const std::string> ws_msg; // Lazy WS frame creation

    for (auto& [fd, conn] : m_clients)
    {
        if (fd == exclude_fd || conn->closing)
            continue;

        if (conn->write_queue.size() >= server_connection::MAX_WRITE_QUEUE)
        {
            conn->closing = true;
            continue;
        }

        if (conn->ws == ws_active)
        {
            if (!ws_msg)
            {
                // Strip trailing newline for WS frame (WS messages are not newline-delimited)
                std::string_view payload(*msg);
                if (!payload.empty() && payload.back() == '\n')
                    payload.remove_suffix(1);
                ws_msg = std::make_shared<const std::string>(ws_frame_text(payload));
            }
            conn->write_queue.push(ws_msg);
            if (!conn->write_pending)
                flush_write_queue(conn.get());
        }
        else
        {
            conn->write_queue.push(msg);
            if (!conn->write_pending)
                flush_write_queue(conn.get());
        }
    }
}

void server_instance::send_to(server_connection* conn, const std::shared_ptr<const std::string>& msg)
{
    if (!m_loop || conn->closing)
        return;

    if (conn->write_queue.size() >= server_connection::MAX_WRITE_QUEUE)
    {
        conn->closing = true;
        return;
    }

    if (conn->ws == ws_active)
    {
        // Strip trailing newline for WS frame
        std::string_view payload(*msg);
        if (!payload.empty() && payload.back() == '\n')
            payload.remove_suffix(1);
        auto framed = std::make_shared<const std::string>(ws_frame_text(payload));
        conn->write_queue.push(framed);
    }
    else
    {
        conn->write_queue.push(msg);
    }

    if (!conn->write_pending)
        flush_write_queue(conn);
}

void server_instance::flush_write_queue(server_connection* conn)
{
    if (!m_loop || conn->write_queue.empty())
        return;

    // Coalesce up to MAX_WRITE_BATCH messages into a single writev
    uint32_t count = 0;
    while (!conn->write_queue.empty() && count < server_connection::MAX_WRITE_BATCH)
    {
        conn->write_batch[count] = std::move(conn->write_queue.front());
        conn->write_queue.pop();

        conn->write_iovs[count].iov_base = const_cast<char*>(conn->write_batch[count]->data());
        conn->write_iovs[count].iov_len = conn->write_batch[count]->size();
        count++;
    }

    conn->write_batch_count = count;
    conn->write_pending = true;

    if (count == 1)
    {
        // Single message — use plain write (lower overhead than writev)
        conn->write_req.type = op_write;
        m_loop->submit_write(conn->fd, conn->write_batch[0]->data(),
            static_cast<uint32_t>(conn->write_batch[0]->size()), &conn->write_req);
    }
    else
    {
        conn->write_req.type = op_writev;
        m_loop->submit_writev(conn->fd, conn->write_iovs, count, &conn->write_req);
    }
}

void server_instance::handle_write(struct io_uring_cqe* cqe, io_request* req)
{
    int fd = req->fd;
    auto* conn = m_conn_idx[fd];
    if (!conn)
        return;

    conn->write_pending = false;

    // Release batch references
    for (uint32_t i = 0; i < conn->write_batch_count; i++)
        conn->write_batch[i].reset();
    conn->write_batch_count = 0;

    if (cqe->res <= 0)
    {
        if (fd == m_master_fd)
            m_master_fd = -1;
        conn->closing = true;
        if (!conn->read_pending)
        {
            unroute_client(fd);
            invoke_on_disconnect(fd);
            m_conn_idx[fd] = nullptr;
            close(fd);
            m_clients.erase(fd);
        }
        return;
    }

    m_stat_bytes_out.fetch_add(static_cast<uint64_t>(cqe->res), std::memory_order_relaxed);

    // Check if more messages to send
    if (!conn->write_queue.empty())
    {
        flush_write_queue(conn);
    }
    else
    {
        if (conn->closing && !conn->read_pending)
        {
            if (fd == m_master_fd)
                m_master_fd = -1;
            unroute_client(fd);
            invoke_on_disconnect(fd);
            m_conn_idx[fd] = nullptr;
            close(fd);
            m_clients.erase(fd);
        }
    }
}

void server_instance::handle_udp_read(struct io_uring_cqe* cqe)
{
    if (cqe->res <= 0)
    {
        // Resubmit on error
        if (m_loop && m_udp_fd >= 0)
            m_loop->submit_recvmsg(m_udp_fd, &m_udp_recv_msg, &m_udp_recv_req);
        return;
    }

    // Register peer if new; skip processing if peer list is full
    if (find_or_add_peer(m_udp_recv_addr) < 0)
    {
        m_udp_recv_msg.msg_namelen = sizeof(m_udp_recv_addr);
        if (m_loop && m_udp_fd >= 0)
            m_loop->submit_recvmsg(m_udp_fd, &m_udp_recv_msg, &m_udp_recv_req);
        return;
    }

    // Extract message — whole datagram = one message
    std::string_view msg(m_udp_recv_buf, static_cast<size_t>(cqe->res));

    // Strip trailing newline if present
    if (!msg.empty() && msg.back() == '\n')
    {
        msg.remove_suffix(1);
        if (!msg.empty() && msg.back() == '\r')
            msg.remove_suffix(1);
    }

    if (!msg.empty())
        process_message(nullptr, msg);

    // Resubmit for next datagram
    m_udp_recv_msg.msg_namelen = sizeof(m_udp_recv_addr);
    if (m_loop && m_udp_fd >= 0)
        m_loop->submit_recvmsg(m_udp_fd, &m_udp_recv_msg, &m_udp_recv_req);
}

void server_instance::udp_broadcast(std::string_view msg, const struct sockaddr_in* exclude)
{
    if (m_udp_fd < 0)
        return;

    for (auto& peer : m_udp_peers)
    {
        if (exclude &&
            peer.addr.sin_addr.s_addr == exclude->sin_addr.s_addr &&
            peer.addr.sin_port == exclude->sin_port)
            continue;

        sendto(m_udp_fd, msg.data(), msg.size(), MSG_DONTWAIT,
               reinterpret_cast<const struct sockaddr*>(&peer.addr), sizeof(peer.addr));
    }
}

void server_instance::lua_disconnect(int client_fd)
{
    auto* conn = (client_fd >= 0 && client_fd < MAX_FDS)
                 ? m_conn_idx[client_fd] : nullptr;
    if (!conn || conn->closing) return;
    conn->closing = true;
    // SHUT_RD only: keeps the write side open so any queued message
    // (e.g. "AUTH FAIL" sent just before disconnect) still reaches the client.
    // If a pending read CQE exists, SHUT_RD triggers its EOF so handle_read
    // can clean up. If no ops are pending, handle_read's submit_next_read
    // branch handles the cleanup when it sees closing=true, write_pending=false.
    shutdown(client_fd, SHUT_RD);
}

std::string server_instance::lua_peer_ip(int client_fd)
{
    struct sockaddr_storage addr{};
    socklen_t len = sizeof(addr);
    if (getpeername(client_fd, reinterpret_cast<struct sockaddr*>(&addr), &len) != 0)
        return "";
    char ip[INET6_ADDRSTRLEN]{};
    if (addr.ss_family == AF_INET)
        inet_ntop(AF_INET,
            &reinterpret_cast<struct sockaddr_in*>(&addr)->sin_addr, ip, sizeof(ip));
    else if (addr.ss_family == AF_INET6)
        inet_ntop(AF_INET6,
            &reinterpret_cast<struct sockaddr_in6*>(&addr)->sin6_addr, ip, sizeof(ip));
    return ip;
}

void server_instance::invoke_on_websocket(int fd)
{
#ifndef SOCKETLEY_NO_LUA
    auto* lctx = lua();
    if (!lctx || !lctx->has_on_websocket()) return;
    auto* conn = (fd >= 0 && fd < MAX_FDS) ? m_conn_idx[fd] : nullptr;
    if (!conn) return;
    try {
        sol::table h = lctx->state().create_table();
        if (!conn->ws_cookie.empty())   h["cookie"]        = conn->ws_cookie;
        if (!conn->ws_origin.empty())   h["origin"]        = conn->ws_origin;
        if (!conn->ws_protocol.empty()) h["protocol"]      = conn->ws_protocol;
        if (!conn->ws_auth.empty())     h["authorization"] = conn->ws_auth;
        lctx->on_websocket()(fd, h);
    } catch (const sol::error& e) {
        fprintf(stderr, "[lua] on_websocket error: %s\n", e.what());
    }
#endif
}

server_instance::ws_headers_result server_instance::lua_ws_headers(int client_fd) const
{
    if (client_fd < 0 || client_fd >= MAX_FDS) return {};
    const auto* conn = m_conn_idx[client_fd];
    if (!conn || conn->ws != ws_active) return {};
    return {true, conn->ws_cookie, conn->ws_origin, conn->ws_protocol, conn->ws_auth};
}

void server_instance::lua_send_to(int client_id, std::string_view msg)
{
    if (!m_loop || m_udp)
        return;

    // Check direct connection first
    if (client_id >= 0 && client_id < MAX_FDS && m_conn_idx[client_id])
    {
        auto* conn = m_conn_idx[client_id];
        if (conn->closing)
            return;

        std::string full_str;
        full_str.reserve(msg.size() + 1);
        full_str.append(msg.data(), msg.size());
        if (full_str.empty() || full_str.back() != '\n')
            full_str += '\n';

        auto full_msg = std::make_shared<const std::string>(std::move(full_str));
        send_to(conn, full_msg);
        return;
    }

    // Check forwarded clients (send through parent server)
    auto fit = m_forwarded_clients.find(client_id);
    if (fit != m_forwarded_clients.end())
    {
        auto* mgr = get_runtime_manager();
        if (mgr)
        {
            auto* parent = mgr->get(fit->second);
            if (parent && parent->get_type() == runtime_server &&
                parent->get_state() == runtime_running)
            {
                static_cast<server_instance*>(parent)->send_to_client(client_id, msg);
            }
        }
    }
}

std::string server_instance::get_stats() const
{
    std::string base = runtime_instance::get_stats();
    std::ostringstream out;
    out << base
        << "peak_connections:" << m_stat_peak_connections << "\n"
        << "mode:" << static_cast<int>(m_mode) << "\n"
        << "udp:" << (m_udp ? "true" : "false") << "\n";
    if (m_mode == mode_master)
        out << "master_fd:" << m_master_fd << "\n";
    return out.str();
}

// ─── Client Routing ───

bool server_instance::route_client(int client_fd, std::string_view target_name)
{
    auto* mgr = get_runtime_manager();
    if (!mgr) return false;

    auto* target = mgr->get(target_name);
    if (!target || target->get_type() != runtime_server) return false;

    auto* sub = static_cast<server_instance*>(target);
    m_routes[client_fd] = std::string(target_name);
    sub->m_forwarded_clients[client_fd] = std::string(get_name());
    sub->invoke_on_connect(client_fd);
    return true;
}

bool server_instance::unroute_client(int client_fd)
{
    auto it = m_routes.find(client_fd);
    if (it == m_routes.end()) return false;

    auto* mgr = get_runtime_manager();
    if (mgr)
    {
        auto* target = mgr->get(it->second);
        if (target && target->get_type() == runtime_server)
        {
            auto* sub = static_cast<server_instance*>(target);
            sub->invoke_on_disconnect(client_fd);
            sub->m_forwarded_clients.erase(client_fd);
        }
    }
    m_routes.erase(it);
    return true;
}

std::string_view server_instance::get_client_route(int client_fd) const
{
    auto it = m_routes.find(client_fd);
    if (it == m_routes.end()) return {};
    return it->second;
}

void server_instance::process_forwarded_message(int client_fd, std::string_view msg,
                                                  std::string_view parent_name)
{
    m_stat_total_messages.fetch_add(1, std::memory_order_relaxed);
    invoke_on_client_message(client_fd, msg);
    invoke_on_message(msg);
}

void server_instance::remove_forwarded_client(int client_fd)
{
    m_forwarded_clients.erase(client_fd);
}

void server_instance::send_to_client(int client_fd, std::string_view msg)
{
    if (client_fd < 0 || client_fd >= MAX_FDS || !m_conn_idx[client_fd]) return;
    auto* conn = m_conn_idx[client_fd];
    if (conn->closing) return;

    std::string full(msg);
    if (full.empty() || full.back() != '\n') full += '\n';
    auto shared = std::make_shared<const std::string>(std::move(full));
    send_to(conn, shared);
}

bool server_instance::owner_send(int client_fd, std::string_view msg)
{
    auto owner_name = get_owner();
    if (owner_name.empty()) return false;

    auto* mgr = get_runtime_manager();
    if (!mgr) return false;

    auto* parent = mgr->get(owner_name);
    if (!parent || parent->get_type() != runtime_server ||
        parent->get_state() != runtime_running) return false;

    static_cast<server_instance*>(parent)->send_to_client(client_fd, msg);
    return true;
}

bool server_instance::owner_broadcast(std::string_view msg)
{
    auto owner_name = get_owner();
    if (owner_name.empty()) return false;

    auto* mgr = get_runtime_manager();
    if (!mgr) return false;

    auto* parent = mgr->get(owner_name);
    if (!parent || parent->get_type() != runtime_server ||
        parent->get_state() != runtime_running) return false;

    static_cast<server_instance*>(parent)->lua_broadcast(msg);
    return true;
}

int server_instance::find_or_add_peer(const struct sockaddr_in& addr)
{
    for (size_t i = 0; i < m_udp_peers.size(); i++)
    {
        if (m_udp_peers[i].addr.sin_addr.s_addr == addr.sin_addr.s_addr &&
            m_udp_peers[i].addr.sin_port == addr.sin_port)
            return static_cast<int>(i);
    }

    if (m_udp_peers.size() >= MAX_UDP_PEERS)
        return -1;

    m_udp_peers.push_back({addr});
    return static_cast<int>(m_udp_peers.size() - 1);
}

// ─── Lua client enumeration ───

std::vector<int> server_instance::lua_clients() const
{
    std::vector<int> result;
    result.reserve(m_clients.size());
    for (const auto& [fd, _] : m_clients)
        result.push_back(fd);
    return result;
}

void server_instance::lua_multicast(const std::vector<int>& fds, std::string_view msg)
{
    if (!m_loop || m_udp) return;
    auto shared = std::make_shared<const std::string>(msg);
    for (int fd : fds)
    {
        if (fd < 0 || fd >= MAX_FDS) continue;
        auto* conn = m_conn_idx[fd];
        if (!conn || conn->closing) continue;
        send_to(conn, shared);
    }
}

// ─── Lua per-connection metadata ───

void server_instance::lua_set_data(int fd, std::string_view key, std::string_view val)
{
    if (fd < 0 || fd >= MAX_FDS || !m_conn_idx[fd]) return;
    m_conn_idx[fd]->meta[std::string(key)] = std::string(val);
}

void server_instance::lua_del_data(int fd, std::string_view key)
{
    if (fd < 0 || fd >= MAX_FDS || !m_conn_idx[fd]) return;
    m_conn_idx[fd]->meta.erase(std::string(key));
}

std::string server_instance::lua_get_data(int fd, std::string_view key) const
{
    if (fd < 0 || fd >= MAX_FDS || !m_conn_idx[fd]) return "";
    const auto& m = m_conn_idx[fd]->meta;
    auto it = m.find(std::string(key));
    return (it != m.end()) ? it->second : "";
}

// ── socketley/runtime/client/client_instance.cpp ──



client_instance::client_instance(std::string_view name)
    : runtime_instance(runtime_client, name), m_mode(client_mode_inout), m_loop(nullptr), m_connected(false)
{
    m_conn.fd = -1;
    std::memset(&m_conn.read_req, 0, sizeof(m_conn.read_req));
    std::memset(&m_conn.write_req, 0, sizeof(m_conn.write_req));
}

client_instance::~client_instance()
{
    if (m_conn.fd >= 0)
        close(m_conn.fd);
}

void client_instance::set_mode(client_mode mode)
{
    m_mode = mode;
}

client_mode client_instance::get_mode() const
{
    return m_mode;
}

void client_instance::set_udp(bool udp)
{
    m_udp = udp;
}

bool client_instance::is_udp() const
{
    return m_udp;
}

size_t client_instance::get_connection_count() const
{
    return m_connected ? 1 : 0;
}

bool client_instance::try_connect()
{
    std::string host = "127.0.0.1";
    uint16_t port = get_port();
    if (port == 0)
        port = 8000;

    auto target = get_target();
    if (!target.empty())
    {
        auto colon = target.rfind(':');
        if (colon != std::string_view::npos)
        {
            host = std::string(target.substr(0, colon));
            auto port_sv = target.substr(colon + 1);
            std::from_chars(port_sv.data(), port_sv.data() + port_sv.size(), port);
        }
    }

    m_conn.fd = socket(AF_INET, m_udp ? SOCK_DGRAM : SOCK_STREAM, 0);
    if (m_conn.fd < 0)
        return false;

    if (!m_udp)
    {
        int opt = 1;
        setsockopt(m_conn.fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));
    }

    struct sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);

    if (inet_pton(AF_INET, host.c_str(), &addr.sin_addr) <= 0)
    {
        close(m_conn.fd);
        m_conn.fd = -1;
        return false;
    }

    if (connect(m_conn.fd, reinterpret_cast<struct sockaddr*>(&addr), sizeof(addr)) < 0)
    {
        close(m_conn.fd);
        m_conn.fd = -1;
        return false;
    }

    m_connected = true;
    m_reconnect_attempt = 0;
    m_stat_total_connections.fetch_add(1, std::memory_order_relaxed);
    invoke_on_connect(m_conn.fd);
    m_conn.partial.clear();
    m_conn.partial.reserve(8192);
    m_conn.closing = false;
    m_conn.read_pending = false;
    m_conn.write_pending = false;

    m_conn.read_req = { op_read, m_conn.fd, m_conn.read_buf, sizeof(m_conn.read_buf), this };
    m_conn.write_req = { op_write, m_conn.fd, nullptr, 0, this };

    if (m_mode != client_mode_out)
    {
        m_conn.read_pending = true;
        if (m_use_provided_bufs)
            m_loop->submit_read_provided(m_conn.fd, BUF_GROUP_ID, &m_conn.read_req);
        else
            m_loop->submit_read(m_conn.fd, m_conn.read_buf, sizeof(m_conn.read_buf), &m_conn.read_req);
    }

    return true;
}

void client_instance::schedule_reconnect()
{
    int max = get_reconnect();
    if (max < 0 || !m_loop)
        return; // Reconnect disabled

    if (max > 0 && m_reconnect_attempt >= max)
        return; // Max attempts reached

    // Exponential backoff: min(1s * 2^attempt, 30s) with jitter
    int base_sec = 1 << std::min(m_reconnect_attempt, 4); // 1,2,4,8,16
    int delay_sec = std::min(base_sec, 30);
    // Simple jitter: add 0-500ms
    int jitter_ms = (m_reconnect_attempt * 137) % 500;

    m_timeout_ts.tv_sec = delay_sec;
    m_timeout_ts.tv_nsec = jitter_ms * 1000000LL;

    m_timeout_req = { op_timeout, -1, nullptr, 0, this };
    m_reconnect_pending = true;
    m_loop->submit_timeout(&m_timeout_ts, &m_timeout_req);
}

bool client_instance::setup(event_loop& loop)
{
    m_loop = &loop;

    m_use_provided_bufs = loop.setup_buf_ring(BUF_GROUP_ID, BUF_COUNT, BUF_SIZE);

    if (!try_connect())
    {
        // If reconnect enabled, schedule first attempt
        if (get_reconnect() >= 0)
        {
            schedule_reconnect();
            return true; // Setup "succeeds" — we'll connect later
        }
        return false;
    }

    return true;
}

void client_instance::teardown(event_loop& loop)
{
    if (m_conn.fd >= 0)
    {
        close(m_conn.fd);
        m_conn.fd = -1;
    }

    m_connected = false;
    m_conn.partial.clear();
    m_loop = nullptr;
}

void client_instance::on_cqe(struct io_uring_cqe* cqe)
{
    auto* req = static_cast<io_request*>(io_uring_cqe_get_data(cqe));
    if (!req || !m_loop)
        return;

    switch (req->type)
    {
        case op_read:
        case op_read_provided:
            handle_read(cqe);
            break;
        case op_write:
            handle_write(cqe);
            break;
        case op_timeout:
            handle_timeout(cqe);
            break;
        default:
            break;
    }
}

void client_instance::handle_read(struct io_uring_cqe* cqe)
{
    m_conn.read_pending = false;

    bool is_provided = (m_conn.read_req.type == op_read_provided);

    if (cqe->res <= 0)
    {
        // Return provided buffer if kernel allocated one before error
        if (is_provided && (cqe->flags & IORING_CQE_F_BUFFER))
        {
            uint16_t buf_id = cqe->flags >> IORING_CQE_BUFFER_SHIFT;
            m_loop->return_buf(BUF_GROUP_ID, buf_id);
        }

        // ENOBUFS: buffer pool exhausted — fall back to regular read
        if (is_provided && cqe->res == -ENOBUFS)
        {
            m_conn.read_pending = true;
            m_loop->submit_read(m_conn.fd, m_conn.read_buf, sizeof(m_conn.read_buf), &m_conn.read_req);
            return;
        }

        // Connection closed or error — defer if write pending
        if (m_conn.write_pending)
        {
            m_conn.closing = true;
        }
        else
        {
            invoke_on_disconnect(m_conn.fd);
            close(m_conn.fd);
            m_conn.fd = -1;
            m_connected = false;
            schedule_reconnect();
        }
        return;
    }

    m_stat_bytes_in.fetch_add(static_cast<uint64_t>(cqe->res), std::memory_order_relaxed);

    if (m_udp)
    {
        // UDP: whole datagram = one message, no line parsing
        const char* buf_data = m_conn.read_buf;
        size_t buf_len = static_cast<size_t>(cqe->res);

        if (is_provided)
        {
            uint16_t buf_id = cqe->flags >> IORING_CQE_BUFFER_SHIFT;
            buf_data = m_loop->get_buf_ptr(BUF_GROUP_ID, buf_id);
            if (!buf_data)
                goto resubmit;

            std::string_view msg(buf_data, buf_len);
            if (!msg.empty() && msg.back() == '\n')
            {
                msg.remove_suffix(1);
                if (!msg.empty() && msg.back() == '\r')
                    msg.remove_suffix(1);
            }
            if (!msg.empty())
                process_message(msg);

            m_loop->return_buf(BUF_GROUP_ID, buf_id);
        }
        else
        {
            std::string_view msg(buf_data, buf_len);
            if (!msg.empty() && msg.back() == '\n')
            {
                msg.remove_suffix(1);
                if (!msg.empty() && msg.back() == '\r')
                    msg.remove_suffix(1);
            }
            if (!msg.empty())
                process_message(msg);
        }
        goto resubmit;
    }

    if (is_provided)
    {
        uint16_t buf_id = cqe->flags >> IORING_CQE_BUFFER_SHIFT;
        char* buf_ptr = m_loop->get_buf_ptr(BUF_GROUP_ID, buf_id);
        if (buf_ptr)
        {
            m_conn.partial.append(buf_ptr, cqe->res);
            m_loop->return_buf(BUF_GROUP_ID, buf_id);
        }
    }
    else
    {
        m_conn.partial.append(m_conn.read_buf, cqe->res);
    }

    if (m_conn.partial.size() > client_tcp_connection::MAX_PARTIAL_SIZE)
    {
        m_conn.closing = true;
        goto resubmit;
    }

    {
    size_t scan_from = 0;
    size_t pos;
    while ((pos = m_conn.partial.find('\n', scan_from)) != std::string::npos)
    {
        std::string_view line(m_conn.partial.data() + scan_from, pos - scan_from);

        if (!line.empty() && line.back() == '\r')
            line.remove_suffix(1);

        if (!line.empty())
            process_message(line);

        scan_from = pos + 1;
    }

    if (scan_from > 0)
    {
        if (scan_from >= m_conn.partial.size())
            m_conn.partial.clear();
        else
            m_conn.partial.erase(0, scan_from);
    }
    }

resubmit:
    if (m_loop && m_connected && !m_conn.closing)
    {
        m_conn.read_pending = true;
        if (m_use_provided_bufs)
            m_loop->submit_read_provided(m_conn.fd, BUF_GROUP_ID, &m_conn.read_req);
        else
            m_loop->submit_read(m_conn.fd, m_conn.read_buf, sizeof(m_conn.read_buf), &m_conn.read_req);
    }
}

void client_instance::handle_write(struct io_uring_cqe* cqe)
{
    m_conn.write_pending = false;

    if (cqe->res <= 0)
    {
        m_conn.closing = true;
        if (!m_conn.read_pending)
        {
            invoke_on_disconnect(m_conn.fd);
            close(m_conn.fd);
            m_conn.fd = -1;
            m_connected = false;
            schedule_reconnect();
        }
        return;
    }

    m_stat_bytes_out.fetch_add(static_cast<uint64_t>(cqe->res), std::memory_order_relaxed);

    if (m_conn.closing && !m_conn.read_pending)
    {
        invoke_on_disconnect(m_conn.fd);
        close(m_conn.fd);
        m_conn.fd = -1;
        m_connected = false;
    }
}

void client_instance::handle_timeout(struct io_uring_cqe* cqe)
{
    m_reconnect_pending = false;

    // io_uring timeout fires with -ETIME on expiration
    if (cqe->res != -ETIME && cqe->res != 0)
        return;

    m_reconnect_attempt++;

    if (try_connect())
        return; // Reconnected successfully

    // Failed — schedule another attempt
    schedule_reconnect();
}

void client_instance::process_message(std::string_view msg)
{
    m_stat_total_messages.fetch_add(1, std::memory_order_relaxed);
    print_bash_message(msg);
    notify_interactive(msg);

    switch (m_mode)
    {
        case client_mode_inout:
        case client_mode_in:
        {
            invoke_on_message(msg);
            break;
        }
        case client_mode_out:
            break;
        default:
            break;
    }
}

void client_instance::lua_send(std::string_view msg)
{
    if (!m_loop || !m_connected || m_mode == client_mode_in)
        return;

    invoke_on_send(msg);

    if (m_udp)
    {
        // UDP: send as-is, no newline needed
        send_to_server(msg);
        return;
    }

    std::string full_msg;
    full_msg.reserve(msg.size() + 1);
    full_msg = msg;
    if (full_msg.empty() || full_msg.back() != '\n')
        full_msg += '\n';

    send_to_server(full_msg);
}

void client_instance::send_to_server(std::string_view msg)
{
    if (!m_loop || !m_connected || m_mode == client_mode_in || m_conn.write_pending || m_conn.closing)
        return;

    m_conn.write_buf = std::string(msg);
    m_conn.write_req.buffer = m_conn.write_buf.data();
    m_conn.write_req.length = static_cast<uint32_t>(m_conn.write_buf.size());

    m_conn.write_pending = true;
    m_loop->submit_write(m_conn.fd, m_conn.write_buf.data(),
        static_cast<uint32_t>(m_conn.write_buf.size()), &m_conn.write_req);
}

// ── socketley/runtime/proxy/proxy_instance.cpp ──



proxy_instance::proxy_instance(std::string_view name)
    : runtime_instance(runtime_proxy, name)
{
    std::memset(&m_accept_addr, 0, sizeof(m_accept_addr));
    m_accept_addrlen = sizeof(m_accept_addr);
    m_accept_req = { op_accept, -1, nullptr, 0, this };
}

proxy_instance::~proxy_instance()
{
    if (m_listen_fd >= 0)
        close(m_listen_fd);
}

void proxy_instance::add_backend(std::string_view addr)
{
    backend_info b;
    b.address = std::string(addr);
    m_backends.push_back(std::move(b));
}

void proxy_instance::clear_backends() { m_backends.clear(); }
void proxy_instance::set_protocol(proxy_protocol p) { m_protocol = p; }
void proxy_instance::set_strategy(proxy_strategy s) { m_strategy = s; }
void proxy_instance::set_runtime_manager(runtime_manager* mgr) { runtime_instance::set_runtime_manager(mgr); }
proxy_protocol proxy_instance::get_protocol() const { return m_protocol; }
proxy_strategy proxy_instance::get_strategy() const { return m_strategy; }
const std::vector<backend_info>& proxy_instance::get_backends() const { return m_backends; }

size_t proxy_instance::get_connection_count() const
{
    return m_clients.size();
}

bool proxy_instance::resolve_backend(backend_info& b)
{
    // Group references (@groupname) are resolved dynamically at connection time
    if (b.address.size() > 1 && b.address[0] == '@')
    {
        b.is_group = true;
        return true;
    }

    auto colon = b.address.find(':');
    if (colon != std::string::npos)
    {
        b.resolved_host = b.address.substr(0, colon);
        auto port_str = b.address.data() + colon + 1;
        auto port_end = b.address.data() + b.address.size();
        std::from_chars(port_str, port_end, b.resolved_port);
        return true;
    }

    if (!get_runtime_manager())
        return false;

    auto* inst = get_runtime_manager()->get(b.address);
    if (!inst)
        return false;

    uint16_t port = inst->get_port();
    if (port == 0)
        return false;

    b.resolved_host = "127.0.0.1";
    b.resolved_port = port;
    return true;
}

bool proxy_instance::setup(event_loop& loop)
{
    // Clear any connections left from a previous stop() — safe to free now that
    // all in-flight CQEs have been processed (we're starting a fresh run).
    m_clients.clear();
    m_backend_conns.clear();

    m_loop = &loop;

    if (m_backends.empty())
        return false;

    for (auto& b : m_backends)
    {
        if (!resolve_backend(b))
            return false;
    }

    m_use_provided_bufs = loop.setup_buf_ring(BUF_GROUP_ID, BUF_COUNT, BUF_SIZE);

    // Pre-build prefix once to avoid per-request allocation
    m_prefix = "/" + std::string(get_name()) + "/";

    uint16_t port = get_port();
    if (port == 0)
        port = 8080;

    m_listen_fd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);
    if (m_listen_fd < 0)
        return false;

    int opt = 1;
    setsockopt(m_listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    setsockopt(m_listen_fd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));
    setsockopt(m_listen_fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));

    struct sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(port);

    if (bind(m_listen_fd, reinterpret_cast<struct sockaddr*>(&addr), sizeof(addr)) < 0)
    {
        close(m_listen_fd);
        m_listen_fd = -1;
        return false;
    }

    if (listen(m_listen_fd, 4096) < 0)
    {
        close(m_listen_fd);
        m_listen_fd = -1;
        return false;
    }

    if (event_loop::supports_multishot_accept())
    {
        m_accept_req.type = op_multishot_accept;
        loop.submit_multishot_accept(m_listen_fd, &m_accept_req);
        m_multishot_active = true;
    }
    else
    {
        m_accept_req.type = op_accept;
        loop.submit_accept(m_listen_fd, &m_accept_addr, &m_accept_addrlen, &m_accept_req);
        m_multishot_active = false;
    }

    if (get_idle_timeout() > 0)
    {
        m_idle_sweep_ts.tv_sec = 30;
        m_idle_sweep_ts.tv_nsec = 0;
        m_idle_sweep_req = { op_timeout, -1, nullptr, 0, this };
        m_loop->submit_timeout(&m_idle_sweep_ts, &m_idle_sweep_req);
    }

    return true;
}

void proxy_instance::teardown(event_loop& loop)
{
    // Null out all req->owner pointers FIRST so any stale CQEs that arrive after
    // teardown (e.g. from SQPOLL processing a write SQE that was queued late) are
    // safely skipped by the event loop's `if (req && req->owner)` guard.  Without
    // this, a CQE processed in the same batch as the "remove" command could read
    // req->owner from already-freed connection memory → SEGFAULT.
    m_accept_req.owner = nullptr;
    m_idle_sweep_req.owner = nullptr;
    for (auto& [fd, conn] : m_clients)
    {
        conn->read_req.owner  = nullptr;
        conn->write_req.owner = nullptr;
    }
    for (auto& [fd, conn] : m_backend_conns)
    {
        conn->read_req.owner  = nullptr;
        conn->write_req.owner = nullptr;
    }

    // Shutdown the listen socket before closing — same reasoning as server_instance:
    // shutdown() forces the pending io_uring accept op to complete synchronously,
    // placing its CQE in the ring before the deferred-delete timeout SQE is submitted.
    if (m_listen_fd >= 0)
    {
        shutdown(m_listen_fd, SHUT_RDWR);
        close(m_listen_fd);
        m_listen_fd = -1;
    }

    // Drain: flush pending write queues before closing
    if (get_drain())
    {
        for (auto& [fd, conn] : m_clients)
        {
            while (!conn->write_queue.empty())
            {
                auto& msg = conn->write_queue.front();
                if (::write(fd, msg->data(), msg->size()) < 0) break;
                conn->write_queue.pop();
            }
        }
    }

    for (auto& [fd, conn] : m_backend_conns)
    {
        shutdown(fd, SHUT_RDWR);
        close(fd);
    }
    // Do NOT clear m_backend_conns here — connection objects must stay alive until
    // all their pending io_uring CQEs are processed (deferred-delete timeout).

    for (auto& [fd, conn] : m_clients)
    {
        // backend_fd is already closed above via m_backend_conns loop; skip it.
        shutdown(fd, SHUT_RDWR);
        close(fd);
    }
    // Do NOT clear m_clients here for the same reason.

    m_loop = nullptr;
    m_multishot_active = false;
}

void proxy_instance::on_cqe(struct io_uring_cqe* cqe)
{
    auto* req = static_cast<io_request*>(io_uring_cqe_get_data(cqe));
    if (!req || !m_loop)
        return;

    switch (req->type)
    {
        case op_accept:
        case op_multishot_accept:
            handle_accept(cqe);
            break;
        case op_read:
        case op_read_provided:
        {
            if (m_clients.count(req->fd))
                handle_client_read(cqe, req);
            else if (m_backend_conns.count(req->fd))
                handle_backend_read(cqe, req);
            break;
        }
        case op_write:
        case op_writev:
        {
            if (m_clients.count(req->fd))
                handle_client_write(cqe, req);
            else if (m_backend_conns.count(req->fd))
                handle_backend_write(cqe, req);
            break;
        }
        case op_timeout:
            if (req == &m_idle_sweep_req)
            {
                auto now = std::chrono::steady_clock::now();
                auto timeout = std::chrono::seconds(get_idle_timeout());
                for (auto& [cfd, cconn] : m_clients)
                {
                    if (!cconn->closing && (now - cconn->last_activity) > timeout)
                    {
                        cconn->closing = true;
                        shutdown(cfd, SHUT_RD);
                    }
                }
                m_loop->submit_timeout(&m_idle_sweep_ts, &m_idle_sweep_req);
            }
            // Accept backoff expired — resubmit accept
            else if (req == &m_accept_backoff_req && m_listen_fd >= 0)
            {
                if (m_multishot_active)
                    m_loop->submit_multishot_accept(m_listen_fd, &m_accept_req);
                else
                {
                    m_accept_addrlen = sizeof(m_accept_addr);
                    m_loop->submit_accept(m_listen_fd, &m_accept_addr, &m_accept_addrlen, &m_accept_req);
                }
            }
            break;
        default:
            break;
    }
}

void proxy_instance::handle_accept(struct io_uring_cqe* cqe)
{
    int client_fd = cqe->res;

    if (client_fd >= 0)
    {
        if (get_max_connections() > 0 && m_clients.size() >= get_max_connections())
        {
            close(client_fd);
            goto proxy_resubmit_accept;
        }

        int opt = 1;
        setsockopt(client_fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));

        m_stat_total_connections.fetch_add(1, std::memory_order_relaxed);

        auto conn = std::make_unique<proxy_client_connection>();
        conn->fd = client_fd;
        conn->partial.reserve(8192);
        conn->read_req = { op_read, client_fd, conn->read_buf, sizeof(conn->read_buf), this };
        conn->write_req = { op_write, client_fd, nullptr, 0, this };

        auto* ptr = conn.get();
        m_clients[client_fd] = std::move(conn);

        ptr->last_activity = std::chrono::steady_clock::now();

        ptr->read_pending = true;
        if (m_use_provided_bufs)
            m_loop->submit_read_provided(client_fd, BUF_GROUP_ID, &ptr->read_req);
        else
            m_loop->submit_read(client_fd, ptr->read_buf, sizeof(ptr->read_buf), &ptr->read_req);
    }

    // EMFILE/ENFILE: backoff 100ms to avoid CPU spin when fd limit is hit
    if (client_fd == -EMFILE || client_fd == -ENFILE)
    {
        m_accept_backoff_ts.tv_sec = 0;
        m_accept_backoff_ts.tv_nsec = 100000000LL;
        m_accept_backoff_req = { op_timeout, -1, nullptr, 0, this };
        m_loop->submit_timeout(&m_accept_backoff_ts, &m_accept_backoff_req);
        return;
    }

proxy_resubmit_accept:
    if (m_multishot_active)
    {
        if (!(cqe->flags & IORING_CQE_F_MORE))
        {
            if (m_listen_fd >= 0)
                m_loop->submit_multishot_accept(m_listen_fd, &m_accept_req);
        }
    }
    else
    {
        if (m_listen_fd >= 0)
        {
            m_accept_addrlen = sizeof(m_accept_addr);
            m_loop->submit_accept(m_listen_fd, &m_accept_addr, &m_accept_addrlen, &m_accept_req);
        }
    }
}

void proxy_instance::handle_client_read(struct io_uring_cqe* cqe, io_request* req)
{
    int fd = req->fd;
    auto it = m_clients.find(fd);
    if (it == m_clients.end())
        return;

    auto* conn = it->second.get();
    conn->read_pending = false;

    bool is_provided = (req->type == op_read_provided);

    if (cqe->res <= 0)
    {
        // Return provided buffer if kernel allocated one before error
        if (is_provided && (cqe->flags & IORING_CQE_F_BUFFER))
        {
            uint16_t buf_id = cqe->flags >> IORING_CQE_BUFFER_SHIFT;
            m_loop->return_buf(BUF_GROUP_ID, buf_id);
        }

        // ENOBUFS: buffer pool exhausted — fall back to regular read
        if (is_provided && cqe->res == -ENOBUFS)
        {
            conn->read_pending = true;
            m_loop->submit_read(fd, conn->read_buf, sizeof(conn->read_buf), &conn->read_req);
            return;
        }

        close_pair(fd, conn->backend_fd);
        return;
    }

    conn->last_activity = std::chrono::steady_clock::now();

    // Extract read data
    char* read_data;
    uint16_t buf_id = 0;
    if (is_provided)
    {
        buf_id = cqe->flags >> IORING_CQE_BUFFER_SHIFT;
        read_data = m_loop->get_buf_ptr(BUF_GROUP_ID, buf_id);
        if (!read_data)
        {
            close_pair(fd, conn->backend_fd);
            return;
        }
    }
    else
    {
        read_data = conn->read_buf;
    }

    if (m_protocol == protocol_tcp)
    {
        // TCP mode: connect on first read, then forward raw bytes
        if (conn->backend_fd < 0)
        {
            auto target = select_and_resolve_backend(conn);
            if (!connect_to_backend(conn, target))
            {
                if (is_provided)
                    m_loop->return_buf(BUF_GROUP_ID, buf_id);
                close_pair(fd, -1);
                return;
            }
        }

        std::string_view data(read_data, cqe->res);
        forward_to_backend(conn, data);
        if (is_provided)
            m_loop->return_buf(BUF_GROUP_ID, buf_id);

        if (!conn->closing)
        {
            conn->read_pending = true;
            if (m_use_provided_bufs)
                m_loop->submit_read_provided(fd, BUF_GROUP_ID, &conn->read_req);
            else
                m_loop->submit_read(fd, conn->read_buf, sizeof(conn->read_buf), &conn->read_req);
        }
        else if (!conn->write_pending)
        {
            // Closing and no more pending ops — clean up now.
            close_pair(fd, conn->backend_fd);
        }
        return;
    }

    // HTTP mode
    conn->partial.append(read_data, cqe->res);
    if (is_provided)
        m_loop->return_buf(BUF_GROUP_ID, buf_id);

    if (conn->partial.size() > proxy_client_connection::MAX_PARTIAL_SIZE)
    {
        close_pair(fd, conn->backend_fd);
        return;
    }

    if (!conn->header_parsed)
    {
        if (!parse_http_request_line(conn))
        {
            // Need more data
            conn->read_pending = true;
            if (m_use_provided_bufs)
                m_loop->submit_read_provided(fd, BUF_GROUP_ID, &conn->read_req);
            else
                m_loop->submit_read(fd, conn->read_buf, sizeof(conn->read_buf), &conn->read_req);
            return;
        }

        conn->header_parsed = true;

        // Check path prefix (m_prefix = "/<name>/", strip trailing slash for bare match)
        std::string_view bare = std::string_view(m_prefix).substr(0, m_prefix.size() - 1);
        if (!conn->path.starts_with(m_prefix) && conn->path != bare)
        {
            send_error(conn, "404 Not Found", "Not Found\n");
            return;
        }

        // Strip prefix
        std::string new_path;
        if (conn->path == bare)
            new_path = "/";
        else
            new_path = conn->path.substr(m_prefix.size() - 1); // Keep leading /

        // Select and connect to backend
        auto target = select_and_resolve_backend(conn);
        if (!connect_to_backend(conn, target))
        {
            send_error(conn, "502 Bad Gateway", "Bad Gateway\n");
            return;
        }

        // Rewrite request and forward
        std::string rewritten = rewrite_http_request(conn, new_path);
        forward_to_backend(conn, rewritten);
    }
    else
    {
        // Subsequent data (request body) — forward as-is
        forward_to_backend(conn, conn->partial);
        conn->partial.clear();
    }

    if (!conn->closing)
    {
        conn->read_pending = true;
        if (m_use_provided_bufs)
            m_loop->submit_read_provided(fd, BUF_GROUP_ID, &conn->read_req);
        else
            m_loop->submit_read(fd, conn->read_buf, sizeof(conn->read_buf), &conn->read_req);
    }
    else if (!conn->write_pending)
    {
        // Closing and no more pending ops — clean up now.
        close_pair(fd, conn->backend_fd);
    }
}

void proxy_instance::handle_backend_read(struct io_uring_cqe* cqe, io_request* req)
{
    int fd = req->fd;
    auto it = m_backend_conns.find(fd);
    if (it == m_backend_conns.end())
        return;

    auto* conn = it->second.get();
    conn->read_pending = false;

    bool is_provided = (req->type == op_read_provided);

    if (cqe->res <= 0)
    {
        // Return provided buffer if kernel allocated one before error
        if (is_provided && (cqe->flags & IORING_CQE_F_BUFFER))
        {
            uint16_t buf_id = cqe->flags >> IORING_CQE_BUFFER_SHIFT;
            m_loop->return_buf(BUF_GROUP_ID, buf_id);
        }

        // ENOBUFS: buffer pool exhausted — fall back to regular read
        if (is_provided && cqe->res == -ENOBUFS)
        {
            conn->read_pending = true;
            m_loop->submit_read(fd, conn->read_buf, sizeof(conn->read_buf), &conn->read_req);
            return;
        }

        close_pair(conn->client_fd, fd);
        return;
    }

    if (is_provided)
    {
        uint16_t buf_id = cqe->flags >> IORING_CQE_BUFFER_SHIFT;
        char* buf_ptr = m_loop->get_buf_ptr(BUF_GROUP_ID, buf_id);
        if (buf_ptr)
        {
            std::string_view data(buf_ptr, cqe->res);
            forward_to_client(conn, data);
            m_loop->return_buf(BUF_GROUP_ID, buf_id);
        }
    }
    else
    {
        std::string_view data(conn->read_buf, cqe->res);
        forward_to_client(conn, data);
    }

    if (!conn->closing)
    {
        conn->read_pending = true;
        if (m_use_provided_bufs)
            m_loop->submit_read_provided(fd, BUF_GROUP_ID, &conn->read_req);
        else
            m_loop->submit_read(fd, conn->read_buf, sizeof(conn->read_buf), &conn->read_req);
    }
    else if (!conn->write_pending)
    {
        // Closing and no more pending ops — clean up now.
        close_pair(conn->client_fd, fd);
    }
}

bool proxy_instance::parse_http_request_line(proxy_client_connection* conn)
{
    auto pos = conn->partial.find("\r\n");
    if (pos == std::string::npos)
        return false;

    std::string line = conn->partial.substr(0, pos);

    // Parse: METHOD SP PATH SP VERSION
    auto sp1 = line.find(' ');
    if (sp1 == std::string::npos)
        return false;

    auto sp2 = line.find(' ', sp1 + 1);
    if (sp2 == std::string::npos)
        return false;

    conn->method = line.substr(0, sp1);
    conn->path = line.substr(sp1 + 1, sp2 - sp1 - 1);
    conn->version = line.substr(sp2 + 1);

    return true;
}

std::string proxy_instance::rewrite_http_request(proxy_client_connection* conn,
                                                  std::string_view new_path)
{
    // Find end of request line
    auto pos = conn->partial.find("\r\n");
    std::string result;
    result.reserve(conn->method.size() + 1 + new_path.size() + 1
                   + conn->version.size() + conn->partial.size() - pos);
    result += conn->method;
    result += ' ';
    result += new_path;
    result += ' ';
    result += conn->version;
    result += conn->partial.substr(pos); // includes \r\n and rest of headers+body
    conn->partial.clear();
    return result;
}

resolved_backend proxy_instance::select_and_resolve_backend(proxy_client_connection* conn)
{
    // Build expanded pool of all available backends
    std::vector<resolved_backend> pool;
    pool.reserve(m_backends.size());

    for (const auto& b : m_backends)
    {
        if (b.is_group)
        {
            auto* mgr = get_runtime_manager();
            if (mgr)
            {
                std::string_view group_name(b.address.data() + 1, b.address.size() - 1);

                // Local group members
                auto members = mgr->get_by_group(group_name);
                for (auto* inst : members)
                {
                    uint16_t port = inst->get_port();
                    if (port > 0)
                        pool.push_back({"127.0.0.1", port});
                }

                // Remote group members (from cluster discovery)
                auto* cd = mgr->get_cluster_discovery();
                if (cd)
                {
                    auto remotes = cd->get_remote_group(group_name);
                    for (auto& ep : remotes)
                        pool.push_back({std::move(ep.host), ep.port});
                }
            }
        }
        else
        {
            pool.push_back({b.resolved_host, b.resolved_port});
        }
    }

    if (pool.empty())
        return {};

    if (pool.size() == 1)
        return pool[0];

    if (m_strategy == strategy_lua && lua() && lua()->has_on_route())
    {
#ifndef SOCKETLEY_NO_LUA
        sol::object result;
        if (m_protocol == protocol_http)
            result = lua()->on_route()(conn->method, conn->path);
        else
            result = lua()->on_route()();

        if (result.is<int>())
        {
            int idx = result.as<int>();
            if (idx >= 0 && static_cast<size_t>(idx) < pool.size())
                return pool[static_cast<size_t>(idx)];
        }
#endif
        // Fallback to round-robin
    }

    if (m_strategy == strategy_random)
    {
        std::uniform_int_distribution<size_t> dist(0, pool.size() - 1);
        return pool[dist(m_rng)];
    }

    // round-robin (default, also fallback for lua)
    size_t idx = m_rr_index % pool.size();
    ++m_rr_index;
    return pool[idx];
}

bool proxy_instance::connect_to_backend(proxy_client_connection* conn, const resolved_backend& target)
{
    if (target.port == 0)
        return false;

    // Use getaddrinfo for hostname resolution (supports Docker DNS, IPv4/IPv6)
    char port_str[8];
    auto [pend, pec] = std::to_chars(port_str, port_str + sizeof(port_str), target.port);
    *pend = '\0';

    struct addrinfo hints{};
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    struct addrinfo* result = nullptr;
    if (getaddrinfo(target.host.c_str(), port_str, &hints, &result) != 0 || !result)
        return false;

    int bfd = socket(result->ai_family, SOCK_STREAM, 0);
    if (bfd < 0)
    {
        freeaddrinfo(result);
        return false;
    }

    int opt = 1;
    setsockopt(bfd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));

    if (::connect(bfd, result->ai_addr, result->ai_addrlen) < 0)
    {
        close(bfd);
        freeaddrinfo(result);
        return false;
    }

    freeaddrinfo(result);

    conn->backend_fd = bfd;

    auto bconn = std::make_unique<proxy_backend_connection>();
    bconn->fd = bfd;
    bconn->client_fd = conn->fd;
    bconn->read_req = { op_read, bfd, bconn->read_buf, sizeof(bconn->read_buf), this };
    bconn->write_req = { op_write, bfd, nullptr, 0, this };

    auto* ptr = bconn.get();
    m_backend_conns[bfd] = std::move(bconn);

    ptr->read_pending = true;
    if (m_use_provided_bufs)
        m_loop->submit_read_provided(bfd, BUF_GROUP_ID, &ptr->read_req);
    else
        m_loop->submit_read(bfd, ptr->read_buf, sizeof(ptr->read_buf), &ptr->read_req);

    return true;
}

void proxy_instance::close_pair(int client_fd, int backend_fd)
{
    if (backend_fd >= 0)
    {
        auto bit = m_backend_conns.find(backend_fd);
        if (bit != m_backend_conns.end())
        {
            auto* bconn = bit->second.get();
            if (bconn->read_pending || bconn->write_pending)
            {
                bconn->closing = true;
            }
            else
            {
                // Clear the stale reference on the client side so a later
                // close_pair call does not re-close this (now-freed) fd.
                auto cit = m_clients.find(bconn->client_fd);
                if (cit != m_clients.end())
                    cit->second->backend_fd = -1;
                close(backend_fd);
                m_backend_conns.erase(bit);
            }
        }
        // else: backend was already closed and erased from the map.
        // Do NOT call close() here — the fd integer may have been reused by
        // the kernel for a new connection, and closing it would corrupt that
        // connection (or even close the proxy's own listen socket).
    }

    if (client_fd >= 0)
    {
        auto it = m_clients.find(client_fd);
        if (it != m_clients.end())
        {
            auto* conn = it->second.get();

            // Also close the other side of the pair
            if (conn->backend_fd >= 0 && conn->backend_fd != backend_fd)
            {
                auto bit2 = m_backend_conns.find(conn->backend_fd);
                if (bit2 != m_backend_conns.end())
                {
                    auto* bconn2 = bit2->second.get();
                    if (bconn2->read_pending || bconn2->write_pending)
                    {
                        bconn2->closing = true;
                    }
                    else
                    {
                        close(conn->backend_fd);
                        m_backend_conns.erase(bit2);
                    }
                }
                // else: already closed and erased — do not close again.
                conn->backend_fd = -1;
            }

            if (conn->read_pending || conn->write_pending)
            {
                conn->closing = true;
            }
            else
            {
                close(client_fd);
                m_clients.erase(it);
            }
        }
        // else: client was already closed and erased from the map.
        // Do NOT call close() here for the same fd-reuse reason as above.
    }
}

std::string proxy_instance::get_stats() const
{
    std::string base = runtime_instance::get_stats();
    std::ostringstream out;
    out << base
        << "backend_connections:" << m_backend_conns.size() << "\n"
        << "protocol:" << (m_protocol == protocol_http ? "http" : "tcp") << "\n"
        << "backends:" << m_backends.size() << "\n";
    return out.str();
}

void proxy_instance::forward_to_backend(proxy_client_connection* conn, std::string_view data)
{
    if (conn->backend_fd < 0 || !m_loop)
        return;

    auto it = m_backend_conns.find(conn->backend_fd);
    if (it == m_backend_conns.end())
        return;

    auto* bconn = it->second.get();
    if (bconn->closing)
        return;

#ifndef SOCKETLEY_NO_LUA
    std::string hook_storage;
    std::string_view effective = data;
    if (auto* lctx = lua(); lctx && lctx->has_on_proxy_request())
    {
        try {
            sol::object r = lctx->on_proxy_request()(conn->fd, std::string(data));
            if (r.get_type() == sol::type::nil) return;   // drop
            if (r.is<std::string>()) {
                hook_storage = r.as<std::string>();
                effective = hook_storage;
            }
        } catch (const sol::error& e) {
            fprintf(stderr, "[lua] on_proxy_request error: %s\n", e.what());
        }
    }
    auto msg = std::make_shared<const std::string>(effective);
#else
    auto msg = std::make_shared<const std::string>(data);
#endif

    if (bconn->write_queue.size() >= proxy_backend_connection::MAX_WRITE_QUEUE)
    {
        bconn->closing = true;
        return;
    }

    bconn->write_queue.push(msg);

    if (!bconn->write_pending)
        flush_backend_write_queue(bconn);
}

void proxy_instance::forward_to_client(proxy_backend_connection* conn, std::string_view data)
{
    if (!m_loop)
        return;

    auto it = m_clients.find(conn->client_fd);
    if (it == m_clients.end())
        return;

    auto* cconn = it->second.get();
    if (cconn->closing)
        return;

#ifndef SOCKETLEY_NO_LUA
    std::string hook_storage;
    std::string_view effective = data;
    if (auto* lctx = lua(); lctx && lctx->has_on_proxy_response())
    {
        try {
            sol::object r = lctx->on_proxy_response()(conn->client_fd, std::string(data));
            if (r.get_type() == sol::type::nil) return;   // drop
            if (r.is<std::string>()) {
                hook_storage = r.as<std::string>();
                effective = hook_storage;
            }
        } catch (const sol::error& e) {
            fprintf(stderr, "[lua] on_proxy_response error: %s\n", e.what());
        }
    }
    auto msg = std::make_shared<const std::string>(effective);
#else
    auto msg = std::make_shared<const std::string>(data);
#endif

    if (cconn->write_queue.size() >= proxy_client_connection::MAX_WRITE_QUEUE)
    {
        cconn->closing = true;
        return;
    }

    cconn->write_queue.push(msg);

    if (!cconn->write_pending)
        flush_client_write_queue(cconn);
}

void proxy_instance::send_error(proxy_client_connection* conn, std::string_view status, std::string_view body)
{
    if (!m_loop || conn->closing)
        return;

    std::string response;
    response.reserve(9 + status.size() + 18 + 8 + 23 + body.size());
    char clen_buf[24];
    auto [clen_end, clen_ec] = std::to_chars(clen_buf, clen_buf + sizeof(clen_buf), body.size());
    response += "HTTP/1.1 ";
    response += status;
    response += "\r\nContent-Length: ";
    response.append(clen_buf, static_cast<size_t>(clen_end - clen_buf));
    response += "\r\nConnection: close\r\n\r\n";
    response += body;

    auto msg = std::make_shared<const std::string>(std::move(response));
    conn->write_queue.push(msg);
    conn->closing = true;

    if (!conn->write_pending)
        flush_client_write_queue(conn);
}

void proxy_instance::flush_client_write_queue(proxy_client_connection* conn)
{
    if (!m_loop || conn->write_queue.empty())
        return;

    uint32_t count = 0;
    while (!conn->write_queue.empty() && count < proxy_client_connection::MAX_WRITE_BATCH)
    {
        conn->write_batch[count] = std::move(conn->write_queue.front());
        conn->write_queue.pop();

        conn->write_iovs[count].iov_base = const_cast<char*>(conn->write_batch[count]->data());
        conn->write_iovs[count].iov_len = conn->write_batch[count]->size();
        count++;
    }

    conn->write_batch_count = count;
    conn->write_pending = true;

    if (count == 1)
    {
        conn->write_req.type = op_write;
        m_loop->submit_write(conn->fd, conn->write_batch[0]->data(),
            static_cast<uint32_t>(conn->write_batch[0]->size()), &conn->write_req);
    }
    else
    {
        conn->write_req.type = op_writev;
        m_loop->submit_writev(conn->fd, conn->write_iovs, count, &conn->write_req);
    }
}

void proxy_instance::flush_backend_write_queue(proxy_backend_connection* conn)
{
    if (!m_loop || conn->write_queue.empty())
        return;

    uint32_t count = 0;
    while (!conn->write_queue.empty() && count < proxy_backend_connection::MAX_WRITE_BATCH)
    {
        conn->write_batch[count] = std::move(conn->write_queue.front());
        conn->write_queue.pop();

        conn->write_iovs[count].iov_base = const_cast<char*>(conn->write_batch[count]->data());
        conn->write_iovs[count].iov_len = conn->write_batch[count]->size();
        count++;
    }

    conn->write_batch_count = count;
    conn->write_pending = true;

    if (count == 1)
    {
        conn->write_req.type = op_write;
        m_loop->submit_write(conn->fd, conn->write_batch[0]->data(),
            static_cast<uint32_t>(conn->write_batch[0]->size()), &conn->write_req);
    }
    else
    {
        conn->write_req.type = op_writev;
        m_loop->submit_writev(conn->fd, conn->write_iovs, count, &conn->write_req);
    }
}

void proxy_instance::handle_client_write(struct io_uring_cqe* cqe, io_request* req)
{
    int fd = req->fd;
    auto it = m_clients.find(fd);
    if (it == m_clients.end())
        return;

    auto* conn = it->second.get();
    conn->write_pending = false;

    // Release batch references
    for (uint32_t i = 0; i < conn->write_batch_count; i++)
        conn->write_batch[i].reset();
    conn->write_batch_count = 0;

    if (cqe->res <= 0)
    {
        close_pair(fd, conn->backend_fd);
        return;
    }

    if (!conn->write_queue.empty())
    {
        flush_client_write_queue(conn);
    }
    else if (conn->closing && !conn->read_pending)
    {
        close_pair(fd, conn->backend_fd);
    }
}

void proxy_instance::handle_backend_write(struct io_uring_cqe* cqe, io_request* req)
{
    int fd = req->fd;
    auto it = m_backend_conns.find(fd);
    if (it == m_backend_conns.end())
        return;

    auto* conn = it->second.get();
    conn->write_pending = false;

    // Release batch references
    for (uint32_t i = 0; i < conn->write_batch_count; i++)
        conn->write_batch[i].reset();
    conn->write_batch_count = 0;

    if (cqe->res <= 0)
    {
        close_pair(conn->client_fd, fd);
        return;
    }

    if (!conn->write_queue.empty())
    {
        flush_backend_write_queue(conn);
    }
    else if (conn->closing && !conn->read_pending)
    {
        close_pair(conn->client_fd, fd);
    }
}

// ── socketley/runtime/cache/cache_instance.cpp ──



cache_instance::cache_instance(std::string_view name)
    : runtime_instance(runtime_cache, name), m_listen_fd(-1), m_loop(nullptr)
{
    std::memset(&m_accept_addr, 0, sizeof(m_accept_addr));
    m_accept_addrlen = sizeof(m_accept_addr);
    m_accept_req = { op_accept, -1, nullptr, 0, this };
}

cache_instance::~cache_instance()
{
    if (m_listen_fd >= 0)
        close(m_listen_fd);
}

void cache_instance::set_persistent(std::string_view path)
{
    // Validate parent directory exists
    std::string p(path);
    auto slash = p.rfind('/');
    if (slash != std::string::npos && slash > 0)
    {
        std::string parent = p.substr(0, slash);
        struct stat st;
        if (stat(parent.c_str(), &st) != 0 || !S_ISDIR(st.st_mode))
            return; // Silent reject — parent dir doesn't exist
    }
    m_persistent_path = path;
}

std::string_view cache_instance::get_persistent() const
{
    return m_persistent_path;
}

void cache_instance::set_mode(cache_mode mode)
{
    m_mode = mode;
}

cache_mode cache_instance::get_mode() const
{
    return m_mode;
}

size_t cache_instance::get_connection_count() const
{
    return m_clients.size();
}

bool cache_instance::setup(event_loop& loop)
{
    // Clear connections from a previous stop() — safe to free now.
    m_clients.clear();

    m_loop = &loop;

    uint16_t port = get_port();
    if (port == 0)
        port = 9000;

    m_listen_fd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);
    if (m_listen_fd < 0)
        return false;

    int opt = 1;
    setsockopt(m_listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    setsockopt(m_listen_fd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));
    setsockopt(m_listen_fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));

    struct sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(port);

    if (bind(m_listen_fd, reinterpret_cast<struct sockaddr*>(&addr), sizeof(addr)) < 0)
    {
        close(m_listen_fd);
        m_listen_fd = -1;
        return false;
    }

    if (listen(m_listen_fd, 4096) < 0)
    {
        close(m_listen_fd);
        m_listen_fd = -1;
        return false;
    }

    if (!m_persistent_path.empty())
        m_store.load(m_persistent_path);

    // Connect to master if follower
    if (m_repl_role == repl_follower && !m_replicate_target.empty())
        connect_to_master();

    m_use_provided_bufs = loop.setup_buf_ring(BUF_GROUP_ID, BUF_COUNT, BUF_SIZE);

    if (event_loop::supports_multishot_accept())
    {
        m_accept_req.type = op_multishot_accept;
        loop.submit_multishot_accept(m_listen_fd, &m_accept_req);
        m_multishot_active = true;
    }
    else
    {
        m_accept_req.type = op_accept;
        loop.submit_accept(m_listen_fd, &m_accept_addr, &m_accept_addrlen, &m_accept_req);
        m_multishot_active = false;
    }

    // Start periodic TTL sweep (100 ms)
    m_ttl_ts = {0, 100'000'000};
    m_ttl_req = {op_timeout, -1, nullptr, 0, this};
    loop.submit_timeout(&m_ttl_ts, &m_ttl_req);

    if (get_idle_timeout() > 0)
    {
        m_idle_sweep_ts.tv_sec = 30;
        m_idle_sweep_ts.tv_nsec = 0;
        m_idle_sweep_req = { op_timeout, -1, nullptr, 0, this };
        m_loop->submit_timeout(&m_idle_sweep_ts, &m_idle_sweep_req);
    }

    return true;
}

void cache_instance::teardown(event_loop& loop)
{
    if (!m_persistent_path.empty())
        m_store.save(m_persistent_path);

    // Shutdown the listen socket before closing — forces the pending multishot
    // accept CQE to complete synchronously, before the deferred-delete timeout.
    if (m_listen_fd >= 0)
    {
        shutdown(m_listen_fd, SHUT_RDWR);
        close(m_listen_fd);
        m_listen_fd = -1;
    }

    // Drain: flush pending write queues with blocking writes
    if (get_drain())
    {
        for (auto& [fd, conn] : m_clients)
        {
            // Flush response_buf first
            if (!conn->response_buf.empty())
                if (::write(fd, conn->response_buf.data(), conn->response_buf.size()) < 0) break;
            while (!conn->write_queue.empty())
            {
                auto& msg = conn->write_queue.front();
                if (::write(fd, msg.data(), msg.size()) < 0) break;
                conn->write_queue.pop();
            }
        }
    }

    for (auto& [fd, conn] : m_clients)
    {
        shutdown(fd, SHUT_RDWR);
        close(fd);
    }
    // Do NOT clear m_clients here — connection objects must stay alive until the
    // deferred-delete timeout fires and all pending CQEs have been processed.

    // Close replication connections
    if (m_master_fd >= 0)
    {
        shutdown(m_master_fd, SHUT_RDWR);
        close(m_master_fd);
        m_master_fd = -1;
    }
    for (int fd : m_follower_fds)
    {
        shutdown(fd, SHUT_RDWR);
        close(fd);
    }
    m_follower_fds.clear();

    m_ttl_req.owner = nullptr;
    m_idle_sweep_req.owner = nullptr;
    m_loop = nullptr;
    m_multishot_active = false;
}

void cache_instance::on_cqe(struct io_uring_cqe* cqe)
{
    auto* req = static_cast<io_request*>(io_uring_cqe_get_data(cqe));
    if (!req || !m_loop)
        return;

    // Periodic TTL sweep timer
    if (req == &m_ttl_req)
    {
        auto expired_keys = m_store.sweep_expired();
#ifndef SOCKETLEY_NO_LUA
        if (lua() && lua()->has_on_expire() && !expired_keys.empty())
        {
            for (const auto& key : expired_keys)
            {
                try { lua()->on_expire()(key); }
                catch (const sol::error& e)
                { std::cerr << "[lua] on_expire error: " << e.what() << "\n"; }
            }
        }
#endif
        m_loop->submit_timeout(&m_ttl_ts, &m_ttl_req);
        return;
    }

    // Check if this is a read from master (replication)
    if (req->fd == m_master_fd && m_master_fd >= 0 &&
        (req->type == op_read || req->type == op_read_provided))
    {
        handle_master_read(cqe);
        return;
    }

    switch (req->type)
    {
        case op_accept:
        case op_multishot_accept:
            handle_accept(cqe);
            break;
        case op_read:
        case op_read_provided:
            handle_read(cqe, req);
            break;
        case op_write:
        case op_writev:
            handle_write(cqe, req);
            break;
        case op_timeout:
            if (req == &m_idle_sweep_req)
            {
                auto now = std::chrono::steady_clock::now();
                auto timeout = std::chrono::seconds(get_idle_timeout());
                for (auto& [cfd, cconn] : m_clients)
                {
                    if (!cconn->closing && (now - cconn->last_activity) > timeout)
                    {
                        cconn->closing = true;
                        shutdown(cfd, SHUT_RD);
                    }
                }
                m_loop->submit_timeout(&m_idle_sweep_ts, &m_idle_sweep_req);
            }
            // Accept backoff expired — resubmit accept
            else if (req == &m_accept_backoff_req && m_listen_fd >= 0)
            {
                if (m_multishot_active)
                    m_loop->submit_multishot_accept(m_listen_fd, &m_accept_req);
                else
                {
                    m_accept_addrlen = sizeof(m_accept_addr);
                    m_loop->submit_accept(m_listen_fd, &m_accept_addr, &m_accept_addrlen, &m_accept_req);
                }
            }
            break;
        default:
            break;
    }
}

void cache_instance::handle_accept(struct io_uring_cqe* cqe)
{
    int client_fd = cqe->res;

    if (client_fd >= 0)
    {
        // Reject fds beyond our O(1) lookup table — they'd become zombie connections
        if (client_fd >= MAX_FDS)
        {
            close(client_fd);
            goto cache_resubmit_accept;
        }

        if (get_max_connections() > 0 && m_clients.size() >= get_max_connections())
        {
            close(client_fd);
            goto cache_resubmit_accept;
        }

        int opt = 1;
        setsockopt(client_fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));

        m_stat_total_connections.fetch_add(1, std::memory_order_relaxed);

        auto conn = std::make_unique<client_connection>();
        conn->fd = client_fd;
        conn->partial.reserve(4096);
        conn->response_buf.reserve(4096);
        conn->read_req = { op_read, client_fd, conn->read_buf, sizeof(conn->read_buf), this };
        conn->write_req = { op_write, client_fd, nullptr, 0, this };

        auto* ptr = conn.get();
        m_clients[client_fd] = std::move(conn);
        if (client_fd < MAX_FDS)
            m_conn_idx[client_fd] = ptr;

        // Initialize rate limiting
        double rl = get_rate_limit();
        if (rl > 0)
        {
            ptr->rl_max = rl;
            ptr->rl_tokens = rl;
            ptr->rl_last = std::chrono::steady_clock::now();
        }

        ptr->last_activity = std::chrono::steady_clock::now();

        ptr->read_pending = true;
        if (m_use_provided_bufs)
            m_loop->submit_read_provided(client_fd, BUF_GROUP_ID, &ptr->read_req);
        else
            m_loop->submit_read(client_fd, ptr->read_buf, sizeof(ptr->read_buf), &ptr->read_req);
    }

    // EMFILE/ENFILE: backoff 100ms to avoid CPU spin when fd limit is hit
    if (client_fd == -EMFILE || client_fd == -ENFILE)
    {
        m_accept_backoff_ts.tv_sec = 0;
        m_accept_backoff_ts.tv_nsec = 100000000LL;
        m_accept_backoff_req = { op_timeout, -1, nullptr, 0, this };
        m_loop->submit_timeout(&m_accept_backoff_ts, &m_accept_backoff_req);
        return;
    }

cache_resubmit_accept:
    if (m_multishot_active)
    {
        if (!(cqe->flags & IORING_CQE_F_MORE))
        {
            if (m_listen_fd >= 0)
                m_loop->submit_multishot_accept(m_listen_fd, &m_accept_req);
        }
    }
    else
    {
        if (m_listen_fd >= 0)
        {
            m_accept_addrlen = sizeof(m_accept_addr);
            m_loop->submit_accept(m_listen_fd, &m_accept_addr, &m_accept_addrlen, &m_accept_req);
        }
    }
}

void cache_instance::handle_read(struct io_uring_cqe* cqe, io_request* req)
{
    int fd = req->fd;
    if (fd < 0 || fd >= MAX_FDS || !m_conn_idx[fd])
        return;
    auto* conn = m_conn_idx[fd];
    conn->read_pending = false;

    bool is_provided = (req->type == op_read_provided);

    if (cqe->res <= 0)
    {
        // Return provided buffer if kernel allocated one before error
        if (is_provided && (cqe->flags & IORING_CQE_F_BUFFER))
        {
            uint16_t buf_id = cqe->flags >> IORING_CQE_BUFFER_SHIFT;
            m_loop->return_buf(BUF_GROUP_ID, buf_id);
        }

        // ENOBUFS: buffer pool exhausted — fall back to regular read
        if (is_provided && cqe->res == -ENOBUFS)
        {
            conn->read_pending = true;
            m_loop->submit_read(fd, conn->read_buf, sizeof(conn->read_buf), &conn->read_req);
            return;
        }

        // Connection closed or error — defer if write pending
        m_store.unsubscribe_all(fd);
        if (conn->write_pending)
        {
            conn->closing = true;
        }
        else
        {
            close(fd);
            if (fd >= 0 && fd < MAX_FDS) m_conn_idx[fd] = nullptr;
            m_clients.erase(fd);
        }
        return;
    }

    conn->last_activity = std::chrono::steady_clock::now();

    if (is_provided)
    {
        uint16_t buf_id = cqe->flags >> IORING_CQE_BUFFER_SHIFT;
        char* buf_ptr = m_loop->get_buf_ptr(BUF_GROUP_ID, buf_id);
        if (buf_ptr)
        {
            conn->partial.append(buf_ptr, cqe->res);
            m_loop->return_buf(BUF_GROUP_ID, buf_id);
        }
    }
    else
    {
        conn->partial.append(conn->read_buf, cqe->res);
    }

    if (conn->partial.size() > client_connection::MAX_PARTIAL_SIZE)
    {
        conn->closing = true;
        return;
    }

    // Auto-detect RESP mode on first data
    if (!conn->resp_detected && !conn->partial.empty())
    {
        conn->resp_detected = true;
        if (conn->partial[0] == '*' || m_resp_forced)
            conn->resp_mode = true;
    }

    if (conn->resp_mode)
    {
        process_resp(conn);
    }
    else
    {
        size_t scan_from = 0;
        size_t pos;
        while ((pos = conn->partial.find('\n', scan_from)) != std::string::npos)
        {
            std::string_view line(conn->partial.data() + scan_from, pos - scan_from);

            if (!line.empty() && line.back() == '\r')
                line.remove_suffix(1);

            process_command(conn, line);

            scan_from = pos + 1;
        }

        if (scan_from > 0)
        {
            if (scan_from >= conn->partial.size())
                conn->partial.clear();
            else
                conn->partial.erase(0, scan_from);
        }
    }

    // Flush accumulated responses as single write
    flush_responses(conn);

    if (m_loop && !conn->closing)
    {
        conn->read_pending = true;
        if (m_use_provided_bufs)
            m_loop->submit_read_provided(fd, BUF_GROUP_ID, &conn->read_req);
        else
            m_loop->submit_read(fd, conn->read_buf, sizeof(conn->read_buf), &conn->read_req);
    }
}

void cache_instance::handle_write(struct io_uring_cqe* cqe, io_request* req)
{
    int fd = req->fd;
    if (fd < 0 || fd >= MAX_FDS || !m_conn_idx[fd])
        return;
    auto* conn = m_conn_idx[fd];
    conn->write_pending = false;

    // Release batch buffers
    for (uint32_t i = 0; i < conn->write_batch_count; i++)
        conn->write_batch[i] = {};
    conn->write_batch_count = 0;

    if (cqe->res <= 0)
    {
        conn->closing = true;
        if (!conn->read_pending)
        {
            close(fd);
            if (fd >= 0 && fd < MAX_FDS) m_conn_idx[fd] = nullptr;
            m_clients.erase(fd);
        }
        return;
    }

    // Flush remaining queued messages
    if (!conn->write_queue.empty())
    {
        flush_write_queue(conn);
    }
    else
    {
        if (conn->closing && !conn->read_pending)
        {
            close(fd);
            if (fd >= 0 && fd < MAX_FDS) m_conn_idx[fd] = nullptr;
            m_clients.erase(fd);
        }
    }
}

// ─── Helper: parse int from string_view ───

static bool parse_int_sv(std::string_view sv, int& out)
{
    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), out);
    return ec == std::errc{} && ptr == sv.data() + sv.size();
}

std::string cache_instance::execute(std::string_view line)
{
    client_connection dummy{};
    dummy.fd = -1;
    dummy.rl_max = 0;
    process_command(&dummy, line);
    return std::move(dummy.response_buf);
}

// Zero-allocation integer append for text-mode responses
static inline void append_int_nl(std::string& buf, int64_t v)
{
    char tmp[24];
    auto [end, ec] = std::to_chars(tmp, tmp + sizeof(tmp), v);
    buf.append(tmp, static_cast<size_t>(end - tmp));
    buf.push_back('\n');
}

void cache_instance::process_command(client_connection* conn, std::string_view line)
{
    if (line.empty())
        return;

    // Global rate limit check (across all connections)
    if (!check_global_rate_limit())
    {
        conn->response_buf.append("error: rate limited\n", 20);
        return;
    }

    // Rate limit check
    if (conn->rl_max > 0)
    {
        auto now = std::chrono::steady_clock::now();
        double elapsed = std::chrono::duration<double>(now - conn->rl_last).count();
        conn->rl_last = now;
        conn->rl_tokens += elapsed * conn->rl_max;
        if (conn->rl_tokens > conn->rl_max)
            conn->rl_tokens = conn->rl_max;
        if (conn->rl_tokens < 1.0)
        {
            conn->response_buf.append("error: rate limited\n", 20);
            return;
        }
        conn->rl_tokens -= 1.0;
    }

    m_stat_commands++;
    m_stat_total_messages.fetch_add(1, std::memory_order_relaxed);

    size_t first_space = line.find(' ');
    std::string_view cmd = (first_space != std::string_view::npos)
        ? line.substr(0, first_space) : line;

    std::string_view args = (first_space != std::string_view::npos)
        ? line.substr(first_space + 1) : std::string_view{};

    auto& rb = conn->response_buf;

    // Extract key from args (up to first space)
    auto extract_key = [](std::string_view a) -> std::pair<std::string_view, std::string_view> {
        size_t sp = a.find(' ');
        if (sp == std::string_view::npos)
            return {a, {}};
        return {a.substr(0, sp), a.substr(sp + 1)};
    };

    switch (fnv1a_lower(cmd))
    {
        // ─── Strings ───

        case fnv1a("set"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            size_t space = args.find(' ');
            if (space == std::string_view::npos)
            {
                rb.append("usage: set key value\n", 21);
                return;
            }
            auto key = args.substr(0, space);
            auto value = args.substr(space + 1);
            m_store.check_expiry(key);
            if (!m_store.set(key, value))
                rb.append("error: type conflict\n", 21);
            else
            {
                rb.append("ok\n", 3);
                replicate_command(line);
#ifndef SOCKETLEY_NO_LUA
                if (lua() && lua()->has_on_write())
                {
                    try { lua()->on_write()(std::string(key), std::string(value), 0); }
                    catch (const sol::error& e)
                    { std::cerr << "[lua] on_write error: " << e.what() << "\n"; }
                }
#endif
            }
            break;
        }
        case fnv1a("get"):
        {
            m_store.check_expiry(args);
            const std::string* val = m_store.get_ptr(args);
            if (val)
            {
                m_stat_get_hits++;
                rb.append(*val);
                rb.push_back('\n');
            }
            else
            {
#ifndef SOCKETLEY_NO_LUA
                if (lua() && lua()->has_on_miss())
                {
                    try
                    {
                        auto res = lua()->on_miss()(std::string(args));
                        sol::optional<std::string> fetched = res.get<sol::optional<std::string>>(0);
                        if (fetched && !fetched->empty())
                        {
                            int ttl = 0;
                            sol::optional<int> ttl_opt = res.get<sol::optional<int>>(1);
                            if (ttl_opt) ttl = *ttl_opt;
                            m_store.set(args, *fetched);
                            if (ttl > 0) m_store.set_expiry(args, ttl);
                            m_stat_get_hits++;
                            rb.append(*fetched);
                            rb.push_back('\n');
                            break;
                        }
                    }
                    catch (const sol::error& e)
                    { std::cerr << "[lua] on_miss error: " << e.what() << "\n"; }
                }
#endif
                m_stat_get_misses++;
                rb.append("nil\n", 4);
            }
            break;
        }
        case fnv1a("del"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            m_store.check_expiry(args);
            if (m_store.del(args))
            {
                rb.append("ok\n", 3);
                replicate_command(line);
#ifndef SOCKETLEY_NO_LUA
                if (lua() && lua()->has_on_delete())
                {
                    try { lua()->on_delete_cb()(std::string(args)); }
                    catch (const sol::error& e)
                    { std::cerr << "[lua] on_delete error: " << e.what() << "\n"; }
                }
#endif
            }
            else
                rb.append("nil\n", 4);
            break;
        }
        case fnv1a("exists"):
        {
            m_store.check_expiry(args);
            rb.append(m_store.exists(args) ? "1\n" : "0\n");
            break;
        }
        case fnv1a("incr"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            if (args.empty()) { rb.append("usage: incr key\n", 17); return; }
            int64_t result = 0;
            if (!m_store.incr(args, 1, result))
                rb.append("error: not an integer\n", 22);
            else
            {
                append_int_nl(rb, result);
                replicate_command(line);
            }
            break;
        }
        case fnv1a("decr"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            if (args.empty()) { rb.append("usage: decr key\n", 17); return; }
            int64_t result = 0;
            if (!m_store.incr(args, -1, result))
                rb.append("error: not an integer\n", 22);
            else
            {
                append_int_nl(rb, result);
                replicate_command(line);
            }
            break;
        }
        case fnv1a("incrby"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            auto [key, delta_str] = extract_key(args);
            if (key.empty() || delta_str.empty()) { rb.append("usage: incrby key delta\n", 24); return; }
            int64_t delta = 0;
            auto [p, e] = std::from_chars(delta_str.data(), delta_str.data() + delta_str.size(), delta);
            if (e != std::errc{}) { rb.append("error: invalid delta\n", 21); return; }
            int64_t result = 0;
            if (!m_store.incr(key, delta, result))
                rb.append("error: not an integer\n", 22);
            else
            {
                append_int_nl(rb, result);
                replicate_command(line);
            }
            break;
        }
        case fnv1a("decrby"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            auto [key, delta_str] = extract_key(args);
            if (key.empty() || delta_str.empty()) { rb.append("usage: decrby key delta\n", 24); return; }
            int64_t delta = 0;
            auto [p2, e2] = std::from_chars(delta_str.data(), delta_str.data() + delta_str.size(), delta);
            if (e2 != std::errc{}) { rb.append("error: invalid delta\n", 21); return; }
            int64_t result = 0;
            if (!m_store.incr(key, -delta, result))
                rb.append("error: not an integer\n", 22);
            else
            {
                append_int_nl(rb, result);
                replicate_command(line);
            }
            break;
        }
        case fnv1a("append"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            auto [key, suffix] = extract_key(args);
            if (key.empty() || suffix.empty()) { rb.append("usage: append key value\n", 24); return; }
            size_t newlen = m_store.append(key, suffix);
            if (newlen == std::string::npos)
                rb.append("error: type conflict\n", 21);
            else
            {
                append_int_nl(rb, static_cast<int64_t>(newlen));
                replicate_command(line);
            }
            break;
        }
        case fnv1a("strlen"):
        {
            m_store.check_expiry(args);
            append_int_nl(rb, static_cast<int64_t>(m_store.strlen_key(args)));
            break;
        }
        case fnv1a("getset"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            auto [key, newval] = extract_key(args);
            if (key.empty() || newval.empty()) { rb.append("usage: getset key newvalue\n", 27); return; }
            m_store.check_expiry(key);
            bool had_key = m_store.exists(key);
            std::string oldval;
            if (!m_store.getset(key, newval, oldval))
                rb.append("error: type conflict\n", 21);
            else
            {
                if (had_key) { rb.append(oldval); rb.push_back('\n'); }
                else rb.append("nil\n", 4);
                replicate_command(line);
            }
            break;
        }
        case fnv1a("mget"):
        {
            // MGET key1 key2 ... → one value per line (nil if missing), then "end\n"
            std::string_view rest = args;
            while (!rest.empty())
            {
                size_t sp = rest.find(' ');
                std::string_view key = (sp == std::string_view::npos) ? rest : rest.substr(0, sp);
                m_store.check_expiry(key);
                const std::string* val = m_store.get_ptr(key);
                if (val) { rb.append(*val); rb.push_back('\n'); }
                else rb.append("nil\n", 4);
                if (sp == std::string_view::npos) break;
                rest = rest.substr(sp + 1);
            }
            rb.append("end\n", 4);
            break;
        }
        case fnv1a("mset"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            // MSET key1 val1 key2 val2 ...
            std::string_view rest = args;
            while (!rest.empty())
            {
                size_t sp1 = rest.find(' ');
                if (sp1 == std::string_view::npos) break;
                std::string_view key = rest.substr(0, sp1);
                rest = rest.substr(sp1 + 1);
                size_t sp2 = rest.find(' ');
                std::string_view val = (sp2 == std::string_view::npos) ? rest : rest.substr(0, sp2);
                m_store.check_expiry(key);
                m_store.set(key, val);
#ifndef SOCKETLEY_NO_LUA
                if (lua() && lua()->has_on_write())
                {
                    try { lua()->on_write()(std::string(key), std::string(val), 0); }
                    catch (const sol::error& e)
                    { std::cerr << "[lua] on_write error: " << e.what() << "\n"; }
                }
#endif
                if (sp2 == std::string_view::npos) break;
                rest = rest.substr(sp2 + 1);
            }
            rb.append("ok\n", 3);
            replicate_command(line);
            break;
        }
        case fnv1a("type"):
        {
            m_store.check_expiry(args);
            rb.append(m_store.type(args));
            rb.push_back('\n');
            break;
        }
        case fnv1a("keys"):
        {
            std::string_view pattern = args.empty() ? std::string_view("*") : args;
            std::vector<std::string_view> result;
            m_store.keys(pattern, result);
            for (auto& k : result) { rb.append(k); rb.push_back('\n'); }
            rb.append("end\n", 4);
            break;
        }

        // ─── Lists ───

        case fnv1a("lpush"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            auto [key, val] = extract_key(args);
            if (key.empty() || val.empty())
            {
                rb.append("usage: lpush key value\n", 23);
                return;
            }
            m_store.check_expiry(key);
            if (!m_store.lpush(key, val))
                rb.append("error: type conflict\n", 21);
            else
            {
                rb.append("ok\n", 3);
                replicate_command(line);
            }
            break;
        }
        case fnv1a("rpush"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            auto [key, val] = extract_key(args);
            if (key.empty() || val.empty())
            {
                rb.append("usage: rpush key value\n", 23);
                return;
            }
            m_store.check_expiry(key);
            if (!m_store.rpush(key, val))
                rb.append("error: type conflict\n", 21);
            else
            {
                rb.append("ok\n", 3);
                replicate_command(line);
            }
            break;
        }
        case fnv1a("lpop"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            m_store.check_expiry(args);
            std::string val;
            if (m_store.lpop(args, val))
            {
                rb.append(val);
                rb.push_back('\n');
            }
            else
                rb.append("nil\n", 4);
            break;
        }
        case fnv1a("rpop"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            m_store.check_expiry(args);
            std::string val;
            if (m_store.rpop(args, val))
            {
                rb.append(val);
                rb.push_back('\n');
            }
            else
                rb.append("nil\n", 4);
            break;
        }
        case fnv1a("llen"):
        {
            m_store.check_expiry(args);
            append_int_nl(rb, m_store.llen(args));
            break;
        }
        case fnv1a("lindex"):
        {
            auto [key, idx_str] = extract_key(args);
            if (key.empty() || idx_str.empty())
            {
                rb.append("usage: lindex key index\n", 24);
                return;
            }
            m_store.check_expiry(key);
            int idx;
            if (!parse_int_sv(idx_str, idx))
            {
                rb.append("error: invalid index\n", 21);
                return;
            }
            const std::string* val = m_store.lindex(key, idx);
            if (val)
            {
                rb.append(*val);
                rb.push_back('\n');
            }
            else
                rb.append("nil\n", 4);
            break;
        }
        case fnv1a("lrange"):
        {
            auto [key, rest] = extract_key(args);
            if (key.empty() || rest.empty())
            {
                rb.append("usage: lrange key start stop\n", 29);
                return;
            }
            auto [start_str, stop_str] = extract_key(rest);
            if (start_str.empty() || stop_str.empty())
            {
                rb.append("usage: lrange key start stop\n", 29);
                return;
            }
            m_store.check_expiry(key);
            int start, stop;
            if (!parse_int_sv(start_str, start) || !parse_int_sv(stop_str, stop))
            {
                rb.append("error: invalid index\n", 21);
                return;
            }
            const auto* deq = m_store.list_ptr(key);
            if (!deq || deq->empty())
            {
                rb.append("end\n", 4);
                return;
            }
            int len = static_cast<int>(deq->size());
            if (start < 0) start += len;
            if (stop < 0) stop += len;
            if (start < 0) start = 0;
            if (stop >= len) stop = len - 1;
            for (int i = start; i <= stop; i++)
            {
                rb.append((*deq)[static_cast<size_t>(i)]);
                rb.push_back('\n');
            }
            rb.append("end\n", 4);
            break;
        }

        // ─── Sets ───

        case fnv1a("sadd"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            auto [key, member] = extract_key(args);
            if (key.empty() || member.empty())
            {
                rb.append("usage: sadd key member\n", 23);
                return;
            }
            m_store.check_expiry(key);
            int result = m_store.sadd(key, member);
            if (result < 0)
                rb.append("error: type conflict\n", 21);
            else if (result == 0)
                rb.append("exists\n", 7);
            else
            {
                rb.append("ok\n", 3);
                replicate_command(line);
            }
            break;
        }
        case fnv1a("srem"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            auto [key, member] = extract_key(args);
            if (key.empty() || member.empty())
            {
                rb.append("usage: srem key member\n", 23);
                return;
            }
            m_store.check_expiry(key);
            rb.append(m_store.srem(key, member) ? "ok\n" : "nil\n");
            break;
        }
        case fnv1a("sismember"):
        {
            auto [key, member] = extract_key(args);
            if (key.empty() || member.empty())
            {
                rb.append("usage: sismember key member\n", 28);
                return;
            }
            m_store.check_expiry(key);
            rb.append(m_store.sismember(key, member) ? "1\n" : "0\n");
            break;
        }
        case fnv1a("scard"):
        {
            m_store.check_expiry(args);
            append_int_nl(rb, m_store.scard(args));
            break;
        }
        case fnv1a("smembers"):
        {
            m_store.check_expiry(args);
            const auto* s = m_store.set_ptr(args);
            if (!s || s->empty())
            {
                rb.append("end\n", 4);
                return;
            }
            for (const auto& member : *s)
            {
                rb.append(member);
                rb.push_back('\n');
            }
            rb.append("end\n", 4);
            break;
        }

        // ─── Hashes ───

        case fnv1a("hset"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            auto [key, rest] = extract_key(args);
            if (key.empty() || rest.empty())
            {
                rb.append("usage: hset key field value\n", 28);
                return;
            }
            auto [field, val] = extract_key(rest);
            if (field.empty() || val.empty())
            {
                rb.append("usage: hset key field value\n", 28);
                return;
            }
            m_store.check_expiry(key);
            if (!m_store.hset(key, field, val))
                rb.append("error: type conflict\n", 21);
            else
            {
                rb.append("ok\n", 3);
                replicate_command(line);
            }
            break;
        }
        case fnv1a("hget"):
        {
            auto [key, field] = extract_key(args);
            if (key.empty() || field.empty())
            {
                rb.append("usage: hget key field\n", 22);
                return;
            }
            m_store.check_expiry(key);
            const std::string* val = m_store.hget(key, field);
            if (val)
            {
                rb.append(*val);
                rb.push_back('\n');
            }
            else
                rb.append("nil\n", 4);
            break;
        }
        case fnv1a("hdel"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            auto [key, field] = extract_key(args);
            if (key.empty() || field.empty())
            {
                rb.append("usage: hdel key field\n", 22);
                return;
            }
            m_store.check_expiry(key);
            rb.append(m_store.hdel(key, field) ? "ok\n" : "nil\n");
            break;
        }
        case fnv1a("hlen"):
        {
            m_store.check_expiry(args);
            append_int_nl(rb, m_store.hlen(args));
            break;
        }
        case fnv1a("hgetall"):
        {
            m_store.check_expiry(args);
            const auto* h = m_store.hash_ptr(args);
            if (!h || h->empty())
            {
                rb.append("end\n", 4);
                return;
            }
            for (const auto& [field, val] : *h)
            {
                rb.append(field);
                rb.push_back(' ');
                rb.append(val);
                rb.push_back('\n');
            }
            rb.append("end\n", 4);
            break;
        }

        // ─── TTL / Expiry ───

        case fnv1a("expire"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            auto [key, sec_str] = extract_key(args);
            if (key.empty() || sec_str.empty())
            {
                rb.append("usage: expire key seconds\n", 26);
                return;
            }
            int seconds;
            if (!parse_int_sv(sec_str, seconds) || seconds <= 0)
            {
                rb.append("error: invalid seconds\n", 23);
                return;
            }
            rb.append(m_store.set_expiry(key, seconds) ? "ok\n" : "nil\n");
            break;
        }
        case fnv1a("ttl"):
        {
            m_store.check_expiry(args);
            int ttl = m_store.get_ttl(args);
            append_int_nl(rb, ttl);
            break;
        }
        case fnv1a("persist"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            rb.append(m_store.persist(args) ? "ok\n" : "nil\n");
            break;
        }
        case fnv1a("setnx"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            auto [key, val] = extract_key(args);
            if (key.empty() || val.empty()) { rb.append("usage: setnx key value\n", 23); return; }
            bool did_set = m_store.setnx(key, val);
            rb.append(did_set ? "1\n" : "0\n");
            if (did_set)
            {
                replicate_command(line);
#ifndef SOCKETLEY_NO_LUA
                if (lua() && lua()->has_on_write())
                {
                    try { lua()->on_write()(std::string(key), std::string(val), 0); }
                    catch (const sol::error& e)
                    { std::cerr << "[lua] on_write error: " << e.what() << "\n"; }
                }
#endif
            }
            break;
        }
        case fnv1a("setex"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            auto [key, rest] = extract_key(args);
            auto [sec_str, val] = extract_key(rest);
            if (key.empty() || sec_str.empty() || val.empty()) { rb.append("usage: setex key seconds value\n", 31); return; }
            int sec = 0;
            if (!parse_int_sv(sec_str, sec) || sec <= 0) { rb.append("error: invalid seconds\n", 23); return; }
            m_store.check_expiry(key);
            if (!m_store.set(key, val)) { rb.append("error: type conflict\n", 21); return; }
            m_store.set_expiry(key, sec);
            rb.append("ok\n", 3);
            replicate_command(line);
#ifndef SOCKETLEY_NO_LUA
            if (lua() && lua()->has_on_write())
            {
                try { lua()->on_write()(std::string(key), std::string(val), sec); }
                catch (const sol::error& e)
                { std::cerr << "[lua] on_write error: " << e.what() << "\n"; }
            }
#endif
            break;
        }
        case fnv1a("psetex"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            auto [key, rest] = extract_key(args);
            auto [ms_str, val] = extract_key(rest);
            if (key.empty() || ms_str.empty() || val.empty()) { rb.append("usage: psetex key milliseconds value\n", 37); return; }
            int64_t ms = 0;
            {
                auto [p, e] = std::from_chars(ms_str.data(), ms_str.data() + ms_str.size(), ms);
                if (e != std::errc{} || ms <= 0) { rb.append("error: invalid milliseconds\n", 28); return; }
            }
            m_store.check_expiry(key);
            if (!m_store.set(key, val)) { rb.append("error: type conflict\n", 21); return; }
            m_store.set_expiry_ms(key, ms);
            rb.append("ok\n", 3);
            replicate_command(line);
#ifndef SOCKETLEY_NO_LUA
            if (lua() && lua()->has_on_write())
            {
                try { lua()->on_write()(std::string(key), std::string(val), 0); }
                catch (const sol::error& e)
                { std::cerr << "[lua] on_write error: " << e.what() << "\n"; }
            }
#endif
            break;
        }
        case fnv1a("pexpire"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            auto [key, ms_str] = extract_key(args);
            if (key.empty() || ms_str.empty()) { rb.append("usage: pexpire key ms\n", 22); return; }
            int64_t ms = 0;
            {
                auto [p, e] = std::from_chars(ms_str.data(), ms_str.data() + ms_str.size(), ms);
                if (e != std::errc{} || ms <= 0) { rb.append("error: invalid ms\n", 18); return; }
            }
            rb.append(m_store.set_expiry_ms(key, ms) ? "1\n" : "0\n");
            break;
        }
        case fnv1a("pttl"):
        {
            m_store.check_expiry(args);
            append_int_nl(rb, m_store.get_pttl(args));
            break;
        }
        case fnv1a("expireat"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            auto [key, ts_str] = extract_key(args);
            if (key.empty() || ts_str.empty()) { rb.append("usage: expireat key unix_seconds\n", 33); return; }
            int64_t unix_s = 0;
            {
                auto [p, e] = std::from_chars(ts_str.data(), ts_str.data() + ts_str.size(), unix_s);
                if (e != std::errc{}) { rb.append("error: invalid timestamp\n", 25); return; }
            }
            {
                int64_t now_s = std::chrono::duration_cast<std::chrono::seconds>(
                    std::chrono::system_clock::now().time_since_epoch()).count();
                int64_t remaining = unix_s - now_s;
                if (remaining <= 0) { m_store.del(key); rb.append("1\n", 2); }
                else rb.append(m_store.set_expiry(key, static_cast<int>(remaining)) ? "1\n" : "0\n");
            }
            break;
        }
        case fnv1a("pexpireat"):
        {
            if (m_mode == cache_mode_readonly) { rb.append("denied: readonly mode\n", 22); return; }
            auto [key, ts_str] = extract_key(args);
            if (key.empty() || ts_str.empty()) { rb.append("usage: pexpireat key unix_ms\n", 29); return; }
            int64_t unix_ms = 0;
            {
                auto [p, e] = std::from_chars(ts_str.data(), ts_str.data() + ts_str.size(), unix_ms);
                if (e != std::errc{}) { rb.append("error: invalid timestamp\n", 25); return; }
            }
            {
                int64_t now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                    std::chrono::system_clock::now().time_since_epoch()).count();
                int64_t remaining_ms = unix_ms - now_ms;
                if (remaining_ms <= 0) { m_store.del(key); rb.append("1\n", 2); }
                else rb.append(m_store.set_expiry_ms(key, remaining_ms) ? "1\n" : "0\n");
            }
            break;
        }
        case fnv1a("scan"):
        {
            // scan cursor [match pattern] [count n]
            size_t sp0 = args.find(' ');
            std::string_view cursor_str = (sp0 == std::string_view::npos) ? args : args.substr(0, sp0);
            std::string_view rest2 = (sp0 == std::string_view::npos) ? std::string_view{} : args.substr(sp0 + 1);
            uint64_t scan_cursor = 0;
            {
                auto [p, e] = std::from_chars(cursor_str.data(), cursor_str.data() + cursor_str.size(), scan_cursor);
                if (e != std::errc{}) { rb.append("error: invalid cursor\n", 22); return; }
            }
            std::string_view scan_pattern = "*";
            size_t scan_count = 10;
            while (!rest2.empty())
            {
                size_t sp2 = rest2.find(' ');
                std::string_view opt = (sp2 == std::string_view::npos) ? rest2 : rest2.substr(0, sp2);
                rest2 = (sp2 == std::string_view::npos) ? std::string_view{} : rest2.substr(sp2 + 1);
                if (fnv1a_lower(opt) == fnv1a("match") && !rest2.empty())
                {
                    sp2 = rest2.find(' ');
                    scan_pattern = (sp2 == std::string_view::npos) ? rest2 : rest2.substr(0, sp2);
                    rest2 = (sp2 == std::string_view::npos) ? std::string_view{} : rest2.substr(sp2 + 1);
                }
                else if (fnv1a_lower(opt) == fnv1a("count") && !rest2.empty())
                {
                    sp2 = rest2.find(' ');
                    std::string_view cnt_str = (sp2 == std::string_view::npos) ? rest2 : rest2.substr(0, sp2);
                    rest2 = (sp2 == std::string_view::npos) ? std::string_view{} : rest2.substr(sp2 + 1);
                    size_t cnt = 10;
                    auto [p2, e2] = std::from_chars(cnt_str.data(), cnt_str.data() + cnt_str.size(), cnt);
                    if (e2 == std::errc{}) scan_count = cnt;
                }
            }
            std::vector<std::string_view> scan_keys;
            uint64_t next_cursor = m_store.scan(scan_cursor, scan_pattern, scan_count, scan_keys);
            append_int_nl(rb, static_cast<int64_t>(next_cursor));
            for (auto& k : scan_keys) { rb.append(k); rb.push_back('\n'); }
            rb.append("end\n", 4);
            break;
        }

        // ─── Admin ───

        case fnv1a("flush"):
        {
            if (m_mode != cache_mode_admin)
            {
                rb.append("denied: admin mode required\n", 28);
                return;
            }
            std::string_view path = m_persistent_path;
            if (path.empty())
            {
                rb.append("failed: no persistent path set\n", 31);
                return;
            }
            rb.append(m_store.save(path) ? "ok\n" : "failed: flush failed\n");
            break;
        }
        case fnv1a("load"):
        {
            if (m_mode != cache_mode_admin)
            {
                rb.append("denied: admin mode required\n", 28);
                return;
            }
            std::string_view path = m_persistent_path;
            if (path.empty())
            {
                rb.append("failed: no persistent path set\n", 31);
                return;
            }
            rb.append(m_store.load(path) ? "ok\n" : "failed: load failed\n");
            break;
        }
        case fnv1a("size"):
        {
            append_int_nl(rb, m_store.size());
            break;
        }

        // ─── Pub/Sub ───

        case fnv1a("subscribe"):
        {
            if (args.empty())
            {
                rb.append("usage: subscribe channel\n", 25);
                return;
            }
            m_store.subscribe(conn->fd, args);
            rb.append("ok\n", 3);
            break;
        }
        case fnv1a("unsubscribe"):
        {
            if (args.empty())
            {
                rb.append("usage: unsubscribe channel\n", 27);
                return;
            }
            m_store.unsubscribe(conn->fd, args);
            rb.append("ok\n", 3);
            break;
        }
        case fnv1a("publish"):
        {
            if (m_mode == cache_mode_readonly)
            {
                rb.append("denied: readonly mode\n", 22);
                return;
            }
            auto [channel, message] = extract_key(args);
            if (channel.empty() || message.empty())
            {
                rb.append("usage: publish channel message\n", 31);
                return;
            }
            int count = publish(channel, message);
            append_int_nl(rb, count);
            break;
        }

        // ─── Memory / Maxmemory ───

        case fnv1a("maxmemory"):
        {
            append_int_nl(rb, m_store.get_max_memory());
            break;
        }
        case fnv1a("memory"):
        {
            append_int_nl(rb, m_store.get_memory_used());
            break;
        }
        case fnv1a("replicate"):
        {
            handle_replicate_request(conn);
            return;
        }
        default:
            rb.append("failed: unknown command\n", 24);
            break;
    }
}

void cache_instance::flush_responses(client_connection* conn)
{
    if (conn->response_buf.empty() || !m_loop || conn->closing)
        return;

    if (conn->write_queue.size() >= client_connection::MAX_WRITE_QUEUE)
    {
        conn->closing = true;
        return;
    }

    conn->write_queue.push(std::move(conn->response_buf));
    conn->response_buf.reserve(4096);

    if (!conn->write_pending)
        flush_write_queue(conn);
}

void cache_instance::flush_write_queue(client_connection* conn)
{
    if (!m_loop || conn->write_queue.empty())
        return;

    uint32_t count = 0;
    while (!conn->write_queue.empty() && count < client_connection::MAX_WRITE_BATCH)
    {
        conn->write_batch[count] = std::move(conn->write_queue.front());
        conn->write_queue.pop();

        conn->write_iovs[count].iov_base = conn->write_batch[count].data();
        conn->write_iovs[count].iov_len  = conn->write_batch[count].size();
        count++;
    }

    conn->write_batch_count = count;
    conn->write_pending = true;

    if (count == 1)
    {
        conn->write_req.type = op_write;
        m_loop->submit_write(conn->fd, conn->write_batch[0].data(),
            static_cast<uint32_t>(conn->write_batch[0].size()), &conn->write_req);
    }
    else
    {
        conn->write_req.type = op_writev;
        m_loop->submit_writev(conn->fd, conn->write_iovs, count, &conn->write_req);
    }
}

// ─── Lua accessor methods ───

std::string cache_instance::lua_get(std::string_view key)
{
    m_store.check_expiry(key);
    std::string value;
    if (m_store.get(key, value))
        return value;
    return "";
}

bool cache_instance::lua_set(std::string_view key, std::string_view value)
{
    if (m_mode == cache_mode_readonly)
        return false;
    m_store.check_expiry(key);
    return m_store.set(key, value);
}

bool cache_instance::lua_del(std::string_view key)
{
    if (m_mode == cache_mode_readonly)
        return false;
    return m_store.del(key);
}

bool cache_instance::lua_lpush(std::string_view key, std::string_view val)
{
    if (m_mode == cache_mode_readonly)
        return false;
    m_store.check_expiry(key);
    return m_store.lpush(key, val);
}

bool cache_instance::lua_rpush(std::string_view key, std::string_view val)
{
    if (m_mode == cache_mode_readonly)
        return false;
    m_store.check_expiry(key);
    return m_store.rpush(key, val);
}

std::string cache_instance::lua_lpop(std::string_view key)
{
    if (m_mode == cache_mode_readonly)
        return "";
    m_store.check_expiry(key);
    std::string val;
    if (m_store.lpop(key, val))
        return val;
    return "";
}

std::string cache_instance::lua_rpop(std::string_view key)
{
    if (m_mode == cache_mode_readonly)
        return "";
    m_store.check_expiry(key);
    std::string val;
    if (m_store.rpop(key, val))
        return val;
    return "";
}

int cache_instance::lua_llen(std::string_view key)
{
    m_store.check_expiry(key);
    return m_store.llen(key);
}

#ifndef SOCKETLEY_NO_LUA
sol::table cache_instance::lua_lrange(std::string_view key, int start, int stop)
{
    m_store.check_expiry(key);
    auto* ctx = lua();
    if (!ctx)
        return sol::table();

    sol::table result = ctx->state().create_table();
    const auto* deq = m_store.list_ptr(key);
    if (!deq || deq->empty())
        return result;

    int len = static_cast<int>(deq->size());
    if (start < 0) start += len;
    if (stop < 0) stop += len;
    if (start < 0) start = 0;
    if (stop >= len) stop = len - 1;

    int lua_idx = 1;
    for (int i = start; i <= stop; i++)
        result[lua_idx++] = (*deq)[static_cast<size_t>(i)];

    return result;
}
#endif

int cache_instance::lua_sadd(std::string_view key, std::string_view member)
{
    if (m_mode == cache_mode_readonly)
        return -1;
    m_store.check_expiry(key);
    return m_store.sadd(key, member);
}

bool cache_instance::lua_srem(std::string_view key, std::string_view member)
{
    if (m_mode == cache_mode_readonly)
        return false;
    m_store.check_expiry(key);
    return m_store.srem(key, member);
}

bool cache_instance::lua_sismember(std::string_view key, std::string_view member)
{
    m_store.check_expiry(key);
    return m_store.sismember(key, member);
}

int cache_instance::lua_scard(std::string_view key)
{
    m_store.check_expiry(key);
    return m_store.scard(key);
}

#ifndef SOCKETLEY_NO_LUA
sol::table cache_instance::lua_smembers(std::string_view key)
{
    m_store.check_expiry(key);
    auto* ctx = lua();
    if (!ctx)
        return sol::table();

    sol::table result = ctx->state().create_table();
    const auto* s = m_store.set_ptr(key);
    if (!s)
        return result;

    int lua_idx = 1;
    for (const auto& member : *s)
        result[lua_idx++] = member;

    return result;
}
#endif

bool cache_instance::lua_hset(std::string_view key, std::string_view field, std::string_view val)
{
    if (m_mode == cache_mode_readonly)
        return false;
    m_store.check_expiry(key);
    return m_store.hset(key, field, val);
}

std::string cache_instance::lua_hget(std::string_view key, std::string_view field)
{
    m_store.check_expiry(key);
    const std::string* val = m_store.hget(key, field);
    return val ? *val : "";
}

bool cache_instance::lua_hdel(std::string_view key, std::string_view field)
{
    if (m_mode == cache_mode_readonly)
        return false;
    m_store.check_expiry(key);
    return m_store.hdel(key, field);
}

int cache_instance::lua_hlen(std::string_view key)
{
    m_store.check_expiry(key);
    return m_store.hlen(key);
}

#ifndef SOCKETLEY_NO_LUA
sol::table cache_instance::lua_hgetall(std::string_view key)
{
    m_store.check_expiry(key);
    auto* ctx = lua();
    if (!ctx)
        return sol::table();

    sol::table result = ctx->state().create_table();
    const auto* h = m_store.hash_ptr(key);
    if (!h)
        return result;

    for (const auto& [field, val] : *h)
        result[field] = val;

    return result;
}
#endif

bool cache_instance::lua_expire(std::string_view key, int seconds)
{
    if (m_mode == cache_mode_readonly)
        return false;
    return m_store.set_expiry(key, seconds);
}

int cache_instance::lua_ttl(std::string_view key)
{
    m_store.check_expiry(key);
    return m_store.get_ttl(key);
}

bool cache_instance::lua_persist(std::string_view key)
{
    if (m_mode == cache_mode_readonly)
        return false;
    return m_store.persist(key);
}

bool cache_instance::store_direct(std::string_view key, std::string_view value)
{
    return m_store.set(key, value);
}

uint32_t cache_instance::get_size() const
{
    return m_store.size();
}

size_t cache_instance::store_memory_used() const
{
    return m_store.get_memory_used();
}

bool cache_instance::flush_to(std::string_view path)
{
    if (m_mode != cache_mode_admin)
        return false;
    return m_store.save(path);
}

bool cache_instance::load_from(std::string_view path)
{
    if (m_mode != cache_mode_admin)
        return false;
    return m_store.load(path);
}

// ─── RESP protocol support ───

void cache_instance::process_resp(client_connection* conn)
{
    // Fixed-size string_view array — zero heap allocations per command
    static constexpr int MAX_RESP_ARGS = 64;
    std::string_view args[MAX_RESP_ARGS];
    int argc = 0;
    size_t consumed = 0;
    size_t offset = 0;

    while (offset < conn->partial.size())
    {
        std::string_view buf(conn->partial.data() + offset, conn->partial.size() - offset);
        auto result = resp::parse_message_views(buf, args, MAX_RESP_ARGS, argc, consumed);

        if (result == resp::parse_result::incomplete)
            break;

        if (result == resp::parse_result::error)
        {
            conn->response_buf.append("-ERR protocol error\r\n");
            conn->partial.clear();
            return;
        }

        // Advance offset; args[] point into conn->partial which stays valid
        offset += consumed;

        if (argc > 0)
            process_resp_command(conn, args, argc);
    }

    // Single erase for entire batch — O(remaining) not O(n * commands)
    if (offset > 0)
    {
        if (offset >= conn->partial.size())
            conn->partial.clear();
        else
            conn->partial.erase(0, offset);
    }
}

void cache_instance::process_resp_command(client_connection* conn, std::string_view* args, int argc)
{
    if (argc == 0)
        return;

    // Global rate limit check (across all connections)
    if (!check_global_rate_limit())
    {
        resp::encode_error_into(conn->response_buf, "rate limited");
        return;
    }

    // Rate limit check
    if (conn->rl_max > 0)
    {
        auto now = std::chrono::steady_clock::now();
        double elapsed = std::chrono::duration<double>(now - conn->rl_last).count();
        conn->rl_last = now;
        conn->rl_tokens += elapsed * conn->rl_max;
        if (conn->rl_tokens > conn->rl_max)
            conn->rl_tokens = conn->rl_max;
        if (conn->rl_tokens < 1.0)
        {
            resp::encode_error_into(conn->response_buf, "rate limited");
            return;
        }
        conn->rl_tokens -= 1.0;
    }

    m_stat_commands++;
    m_stat_total_messages.fetch_add(1, std::memory_order_relaxed);

    // Dispatch via case-insensitive FNV-1a — no string allocation
    auto& rb = conn->response_buf;

    switch (fnv1a_lower(args[0]))
    {
        case fnv1a("set"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            bool nx = false, xx = false;
            int ex_sec = 0;
            int64_t px_ms = 0;
            for (int i = 3; i < argc; i++)
            {
                switch (fnv1a_lower(args[i]))
                {
                    case fnv1a("ex"):
                        if (i + 1 < argc)
                        {
                            auto [p, e] = std::from_chars(args[i+1].data(), args[i+1].data() + args[i+1].size(), ex_sec);
                            if (e == std::errc{}) i++;
                        }
                        break;
                    case fnv1a("px"):
                        if (i + 1 < argc)
                        {
                            auto [p, e] = std::from_chars(args[i+1].data(), args[i+1].data() + args[i+1].size(), px_ms);
                            if (e == std::errc{}) i++;
                        }
                        break;
                    case fnv1a("nx"): nx = true; break;
                    case fnv1a("xx"): xx = true; break;
                    default: break;
                }
            }
            m_store.check_expiry(args[1]);
            bool key_exists = m_store.exists(args[1]);
            if (nx && key_exists)  { resp::encode_null_into(rb); break; }
            if (xx && !key_exists) { resp::encode_null_into(rb); break; }
            if (!m_store.set(args[1], args[2]))
            {
                resp::encode_error_into(rb, "type conflict");
                break;
            }
            if (ex_sec > 0) m_store.set_expiry(args[1], ex_sec);
            else if (px_ms > 0) m_store.set_expiry_ms(args[1], px_ms);
            resp::encode_ok_into(rb);
#ifndef SOCKETLEY_NO_LUA
            if (lua() && lua()->has_on_write())
            {
                try { lua()->on_write()(std::string(args[1]), std::string(args[2]), ex_sec); }
                catch (const sol::error& e)
                { std::cerr << "[lua] on_write error: " << e.what() << "\n"; }
            }
#endif
            break;
        }
        case fnv1a("get"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            const std::string* val = m_store.get_ptr(args[1]);
            if (val)
            {
                m_stat_get_hits++;
                resp::encode_bulk_into(rb, *val);
            }
            else
            {
#ifndef SOCKETLEY_NO_LUA
                if (lua() && lua()->has_on_miss())
                {
                    try
                    {
                        auto res = lua()->on_miss()(std::string(args[1]));
                        sol::optional<std::string> fetched = res.get<sol::optional<std::string>>(0);
                        if (fetched && !fetched->empty())
                        {
                            int ttl = 0;
                            sol::optional<int> ttl_opt = res.get<sol::optional<int>>(1);
                            if (ttl_opt) ttl = *ttl_opt;
                            m_store.set(args[1], *fetched);
                            if (ttl > 0) m_store.set_expiry(args[1], ttl);
                            m_stat_get_hits++;
                            resp::encode_bulk_into(rb, *fetched);
                            break;
                        }
                    }
                    catch (const sol::error& e)
                    { std::cerr << "[lua] on_miss error: " << e.what() << "\n"; }
                }
#endif
                m_stat_get_misses++;
                resp::encode_null_into(rb);
            }
            break;
        }
        case fnv1a("del"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            int deleted = 0;
            for (int i = 1; i < argc; i++)
            {
                m_store.check_expiry(args[i]);
                if (m_store.del(args[i]))
                {
                    deleted++;
#ifndef SOCKETLEY_NO_LUA
                    if (lua() && lua()->has_on_delete())
                    {
                        try { lua()->on_delete_cb()(std::string(args[i])); }
                        catch (const sol::error& e)
                        { std::cerr << "[lua] on_delete error: " << e.what() << "\n"; }
                    }
#endif
                }
            }
            resp::encode_integer_into(rb, deleted);
            break;
        }
        case fnv1a("exists"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            resp::encode_integer_into(rb, m_store.exists(args[1]) ? 1 : 0);
            break;
        }
        case fnv1a("incr"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            int64_t result = 0;
            if (!m_store.incr(args[1], 1, result))
                resp::encode_error_into(rb, "ERR value is not an integer or out of range");
            else
                resp::encode_integer_into(rb, result);
            break;
        }
        case fnv1a("decr"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            int64_t result = 0;
            if (!m_store.incr(args[1], -1, result))
                resp::encode_error_into(rb, "ERR value is not an integer or out of range");
            else
                resp::encode_integer_into(rb, result);
            break;
        }
        case fnv1a("incrby"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            int64_t delta = 0;
            auto [p, e] = std::from_chars(args[2].data(), args[2].data() + args[2].size(), delta);
            if (e != std::errc{}) { resp::encode_error_into(rb, "ERR value is not an integer or out of range"); return; }
            int64_t result = 0;
            if (!m_store.incr(args[1], delta, result))
                resp::encode_error_into(rb, "ERR value is not an integer or out of range");
            else
                resp::encode_integer_into(rb, result);
            break;
        }
        case fnv1a("decrby"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            int64_t delta = 0;
            auto [p2, e2] = std::from_chars(args[2].data(), args[2].data() + args[2].size(), delta);
            if (e2 != std::errc{}) { resp::encode_error_into(rb, "ERR value is not an integer or out of range"); return; }
            int64_t result = 0;
            if (!m_store.incr(args[1], -delta, result))
                resp::encode_error_into(rb, "ERR value is not an integer or out of range");
            else
                resp::encode_integer_into(rb, result);
            break;
        }
        case fnv1a("append"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            size_t newlen = m_store.append(args[1], args[2]);
            if (newlen == std::string::npos)
                resp::encode_error_into(rb, "WRONGTYPE");
            else
                resp::encode_integer_into(rb, static_cast<int64_t>(newlen));
            break;
        }
        case fnv1a("strlen"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            resp::encode_integer_into(rb, static_cast<int64_t>(m_store.strlen_key(args[1])));
            break;
        }
        case fnv1a("getset"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            m_store.check_expiry(args[1]);
            bool had_key = m_store.exists(args[1]);
            std::string oldval;
            if (!m_store.getset(args[1], args[2], oldval))
                resp::encode_error_into(rb, "WRONGTYPE");
            else if (!had_key)
                resp::encode_null_into(rb);
            else
                resp::encode_bulk_into(rb, oldval);
            break;
        }
        case fnv1a("mget"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            resp::encode_array_header_into(rb, argc - 1);
            for (int i = 1; i < argc; i++)
            {
                m_store.check_expiry(args[i]);
                const std::string* val = m_store.get_ptr(args[i]);
                if (val) resp::encode_bulk_into(rb, *val);
                else resp::encode_null_into(rb);
            }
            break;
        }
        case fnv1a("mset"):
        {
            if (argc < 3 || (argc - 1) % 2 != 0) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            for (int i = 1; i + 1 < argc; i += 2)
            {
                m_store.check_expiry(args[i]);
                m_store.set(args[i], args[i+1]);
#ifndef SOCKETLEY_NO_LUA
                if (lua() && lua()->has_on_write())
                {
                    try { lua()->on_write()(std::string(args[i]), std::string(args[i+1]), 0); }
                    catch (const sol::error& e)
                    { std::cerr << "[lua] on_write error: " << e.what() << "\n"; }
                }
#endif
            }
            resp::encode_ok_into(rb);
            break;
        }
        case fnv1a("type"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            resp::encode_simple_into(rb, m_store.type(args[1]));
            break;
        }
        case fnv1a("keys"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            std::vector<std::string_view> result;
            m_store.keys(args[1], result);
            resp::encode_array_header_into(rb, static_cast<int>(result.size()));
            for (auto& k : result)
                resp::encode_bulk_into(rb, k);
            break;
        }
        case fnv1a("ping"):
        {
            if (argc > 1)
                resp::encode_bulk_into(rb, args[1]);
            else
                resp::encode_simple_into(rb, "PONG");
            break;
        }
        case fnv1a("dbsize"):
        {
            resp::encode_integer_into(rb, m_store.size());
            break;
        }
        case fnv1a("lpush"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            m_store.check_expiry(args[1]);
            for (int i = 2; i < argc; i++)
            {
                if (!m_store.lpush(args[1], args[i]))
                {
                    resp::encode_error_into(rb, "type conflict");
                    return;
                }
            }
            resp::encode_integer_into(rb, m_store.llen(args[1]));
            break;
        }
        case fnv1a("rpush"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            m_store.check_expiry(args[1]);
            for (int i = 2; i < argc; i++)
            {
                if (!m_store.rpush(args[1], args[i]))
                {
                    resp::encode_error_into(rb, "type conflict");
                    return;
                }
            }
            resp::encode_integer_into(rb, m_store.llen(args[1]));
            break;
        }
        case fnv1a("lpop"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            m_store.check_expiry(args[1]);
            std::string val;
            if (m_store.lpop(args[1], val)) resp::encode_bulk_into(rb, val);
            else resp::encode_null_into(rb);
            break;
        }
        case fnv1a("rpop"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            m_store.check_expiry(args[1]);
            std::string val;
            if (m_store.rpop(args[1], val)) resp::encode_bulk_into(rb, val);
            else resp::encode_null_into(rb);
            break;
        }
        case fnv1a("llen"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            resp::encode_integer_into(rb, m_store.llen(args[1]));
            break;
        }
        case fnv1a("lrange"):
        {
            if (argc < 4) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            int start = 0, stop = 0;
            auto [p1, e1] = std::from_chars(args[2].data(), args[2].data() + args[2].size(), start);
            auto [p2, e2] = std::from_chars(args[3].data(), args[3].data() + args[3].size(), stop);
            if (e1 != std::errc{} || e2 != std::errc{}) { resp::encode_error_into(rb, "ERR value is not an integer or out of range"); return; }
            const auto* deq = m_store.list_ptr(args[1]);
            if (!deq || deq->empty()) { resp::encode_array_header_into(rb, 0); break; }
            int len = static_cast<int>(deq->size());
            if (start < 0) start += len;
            if (stop < 0) stop += len;
            if (start < 0) start = 0;
            if (stop >= len) stop = len - 1;
            int result_len = (start > stop) ? 0 : (stop - start + 1);
            resp::encode_array_header_into(rb, result_len);
            for (int i = start; i <= stop; i++)
                resp::encode_bulk_into(rb, (*deq)[static_cast<size_t>(i)]);
            break;
        }
        case fnv1a("lindex"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            int idx = 0;
            auto [p, e] = std::from_chars(args[2].data(), args[2].data() + args[2].size(), idx);
            if (e != std::errc{}) { resp::encode_error_into(rb, "ERR value is not an integer or out of range"); return; }
            const std::string* val = m_store.lindex(args[1], idx);
            if (val) resp::encode_bulk_into(rb, *val);
            else resp::encode_null_into(rb);
            break;
        }
        case fnv1a("sadd"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            m_store.check_expiry(args[1]);
            int added = 0;
            for (int i = 2; i < argc; i++)
            {
                int r = m_store.sadd(args[1], args[i]);
                if (r < 0) { resp::encode_error_into(rb, "type conflict"); return; }
                added += r;
            }
            resp::encode_integer_into(rb, added);
            break;
        }
        case fnv1a("srem"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            m_store.check_expiry(args[1]);
            int removed = 0;
            for (int i = 2; i < argc; i++)
                if (m_store.srem(args[1], args[i])) removed++;
            resp::encode_integer_into(rb, removed);
            break;
        }
        case fnv1a("sismember"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            resp::encode_integer_into(rb, m_store.sismember(args[1], args[2]) ? 1 : 0);
            break;
        }
        case fnv1a("scard"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            resp::encode_integer_into(rb, m_store.scard(args[1]));
            break;
        }
        case fnv1a("smembers"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            const auto* s = m_store.set_ptr(args[1]);
            if (!s) { resp::encode_array_header_into(rb, 0); break; }
            resp::encode_array_header_into(rb, static_cast<int>(s->size()));
            for (const auto& member : *s)
                resp::encode_bulk_into(rb, member);
            break;
        }
        case fnv1a("hset"):
        {
            if (argc < 4 || (argc - 2) % 2 != 0)
            {
                resp::encode_error_into(rb, "wrong number of arguments");
                return;
            }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            m_store.check_expiry(args[1]);
            int added = 0;
            for (int i = 2; i + 1 < argc; i += 2)
            {
                if (!m_store.hset(args[1], args[i], args[i+1]))
                {
                    resp::encode_error_into(rb, "type conflict");
                    return;
                }
                added++;
            }
            resp::encode_integer_into(rb, added);
            break;
        }
        case fnv1a("hget"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            const std::string* val = m_store.hget(args[1], args[2]);
            if (val) resp::encode_bulk_into(rb, *val);
            else resp::encode_null_into(rb);
            break;
        }
        case fnv1a("hdel"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            m_store.check_expiry(args[1]);
            int removed = 0;
            for (int i = 2; i < argc; i++)
                if (m_store.hdel(args[1], args[i])) removed++;
            resp::encode_integer_into(rb, removed);
            break;
        }
        case fnv1a("hlen"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            resp::encode_integer_into(rb, m_store.hlen(args[1]));
            break;
        }
        case fnv1a("hgetall"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            const auto* h = m_store.hash_ptr(args[1]);
            if (!h) { resp::encode_array_header_into(rb, 0); break; }
            resp::encode_array_header_into(rb, static_cast<int>(h->size() * 2));
            for (const auto& [field, val] : *h)
            {
                resp::encode_bulk_into(rb, field);
                resp::encode_bulk_into(rb, val);
            }
            break;
        }
        case fnv1a("expire"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            int sec = 0;
            auto [p, e] = std::from_chars(args[2].data(), args[2].data() + args[2].size(), sec);
            if (e != std::errc{} || sec <= 0) { resp::encode_error_into(rb, "invalid seconds"); return; }
            resp::encode_integer_into(rb, m_store.set_expiry(args[1], sec) ? 1 : 0);
            break;
        }
        case fnv1a("ttl"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            resp::encode_integer_into(rb, m_store.get_ttl(args[1]));
            break;
        }
        case fnv1a("persist"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            resp::encode_integer_into(rb, m_store.persist(args[1]) ? 1 : 0);
            break;
        }
        case fnv1a("setnx"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            bool did_set = m_store.setnx(args[1], args[2]);
            resp::encode_integer_into(rb, did_set ? 1 : 0);
#ifndef SOCKETLEY_NO_LUA
            if (did_set && lua() && lua()->has_on_write())
            {
                try { lua()->on_write()(std::string(args[1]), std::string(args[2]), 0); }
                catch (const sol::error& e)
                { std::cerr << "[lua] on_write error: " << e.what() << "\n"; }
            }
#endif
            break;
        }
        case fnv1a("setex"):
        {
            if (argc < 4) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            int sec = 0;
            auto [p, e] = std::from_chars(args[2].data(), args[2].data() + args[2].size(), sec);
            if (e != std::errc{} || sec <= 0) { resp::encode_error_into(rb, "ERR invalid expire time in SETEX"); return; }
            m_store.check_expiry(args[1]);
            if (!m_store.set(args[1], args[3])) { resp::encode_error_into(rb, "WRONGTYPE"); return; }
            m_store.set_expiry(args[1], sec);
            resp::encode_ok_into(rb);
#ifndef SOCKETLEY_NO_LUA
            if (lua() && lua()->has_on_write())
            {
                try { lua()->on_write()(std::string(args[1]), std::string(args[3]), sec); }
                catch (const sol::error& e)
                { std::cerr << "[lua] on_write error: " << e.what() << "\n"; }
            }
#endif
            break;
        }
        case fnv1a("psetex"):
        {
            if (argc < 4) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            int64_t ms = 0;
            auto [p, e] = std::from_chars(args[2].data(), args[2].data() + args[2].size(), ms);
            if (e != std::errc{} || ms <= 0) { resp::encode_error_into(rb, "ERR invalid expire time in PSETEX"); return; }
            m_store.check_expiry(args[1]);
            if (!m_store.set(args[1], args[3])) { resp::encode_error_into(rb, "WRONGTYPE"); return; }
            m_store.set_expiry_ms(args[1], ms);
            resp::encode_ok_into(rb);
#ifndef SOCKETLEY_NO_LUA
            if (lua() && lua()->has_on_write())
            {
                try { lua()->on_write()(std::string(args[1]), std::string(args[3]), 0); }
                catch (const sol::error& e)
                { std::cerr << "[lua] on_write error: " << e.what() << "\n"; }
            }
#endif
            break;
        }
        case fnv1a("pexpire"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            int64_t ms = 0;
            auto [p, e] = std::from_chars(args[2].data(), args[2].data() + args[2].size(), ms);
            if (e != std::errc{} || ms <= 0) { resp::encode_error_into(rb, "ERR invalid expire time"); return; }
            resp::encode_integer_into(rb, m_store.set_expiry_ms(args[1], ms) ? 1 : 0);
            break;
        }
        case fnv1a("pttl"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            m_store.check_expiry(args[1]);
            resp::encode_integer_into(rb, m_store.get_pttl(args[1]));
            break;
        }
        case fnv1a("expireat"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            int64_t unix_s = 0;
            auto [p, e] = std::from_chars(args[2].data(), args[2].data() + args[2].size(), unix_s);
            if (e != std::errc{}) { resp::encode_error_into(rb, "ERR invalid timestamp"); return; }
            {
                int64_t now_s = std::chrono::duration_cast<std::chrono::seconds>(
                    std::chrono::system_clock::now().time_since_epoch()).count();
                int64_t remaining = unix_s - now_s;
                if (remaining <= 0) { m_store.del(args[1]); resp::encode_integer_into(rb, 1); }
                else resp::encode_integer_into(rb, m_store.set_expiry(args[1], static_cast<int>(remaining)) ? 1 : 0);
            }
            break;
        }
        case fnv1a("pexpireat"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            if (m_mode == cache_mode_readonly) { resp::encode_error_into(rb, "readonly mode"); return; }
            int64_t unix_ms = 0;
            auto [p, e] = std::from_chars(args[2].data(), args[2].data() + args[2].size(), unix_ms);
            if (e != std::errc{}) { resp::encode_error_into(rb, "ERR invalid timestamp"); return; }
            {
                int64_t now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                    std::chrono::system_clock::now().time_since_epoch()).count();
                int64_t remaining_ms = unix_ms - now_ms;
                if (remaining_ms <= 0) { m_store.del(args[1]); resp::encode_integer_into(rb, 1); }
                else resp::encode_integer_into(rb, m_store.set_expiry_ms(args[1], remaining_ms) ? 1 : 0);
            }
            break;
        }
        case fnv1a("scan"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            uint64_t scan_cursor = 0;
            {
                auto [p, e] = std::from_chars(args[1].data(), args[1].data() + args[1].size(), scan_cursor);
                if (e != std::errc{}) { resp::encode_error_into(rb, "ERR invalid cursor"); return; }
            }
            std::string_view scan_pattern = "*";
            size_t scan_count = 10;
            for (int i = 2; i < argc; i++)
            {
                if (fnv1a_lower(args[i]) == fnv1a("match") && i + 1 < argc)
                    scan_pattern = args[++i];
                else if (fnv1a_lower(args[i]) == fnv1a("count") && i + 1 < argc)
                {
                    size_t cnt = 10;
                    auto [p2, e2] = std::from_chars(args[i+1].data(), args[i+1].data() + args[i+1].size(), cnt);
                    if (e2 == std::errc{}) scan_count = cnt;
                    i++;
                }
            }
            std::vector<std::string_view> scan_keys;
            uint64_t next_cursor = m_store.scan(scan_cursor, scan_pattern, scan_count, scan_keys);
            // RESP: *2\r\n + bulk(next_cursor_str) + array(keys)
            rb.append("*2\r\n");
            char cur_buf[24];
            auto [end, ec] = std::to_chars(cur_buf, cur_buf + sizeof(cur_buf), next_cursor);
            resp::encode_bulk_into(rb, std::string_view(cur_buf, static_cast<size_t>(end - cur_buf)));
            resp::encode_array_header_into(rb, static_cast<int>(scan_keys.size()));
            for (auto& k : scan_keys)
                resp::encode_bulk_into(rb, k);
            break;
        }
        case fnv1a("subscribe"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            for (int i = 1; i < argc; i++)
                m_store.subscribe(conn->fd, args[i]);
            resp::encode_ok_into(rb);
            break;
        }
        case fnv1a("unsubscribe"):
        {
            if (argc < 2) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            for (int i = 1; i < argc; i++)
                m_store.unsubscribe(conn->fd, args[i]);
            resp::encode_ok_into(rb);
            break;
        }
        case fnv1a("publish"):
        {
            if (argc < 3) { resp::encode_error_into(rb, "wrong number of arguments"); return; }
            int count = publish(args[1], args[2]);
            resp::encode_integer_into(rb, count);
            break;
        }
        default:
        {
            rb.append("-ERR unknown command '", 22);
            rb.append(args[0].data(), args[0].size());
            rb.append("'\r\n", 3);
            break;
        }
    }
}

// ─── Pub/Sub publish ───

int cache_instance::publish(std::string_view channel, std::string_view message)
{
    const auto* subs = m_store.get_subscribers(channel);
    int count = 0;

    if (subs && !subs->empty())
    {
        // Build the message for RESP subscribers
        std::string msg_line;
        msg_line.reserve(8 + channel.size() + 1 + message.size() + 1);
        msg_line.append("message ");
        msg_line.append(channel.data(), channel.size());
        msg_line.push_back(' ');
        msg_line.append(message.data(), message.size());
        msg_line.push_back('\n');

        auto shared_msg = std::make_shared<const std::string>(std::move(msg_line));

        for (int fd : *subs)
        {
            if (fd < 0 || fd >= MAX_FDS || !m_conn_idx[fd])
                continue;

            auto* sub_conn = m_conn_idx[fd];
            if (sub_conn->closing)
                continue;

            if (sub_conn->write_queue.size() >= client_connection::MAX_WRITE_QUEUE)
            {
                sub_conn->closing = true;
                continue;
            }

            sub_conn->write_queue.push(*shared_msg);
            if (!sub_conn->write_pending)
                flush_write_queue(sub_conn);
            count++;
        }
    }

    // Dispatch to Lua subscribers in other runtimes
    if (auto* mgr = get_runtime_manager())
        mgr->dispatch_publish(get_name(), channel, message);

    return count;
}

// ─── Maxmemory / Eviction ───

void cache_instance::set_max_memory(size_t bytes)
{
    m_store.set_max_memory(bytes);
}

size_t cache_instance::get_max_memory() const
{
    return m_store.get_max_memory();
}

void cache_instance::set_eviction(eviction_policy policy)
{
    m_store.set_eviction(policy);
}

eviction_policy cache_instance::get_eviction() const
{
    return m_store.get_eviction();
}

// ─── RESP mode ───

void cache_instance::set_resp_forced(bool enabled)
{
    m_resp_forced = enabled;
}

bool cache_instance::get_resp_forced() const
{
    return m_resp_forced;
}

// ─── Replication ───

void cache_instance::set_replicate_target(std::string_view host_port)
{
    m_replicate_target = host_port;
    m_repl_role = repl_follower;
}

std::string_view cache_instance::get_replicate_target() const
{
    return m_replicate_target;
}

cache_instance::repl_role cache_instance::get_repl_role() const
{
    return m_repl_role;
}

void cache_instance::replicate_command(std::string_view cmd)
{
    if (m_repl_role != repl_leader || m_follower_fds.empty())
        return;

    std::string line;
    line.reserve(cmd.size() + 1);
    line.append(cmd.data(), cmd.size());
    line.push_back('\n');

    for (auto it = m_follower_fds.begin(); it != m_follower_fds.end(); )
    {
        ssize_t sent = ::write(*it, line.data(), line.size());
        if (sent <= 0)
        {
            close(*it);
            it = m_follower_fds.erase(it);
        }
        else
            ++it;
    }
}

void cache_instance::handle_replicate_request(client_connection* conn)
{
    // Client sent "REPLICATE\n" — promote self to leader, send full dump
    if (m_repl_role == repl_follower)
    {
        conn->response_buf.append("error: this node is a follower\n", 31);
        return;
    }

    m_repl_role = repl_leader;
    m_follower_fds.push_back(conn->fd);

    // Send full dump as a series of commands
    send_full_dump(conn->fd);

    conn->response_buf.append("ok\n", 3);
}

void cache_instance::send_full_dump(int fd)
{
    // Send all data as SET/LPUSH/SADD/HSET commands
    std::string buf;
    buf.reserve(65536);

    // Access store internals via the Lua API
    // For strings: iterate via get_stats path — actually we need direct access
    // We'll use the store's public interface indirectly
    // The simplest approach: use the store save format but as text commands

    // NOTE: For a complete implementation, cache_store would expose iterators.
    // For now, this provides the framework. A full dump would require
    // cache_store to expose iteration methods. We'll add a simple one.
    (void)fd;
    (void)buf;
}

bool cache_instance::connect_to_master()
{
    if (m_replicate_target.empty())
        return false;

    // Parse host:port
    size_t colon = m_replicate_target.rfind(':');
    if (colon == std::string::npos)
        return false;

    std::string host = m_replicate_target.substr(0, colon);
    uint16_t port = 0;
    auto port_sv = std::string_view(m_replicate_target).substr(colon + 1);
    auto [p, e] = std::from_chars(port_sv.data(), port_sv.data() + port_sv.size(), port);
    if (e != std::errc{})
        return false;

    int fd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);
    if (fd < 0)
        return false;

    struct sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    if (inet_pton(AF_INET, host.c_str(), &addr.sin_addr) != 1)
    {
        close(fd);
        return false;
    }

    if (connect(fd, reinterpret_cast<struct sockaddr*>(&addr), sizeof(addr)) < 0)
    {
        if (errno != EINPROGRESS)
        {
            close(fd);
            return false;
        }
    }

    // Send REPLICATE command
    const char* cmd = "replicate\n";
    if (::write(fd, cmd, 10) < 0) { ::close(fd); return false; }

    m_master_fd = fd;

    // Submit read for master data
    m_master_read_req = { op_read, fd, m_master_read_buf, sizeof(m_master_read_buf), this };
    if (m_loop)
        m_loop->submit_read(fd, m_master_read_buf, sizeof(m_master_read_buf), &m_master_read_req);

    // Set mode to readonly as follower
    m_mode = cache_mode_readonly;

    return true;
}

void cache_instance::handle_master_read(struct io_uring_cqe* cqe)
{
    if (cqe->res <= 0)
    {
        // Master disconnected
        close(m_master_fd);
        m_master_fd = -1;
        return;
    }

    m_master_partial.append(m_master_read_buf, cqe->res);

    // Process replicated commands
    size_t scan_from = 0;
    size_t pos;
    while ((pos = m_master_partial.find('\n', scan_from)) != std::string::npos)
    {
        std::string_view line(m_master_partial.data() + scan_from, pos - scan_from);
        if (!line.empty() && line.back() == '\r')
            line.remove_suffix(1);

        if (!line.empty())
        {
            // Temporarily allow writes for replication
            cache_mode saved = m_mode;
            m_mode = cache_mode_readwrite;

            // Create a temporary dummy connection for process_command
            // Actually, we can just call the store methods directly
            size_t sp = line.find(' ');
            std::string_view cmd = (sp != std::string_view::npos) ? line.substr(0, sp) : line;
            std::string_view args = (sp != std::string_view::npos) ? line.substr(sp + 1) : std::string_view{};

            // Simple replication: just apply SET/DEL commands
            auto extract_key = [](std::string_view a) -> std::pair<std::string_view, std::string_view> {
                size_t s = a.find(' ');
                if (s == std::string_view::npos) return {a, {}};
                return {a.substr(0, s), a.substr(s + 1)};
            };

            switch (fnv1a_lower(cmd))
            {
                case fnv1a("set"):
                {
                    auto [key, val] = extract_key(args);
                    if (!key.empty() && !val.empty())
                        m_store.set(key, val);
                    break;
                }
                case fnv1a("del"):
                    if (!args.empty())
                        m_store.del(args);
                    break;
                case fnv1a("lpush"):
                {
                    auto [key, val] = extract_key(args);
                    if (!key.empty() && !val.empty())
                        m_store.lpush(key, val);
                    break;
                }
                case fnv1a("rpush"):
                {
                    auto [key, val] = extract_key(args);
                    if (!key.empty() && !val.empty())
                        m_store.rpush(key, val);
                    break;
                }
                case fnv1a("sadd"):
                {
                    auto [key, member] = extract_key(args);
                    if (!key.empty() && !member.empty())
                        m_store.sadd(key, member);
                    break;
                }
                case fnv1a("hset"):
                {
                    auto [key, rest] = extract_key(args);
                    auto [field, val] = extract_key(rest);
                    if (!key.empty() && !field.empty() && !val.empty())
                        m_store.hset(key, field, val);
                    break;
                }
                default:
                    break;
            }

            m_mode = saved;
        }

        scan_from = pos + 1;
    }

    if (scan_from > 0)
    {
        if (scan_from >= m_master_partial.size())
            m_master_partial.clear();
        else
            m_master_partial = m_master_partial.substr(scan_from);
    }

    // Re-submit read
    if (m_loop && m_master_fd >= 0)
        m_loop->submit_read(m_master_fd, m_master_read_buf, sizeof(m_master_read_buf), &m_master_read_req);
}

// ─── Stats ───

std::string cache_instance::get_stats() const
{
    std::string base = runtime_instance::get_stats();
    std::ostringstream out;
    out << base
        << "keys:" << m_store.size() << "\n"
        << "commands_processed:" << m_stat_commands << "\n"
        << "get_hits:" << m_stat_get_hits << "\n"
        << "get_misses:" << m_stat_get_misses << "\n"
        << "keys_expired:" << m_stat_keys_expired << "\n"
        << "mode:" << static_cast<int>(m_mode) << "\n"
        << "max_memory:" << m_store.get_max_memory() << "\n"
        << "memory_used:" << m_store.get_memory_used() << "\n"
        << "eviction:" << static_cast<int>(m_store.get_eviction()) << "\n"
        << "channels:" << m_store.channel_count() << "\n"
        << "repl_role:" << static_cast<int>(m_repl_role) << "\n"
        << "followers:" << m_follower_fds.size() << "\n";
    return out.str();
}

#endif // SOCKETLEY_IMPLEMENTATION

#endif // SOCKETLEY_H
