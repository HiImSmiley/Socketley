    <ul id="navList-addons" style="display:none">
      <li class="open"><a href="#addons-overview">Overview</a></li>
      <li><a href="#addons-auth">Auth Middleware</a><ul>
        <li><a href="#addons-auth-ip">IP Allowlist</a></li>
        <li><a href="#addons-auth-token">Token Auth</a></li>
      </ul></li>
      <li><a href="#addons-rate-limit">Rate Limiting</a></li>
      <li><a href="#addons-clients-multicast">Client Enumeration &amp; Multicast</a></li>
      <li><a href="#addons-metadata">Per-Connection Metadata</a></li>
      <li><a href="#addons-timers">Timers</a></li>
      <li><a href="#addons-proxy-hooks">Proxy Data Hooks</a></li>
      <li><a href="#addons-pubsub">Cross-Runtime Pub/Sub</a></li>
      <li><a href="#addons-cluster-events">Cluster Events</a><ul>
        <li><a href="#addons-cluster-join">on_cluster_join / leave</a></li>
        <li><a href="#addons-group-change">on_group_change</a></li>
      </ul></li>
      <li><a href="#addons-http">HTTP Calls</a><ul>
        <li><a href="#addons-http-api">socketley.http API</a></li>
        <li><a href="#addons-http-https">HTTPS</a></li>
      </ul></li>
      <li><a href="#addons-service-discovery">Service Discovery</a></li>
      <li><a href="#addons-metrics">Metrics Push</a></li>
      <li><a href="#db-backend">DB Backend Hooks</a><ul>
        <li><a href="#cb-on-miss">on_miss</a></li>
        <li><a href="#cb-on-write">on_write</a></li>
        <li><a href="#cb-on-delete-expire">on_delete / on_expire</a></li>
        <li><a href="#db-sqlite">SQLite</a></li>
        <li><a href="#db-mysql">MySQL / MariaDB</a></li>
        <li><a href="#db-postgres">PostgreSQL</a></li>
        <li><a href="#db-patterns">Write-Behind vs Write-Through</a></li>
      </ul></li>
      <li><a href="#addons-mq">Message Queue Bridge</a></li>
      <li><a href="#addons-redis-session">Distributed State</a></li>
      <li><a href="#addons-session-ids">Session IDs</a></li>
    </ul>
<div id="content-addons" class="content" style="display:none">

<h2 id="addons-overview">Addons</h2>
<p>Socketley's Lua scripting layer enables pure-Lua addon patterns that extend servers with auth middleware, rate limiting, service discovery, metrics push, and more — without touching C++ code. This page documents the primitives that make these patterns possible and shows working examples for each use case.</p>

<h2 id="addons-auth">Auth Middleware</h2>
<p>Two complementary auth patterns cover the most common cases: IP-based admission (via <code>on_auth</code>) and first-message token auth (via <code>self.disconnect</code>).</p>

<h3 id="addons-auth-ip">IP Allowlist</h3>
<p><code>on_auth(client_id)</code> fires immediately after a TCP accept, before <code>on_connect</code>. Return <code>true</code> to admit the client or <code>false</code> to reject and close the connection. Rejected clients never trigger <code>on_connect</code>.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">on_auth</span><span class="method-sig">(client_id) &rarr; bool</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Called before <code>on_connect</code>. Return <code>false</code> (or raise an error) to reject. Fail-closed: if the callback throws, the client is rejected.</div>
</div>

<div class="method-card">
<div class="method-header"><span class="method-name">self.peer_ip</span><span class="method-sig">(client_id) &rarr; string</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Returns the client's IP address (IPv4 or IPv6 string). Calls <code>getpeername()</code> at call time; works in any callback including <code>on_auth</code>.</div>
</div>

<pre><code><span class="cm">-- auth-ip-allowlist.lua</span>
<span class="kw">local</span> allowed_prefix = <span class="st">"192.168."</span>

<span class="kw">function</span> <span class="fn">on_auth</span>(client_id)
    <span class="kw">local</span> ip = self.peer_ip(client_id)
    <span class="kw">local</span> ok = ip:sub(<span class="nb">1</span>, #allowed_prefix) == allowed_prefix
    <span class="kw">if not</span> ok <span class="kw">then</span>
        socketley.log(<span class="st">"rejected: "</span> .. ip)
    <span class="kw">end</span>
    <span class="kw">return</span> ok
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    self.broadcast(<span class="st">"["</span> .. tostring(client_id) .. <span class="st">"] "</span> .. msg)
<span class="kw">end</span></code></pre>

<pre><code><span class="cm"># Test: 127.0.0.1 is not in 192.168. → rejected immediately</span>
socketley create server authtest -p 19100 --lua auth-ip-allowlist.lua -s
nc 127.0.0.1 19100   <span class="cm"># connection is closed before any data exchange</span></code></pre>

<h3 id="addons-auth-token">Token Auth</h3>
<p>For protocol-level auth (e.g., an API token as the first message), use <code>self.disconnect(client_id)</code> to close the connection from inside a callback.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">self.disconnect</span><span class="method-sig">(client_id)</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Gracefully terminates a client connection. Calls <code>shutdown(SHUT_RDWR)</code> on the fd — the pending read CQE completes with EOF, which triggers <code>on_disconnect</code> and cleans up the slot normally. Safe to call at any time from any server callback.</div>
</div>

<pre><code><span class="cm">-- auth-token.lua</span>
<span class="kw">local</span> SECRET = <span class="st">"my-secret-token"</span>
<span class="kw">local</span> authenticated = {}

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)    authenticated[client_id] = <span class="kw">false</span> <span class="kw">end</span>
<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id) authenticated[client_id] = <span class="kw">nil</span>   <span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="kw">if not</span> authenticated[client_id] <span class="kw">then</span>
        <span class="kw">if</span> msg == SECRET <span class="kw">then</span>
            authenticated[client_id] = <span class="kw">true</span>
            self.send(client_id, <span class="st">"AUTH OK"</span>)
        <span class="kw">else</span>
            self.send(client_id, <span class="st">"AUTH FAIL"</span>)
            self.disconnect(client_id)
        <span class="kw">end</span>
        <span class="kw">return</span>
    <span class="kw">end</span>
    self.broadcast(<span class="st">"["</span> .. tostring(client_id) .. <span class="st">"] "</span> .. msg)
<span class="kw">end</span></code></pre>

<h2 id="addons-websocket-session">WebSocket Session Identity</h2>
<p>When a browser connects via WebSocket, the HTTP upgrade request automatically carries rich identity information: <code>Cookie</code>, <code>Origin</code>, <code>Sec-WebSocket-Protocol</code>, and <code>Authorization</code>. The <code>on_websocket</code> callback fires after the handshake completes and exposes these headers as a Lua table.</p>
<p>This is the preferred mechanism for cross-session identity: the session cookie set by your web app's login flow is forwarded automatically by the browser on every WebSocket reconnect, giving you a durable identifier that survives fd recycling and IP changes.</p>

<div class="method-card" id="cb-on-websocket">
<div class="method-header"><span class="method-name">on_websocket</span><span class="method-sig">(client_id, headers)</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Called immediately after a WebSocket upgrade handshake completes, after <code>on_connect</code> has already fired. <code>headers</code> is a Lua table with any subset of: <code>cookie</code>, <code>origin</code>, <code>protocol</code> (Sec-WebSocket-Protocol), <code>authorization</code>. Absent headers are nil. Never fires for plain TCP clients.</div>
</div>

<div class="method-card">
<div class="method-header"><span class="method-name">self.ws_headers</span><span class="method-sig">(client_id) &rarr; table | nil</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Returns the stored WebSocket upgrade headers table for a connected client, or <code>nil</code> if the client is a plain TCP connection. Same keys as the <code>on_websocket</code> <code>headers</code> argument. Can be called from any server callback after the handshake.</div>
</div>

<pre><code><span class="cm">-- websocket-session.lua</span>
<span class="kw">local</span> cjson    = require <span class="st">"cjson"</span>
<span class="kw">local</span> sessions = {}   <span class="cm">-- client_id → { sid, ip, origin }</span>

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)
    sessions[client_id] = { sid = tostring(client_id), ip = self.peer_ip(client_id) }
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_websocket</span>(client_id, headers)
    <span class="kw">local</span> sid = sessions[client_id] <span class="kw">and</span> sessions[client_id].sid <span class="kw">or</span> tostring(client_id)
    <span class="kw">if</span> headers.cookie <span class="kw">then</span>
        sid = headers.cookie:match(<span class="st">"session_id=([^;%s]+)"</span>) <span class="kw">or</span> sid
    <span class="kw">end</span>
    sessions[client_id] = { sid = sid, ip = self.peer_ip(client_id), origin = headers.origin <span class="kw">or</span> <span class="st">"unknown"</span> }
    socketley.log(<span class="st">"ws connect sid="</span> .. sid .. <span class="st">" origin="</span> .. (headers.origin <span class="kw">or</span> <span class="st">"?"</span>))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id)
    <span class="kw">local</span> s = sessions[client_id]
    <span class="kw">if</span> s <span class="kw">then</span> socketley.log(<span class="st">"disconnect sid="</span> .. s.sid) sessions[client_id] = <span class="kw">nil</span> <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="kw">local</span> s = sessions[client_id] <span class="kw">or</span> {}
    self.broadcast(cjson.encode({ sid = s.sid, data = msg }))
<span class="kw">end</span></code></pre>

<pre><code><span class="cm"># Start server and connect with a cookie header</span>
socketley start ws-test --lua websocket-session.lua --port 9000
wscat --header <span class="st">"Cookie: session_id=abc123"</span> --connect ws://localhost:9000
<span class="cm"># Logs: ws connect sid=abc123 origin=?</span>
<span class="cm"># Reconnect with same cookie → same sid=abc123</span></code></pre>

<h2 id="addons-rate-limit">Rate Limiting</h2>
<p>Combine <code>self.disconnect</code> with <code>on_tick</code> to enforce a per-client message budget. No external deps required — pure Lua.</p>

<pre><code><span class="cm">-- rate-limit.lua: 10 messages per second per client</span>
<span class="kw">local</span> MAX_MSGS = <span class="nb">10</span>
<span class="kw">local</span> counts   = {}
tick_ms = <span class="nb">1000</span>

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)    counts[client_id] = <span class="nb">0</span>   <span class="kw">end</span>
<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id) counts[client_id] = <span class="kw">nil</span> <span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    counts[client_id] = (counts[client_id] <span class="kw">or</span> <span class="nb">0</span>) + <span class="nb">1</span>
    <span class="kw">if</span> counts[client_id] > MAX_MSGS <span class="kw">then</span>
        self.send(client_id, <span class="st">"ERROR rate limit exceeded"</span>)
        self.disconnect(client_id)
        <span class="kw">return</span>
    <span class="kw">end</span>
    self.broadcast(msg)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">for</span> id <span class="kw">in</span> pairs(counts) <span class="kw">do</span> counts[id] = <span class="nb">0</span> <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<h2 id="addons-clients-multicast">Client Enumeration &amp; Multicast</h2>
<p>Two primitives fill the gap between single-target <code>self.send</code> and full-fanout <code>self.broadcast</code>: <code>self.clients()</code> enumerates connected client IDs and <code>self.multicast(ids, msg)</code> sends to an arbitrary subset in one call.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">self.clients</span><span class="method-sig">() &rarr; table</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Returns a Lua table (1-based array) of all currently connected client fd integers. The list is a snapshot — clients that disconnect before you iterate it are safe to ignore (send to them simply does nothing).</div>
</div>

<div class="method-card">
<div class="method-header"><span class="method-name">self.multicast</span><span class="method-sig">(ids, msg)</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Send <code>msg</code> to every client_id in the <code>ids</code> table. Silently skips invalid or already-disconnected fds. Uses the same zero-copy shared-string path as <code>broadcast</code>.</div>
</div>

<pre><code><span class="cm">-- multicast.lua: send to clients tagged as "subscriber"</span>
<span class="kw">local</span> subs = {}

<span class="kw">function</span> <span class="fn">on_connect</span>(id) subs[id] = <span class="kw">false</span> <span class="kw">end</span>
<span class="kw">function</span> <span class="fn">on_disconnect</span>(id) subs[id] = <span class="kw">nil</span> <span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(id, msg)
    <span class="kw">if</span> msg == <span class="st">"SUBSCRIBE"</span> <span class="kw">then</span>
        subs[id] = <span class="kw">true</span>
        self.send(id, <span class="st">"OK subscribed"</span>)
    <span class="kw">elseif</span> msg:sub(<span class="nb">1</span>,<span class="nb">9</span>) == <span class="st">"PUBLISH: "</span> <span class="kw">then</span>
        <span class="kw">local</span> targets = {}
        <span class="kw">for</span> cid, is_sub <span class="kw">in</span> pairs(subs) <span class="kw">do</span>
            <span class="kw">if</span> is_sub <span class="kw">then</span> targets[#targets+<span class="nb">1</span>] = cid <span class="kw">end</span>
        <span class="kw">end</span>
        self.multicast(targets, msg:sub(<span class="nb">10</span>))
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<h2 id="addons-metadata">Per-Connection Metadata</h2>
<p>Store arbitrary string key/value pairs on a connection without a separate Lua table. Metadata is freed automatically when the client disconnects — no <code>on_disconnect</code> cleanup needed.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">self.set_data</span><span class="method-sig">(id, key, val)</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Attach a string value to client <code>id</code> under <code>key</code>. Pass <code>nil</code> as <code>val</code> to delete the key.</div>
</div>

<div class="method-card">
<div class="method-header"><span class="method-name">self.get_data</span><span class="method-sig">(id, key) &rarr; string | nil</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Retrieve the value stored under <code>key</code> for client <code>id</code>, or <code>nil</code> if not set.</div>
</div>

<pre><code><span class="cm">-- metadata.lua: store username on auth, access in message handler</span>
<span class="kw">function</span> <span class="fn">on_client_message</span>(id, msg)
    <span class="kw">if</span> <span class="kw">not</span> self.get_data(id, <span class="st">"user"</span>) <span class="kw">then</span>
        <span class="cm">-- First message: treat as login</span>
        self.set_data(id, <span class="st">"user"</span>, msg:match(<span class="st">"^LOGIN (%S+)"</span>))
        self.send(id, <span class="st">"OK"</span>)
        <span class="kw">return</span>
    <span class="kw">end</span>
    <span class="kw">local</span> user = self.get_data(id, <span class="st">"user"</span>)
    self.broadcast(<span class="st">"["</span> .. user .. <span class="st">"] "</span> .. msg)
<span class="kw">end</span>

<span class="cm">-- No on_disconnect needed — metadata freed with connection</span></code></pre>

<h2 id="addons-timers">Timers</h2>
<p>One-shot and repeating timers backed by io_uring <code>IORING_OP_TIMEOUT</code> — no extra threads, no polling. Each timer fires on the runtime's event loop turn.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">socketley.set_timeout</span><span class="method-sig">(ms, fn)</span><span class="badge badge-all">all</span></div>
<div class="method-desc">Fire <code>fn()</code> once after <code>ms</code> milliseconds. The timer is automatically freed after firing.</div>
</div>

<div class="method-card">
<div class="method-header"><span class="method-name">socketley.set_interval</span><span class="method-sig">(ms, fn)</span><span class="badge badge-all">all</span></div>
<div class="method-desc">Fire <code>fn()</code> every <code>ms</code> milliseconds. The interval continues until the runtime's Lua context is destroyed (i.e. on stop). No explicit cancel API — intervals are bounded to the runtime lifetime.</div>
</div>

<pre><code><span class="cm">-- timers.lua: one-shot warmup delay + repeating heartbeat</span>
<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="cm">-- Fire once after 2 seconds</span>
    socketley.set_timeout(<span class="nb">2000</span>, <span class="kw">function</span>()
        socketley.log(<span class="st">"warmup complete"</span>)
        self.broadcast(<span class="st">"SERVER READY"</span>)
    <span class="kw">end</span>)

    <span class="cm">-- Fire every 5 seconds</span>
    socketley.set_interval(<span class="nb">5000</span>, <span class="kw">function</span>()
        self.broadcast(<span class="st">"heartbeat conns="</span> .. tostring(self.connections()))
    <span class="kw">end</span>)
<span class="kw">end</span></code></pre>

<h2 id="addons-proxy-hooks">Proxy Data Hooks</h2>
<p>Intercept, modify, or drop data at the proxy layer without touching backend or client code. Both hooks follow the same contract: return a modified string to replace the chunk, or <code>nil</code> to drop it entirely.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">on_proxy_request</span><span class="method-sig">(client_id, data) &rarr; string | nil</span><span class="badge badge-proxy">proxy</span></div>
<div class="method-desc">Called for every chunk forwarded from a client to a backend. Return a replacement string or <code>nil</code> to drop. Fires before the data is queued for the backend write.</div>
</div>

<div class="method-card">
<div class="method-header"><span class="method-name">on_proxy_response</span><span class="method-sig">(client_id, data) &rarr; string | nil</span><span class="badge badge-proxy">proxy</span></div>
<div class="method-desc">Called for every chunk forwarded from a backend to a client. Same semantics as <code>on_proxy_request</code>.</div>
</div>

<pre><code><span class="cm">-- proxy-hooks.lua: uppercase requests, add header to responses</span>
<span class="kw">function</span> <span class="fn">on_proxy_request</span>(client_id, data)
    <span class="kw">return</span> data:upper()   <span class="cm">-- modify</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_proxy_response</span>(client_id, data)
    <span class="cm">-- Drop responses containing "SECRET"</span>
    <span class="kw">if</span> data:find(<span class="st">"SECRET"</span>) <span class="kw">then</span> <span class="kw">return</span> <span class="kw">nil</span> <span class="kw">end</span>
    <span class="kw">return</span> data
<span class="kw">end</span></code></pre>

<h2 id="addons-pubsub">Cross-Runtime Pub/Sub</h2>
<p>A runtime's Lua script can now subscribe to any named cache runtime's publish channel — no RESP client socket required. <code>socketley.subscribe</code> registers a callback that fires on the subscribing runtime's event loop turn whenever the cache publishes to that channel.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">socketley.subscribe</span><span class="method-sig">(cache_name, channel, fn)</span><span class="badge badge-all">all</span></div>
<div class="method-desc">Register <code>fn(channel, message)</code> to fire whenever the named cache runtime publishes to <code>channel</code>. Multiple subscriptions to the same channel stack and all fire in registration order. The callback is bound to the subscribing runtime's Lua context and freed when the runtime stops.</div>
</div>

<pre><code><span class="cm">-- pubsub-server.lua: server reacts to cache publish events</span>
<span class="kw">function</span> <span class="fn">on_start</span>()
    socketley.subscribe(<span class="st">"events"</span>, <span class="st">"alerts"</span>, <span class="kw">function</span>(ch, msg)
        socketley.log(<span class="st">"alert: "</span> .. msg)
        self.broadcast(<span class="st">"ALERT: "</span> .. msg)
    <span class="kw">end</span>)
<span class="kw">end</span>

<span class="cm">-- pubsub-cache.lua: cache script that publishes alerts</span>
<span class="kw">function</span> <span class="fn">on_write</span>(key, value, ttl)
    <span class="kw">if</span> key:sub(<span class="nb">1</span>,<span class="nb">6</span>) == <span class="st">"alert:"</span> <span class="kw">then</span>
        self.publish(<span class="st">"alerts"</span>, value)
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<pre><code><span class="cm"># Wire it up:</span>
socketley create cache events --port 9100 --lua pubsub-cache.lua
socketley create server api   --port 9000 --lua pubsub-server.lua
socketley start events
socketley start api</code></pre>

<h2 id="addons-cluster-events">Cluster Event Callbacks</h2>
<p>React to cluster topology changes from Lua. These optional callbacks fire when daemons join or leave the cluster, or when a group's membership count changes. Events are detected during the 2-second scan/publish cycle, so callbacks may fire up to 2&nbsp;seconds after the actual change.</p>

<div class="info-box"><strong>Requires cluster mode.</strong> These callbacks only fire when cluster mode is enabled (<code>daemon --name</code> + <code>daemon --cluster</code>). A daemon is considered stale and triggers <code>on_cluster_leave</code> after 10&nbsp;seconds without a heartbeat update.</div>

<div class="callback-card" id="addons-cluster-join">
<div class="method-header"><span class="method-name">on_cluster_join(daemon)</span><span class="badge badge-cluster">cluster</span></div>
<div class="fires">Fires when a new remote daemon is discovered in the cluster directory.</div>
<table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>daemon.name</td><td>string</td><td>The new daemon's name</td></tr>
<tr><td>daemon.host</td><td>string</td><td>The new daemon's advertised address</td></tr>
</tbody></table>
</div>

<div class="callback-card" id="addons-cluster-leave">
<div class="method-header"><span class="method-name">on_cluster_leave(daemon)</span><span class="badge badge-cluster">cluster</span></div>
<div class="fires">Fires when a remote daemon's heartbeat becomes stale (&gt;10s) or its file is removed.</div>
<table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>daemon.name</td><td>string</td><td>The departed daemon's name</td></tr>
</tbody></table>
</div>

<div class="callback-card" id="addons-group-change">
<div class="method-header"><span class="method-name">on_group_change(group, members)</span><span class="badge badge-cluster">cluster</span></div>
<div class="fires">Fires when the total member count of a group changes &mdash; a runtime joins or leaves the group, or a daemon with group members appears or disappears. Only fires on actual count changes, not on every scan cycle.</div>
<table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>group</td><td>string</td><td>The group name</td></tr>
<tr><td>members</td><td>table</td><td>Array of <code>{daemon, host, port}</code> for current group members</td></tr>
</tbody></table>
</div>

<pre><code><span class="cm">-- cluster-failover.lua: maintain a live routing table for the "api" group</span>
<span class="kw">local</span> backends = {}

<span class="kw">function</span> <span class="fn">on_cluster_join</span>(daemon)
    socketley.log(<span class="st">"daemon joined: "</span> .. daemon.name .. <span class="st">" @ "</span> .. daemon.host)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_cluster_leave</span>(daemon)
    socketley.log(<span class="st">"daemon left: "</span> .. daemon.name)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_group_change</span>(group, members)
    <span class="kw">if</span> group == <span class="st">"api"</span> <span class="kw">then</span>
        backends = members
        socketley.log(<span class="st">"api group now has "</span> .. #members .. <span class="st">" members"</span>)
    <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="cm">-- Initial cluster snapshot</span>
    <span class="kw">local</span> stats = socketley.cluster.stats()
    socketley.log(<span class="st">"cluster: "</span> .. stats.daemons .. <span class="st">" daemons, "</span>
                  .. stats.running .. <span class="st">"/"</span> .. stats.runtimes .. <span class="st">" running"</span>)

    <span class="cm">-- Seed the routing table</span>
    backends = socketley.cluster.group(<span class="st">"api"</span>)
    socketley.log(<span class="st">"api group: "</span> .. #backends .. <span class="st">" members"</span>)
<span class="kw">end</span></code></pre>

<pre><code><span class="cm"># Configure two daemons for cluster mode + create api servers + monitoring:</span>
socketley daemon --name node1 --cluster /shared/cluster
socketley daemon --name node2 --cluster /shared/cluster

<span class="cm"># On node1: api server + monitoring server with cluster callbacks</span>
SOCKETLEY_SOCKET=/tmp/node1.sock socketley create server api1 -p 9001 -g api -s
SOCKETLEY_SOCKET=/tmp/node1.sock socketley create server monitor -p 9100 --lua cluster-failover.lua -s

<span class="cm"># On node2: api server (triggers on_cluster_join + on_group_change on node1)</span>
SOCKETLEY_SOCKET=/tmp/node2.sock socketley create server api2 -p 9002 -g api -s</code></pre>

<div class="info-box"><strong>Combining introspection + events.</strong> Use <code>socketley.cluster.group()</code> in <code>on_start</code> for the initial snapshot, then keep it up-to-date via <code>on_group_change</code>. This avoids polling and gives you a near-real-time routing table with ~2s convergence.</div>

<h2 id="addons-http">HTTP Calls</h2>

<h3 id="addons-http-api">socketley.http API</h3>
<p>Make synchronous HTTP or HTTPS requests from Lua scripts using <code>socketley.http(opts)</code>.</p>

<div class="warn-box"><strong>Blocks the event loop.</strong> <code>socketley.http</code> is a synchronous call that blocks the single-threaded event loop for the duration of the request. Use it only in <code>on_start</code>, <code>on_stop</code>, or low-frequency <code>on_tick</code> callbacks (e.g., <code>tick_ms = 30000</code>). Never call it from <code>on_client_message</code> or <code>on_connect</code> under load.</div>

<div class="method-card" id="addons-http-api">
<div class="method-header"><span class="method-name">socketley.http</span><span class="method-sig">(opts) &rarr; table</span><span class="badge badge-all">all</span></div>
<div class="method-desc">
  Sends a synchronous HTTP/1.0 request. Returns <code>{ok, status, body, error}</code>.
  <br><br>
  <strong>opts keys:</strong> <code>url</code> (required), <code>method</code> (default <code>"GET"</code>), <code>body</code>, <code>headers</code> (table), <code>timeout_ms</code> (default 5000).
</div>
</div>

<pre><code><span class="cm">-- Simple GET</span>
<span class="kw">local</span> res = socketley.http({ url = <span class="st">"http://127.0.0.1:8500/v1/status/leader"</span> })
<span class="kw">if</span> res.ok <span class="kw">then</span>
    socketley.log(<span class="st">"leader: "</span> .. res.body)
<span class="kw">else</span>
    socketley.log(<span class="st">"error: "</span> .. res.error)
<span class="kw">end</span>

<span class="cm">-- POST with JSON body</span>
<span class="kw">local</span> res = socketley.http({
    method  = <span class="st">"POST"</span>,
    url     = <span class="st">"http://127.0.0.1:9091/metrics/job/myapp"</span>,
    body    = <span class="st">"connections "</span> .. tostring(self.connections()) .. <span class="st">"\n"</span>,
    headers = { [<span class="st">"Content-Type"</span>] = <span class="st">"text/plain"</span> },
})</code></pre>

<h3 id="addons-http-https">HTTPS</h3>
<p>HTTPS is supported via OpenSSL. Certificate validation is skipped (<code>SSL_VERIFY_NONE</code>) — suitable for trusted internal services (Consul, etcd, Prometheus Pushgateway on localhost).</p>
<p>For external HTTPS with certificate validation, use <code>io.popen</code> (available in Lua scripts since <code>sol::lib::io</code> is opened):</p>
<pre><code><span class="cm">-- Fallback via curl for full cert validation</span>
<span class="kw">local</span> f = io.popen(<span class="st">"curl -s https://api.example.com/health"</span>)
<span class="kw">local</span> body = f:read(<span class="st">"*a"</span>)
f:close()</code></pre>

<h2 id="addons-service-discovery">Service Discovery</h2>
<p>Register and deregister this runtime with Consul (or any HTTP-based registry) using <code>socketley.http</code> in <code>on_start</code>/<code>on_stop</code>.</p>

<pre><code><span class="cm">-- service-discovery.lua — Consul registration</span>
<span class="kw">local</span> CONSUL = <span class="st">"http://127.0.0.1:8500"</span>

<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="kw">local</span> payload = string.format(
        <span class="st">'{"ID":"%s","Name":"%s","Port":%d}'</span>,
        self.name, self.name, self.port)
    socketley.http({
        method  = <span class="st">"PUT"</span>,
        url     = CONSUL .. <span class="st">"/v1/agent/service/register"</span>,
        body    = payload,
        headers = { [<span class="st">"Content-Type"</span>] = <span class="st">"application/json"</span> },
    })
    socketley.log(<span class="st">"registered with Consul: "</span> .. self.name)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_stop</span>()
    socketley.http({
        method = <span class="st">"PUT"</span>,
        url    = CONSUL .. <span class="st">"/v1/agent/service/deregister/"</span> .. self.name,
    })
<span class="kw">end</span></code></pre>

<p>The same pattern works with etcd (PUT to <code>/v3/kv/put</code>), Eureka (POST to <code>/eureka/apps/&lt;name&gt;</code>), or any REST-based registry.</p>

<h2 id="addons-metrics">Metrics Push</h2>
<p>Push runtime metrics to Prometheus Pushgateway every N seconds using <code>on_tick</code> + <code>socketley.http</code>.</p>

<pre><code><span class="cm">-- metrics-push.lua — Prometheus Pushgateway</span>
<span class="kw">local</span> PUSHGW = <span class="st">"http://127.0.0.1:9091"</span>
tick_ms = <span class="nb">30000</span>   <span class="cm">-- push every 30 s</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">local</span> conns = self.connections()
    <span class="kw">local</span> body  = string.format(
        <span class="st">"# HELP socketley_connections Active TCP connections\n"</span> ..
        <span class="st">"# TYPE socketley_connections gauge\n"</span> ..
        <span class="st">"socketley_connections{runtime=\"%s\"} %d\n"</span>,
        self.name, conns)
    socketley.http({
        method  = <span class="st">"POST"</span>,
        url     = PUSHGW .. <span class="st">"/metrics/job/socketley/instance/"</span> .. self.name,
        body    = body,
        headers = { [<span class="st">"Content-Type"</span>] = <span class="st">"text/plain; version=0.0.4"</span> },
    })
<span class="kw">end</span></code></pre>

<h2 id="db-backend">Database Backend Hooks</h2>
<p>Four Lua callbacks wire the cache to any database — no built-in drivers, no C++ changes required. Install a Lua DB library with <code>luarocks</code>, implement the callbacks you need, and the cache handles read-through population and write propagation automatically.</p>
<table><thead><tr><th>Callback</th><th>Signature</th><th>Fires when</th></tr></thead><tbody>
<tr><td><code>on_miss(key)</code></td><td><code>&rarr; value [, ttl_seconds]</code></td><td>GET returns nil — fetch from DB</td></tr>
<tr><td><code>on_write(key, value, ttl)</code></td><td>&rarr; nothing</td><td>After SET / SETEX / SETNX / MSET</td></tr>
<tr><td><code>on_delete(key)</code></td><td>&rarr; nothing</td><td>After DEL</td></tr>
<tr><td><code>on_expire(key)</code></td><td>&rarr; nothing</td><td>After TTL sweep removes key</td></tr>
</tbody></table>
<div class="info-box"><strong>Zero overhead when unused.</strong> Each hook is a single boolean check on the event loop thread — if the callback is not defined in your script, execution falls straight through with no extra work.</div>

<div class="callback-card" id="cb-on-miss">
<div class="method-header"><span class="method-name">on_miss(key)</span><span class="method-sig"> &rarr; value [, ttl_seconds]</span><span class="badge badge-cache">cache</span></div>
<div class="fires">Fires when a GET misses the in-memory store. Return a value (and optional TTL in seconds) to populate the cache transparently and return it to the client. Return nil to pass the miss through to the client normally.</div>
<pre><code><span class="kw">function</span> <span class="fn">on_miss</span>(key)
    <span class="kw">local</span> value = db_fetch(key)
    <span class="kw">if</span> value <span class="kw">then</span>
        <span class="kw">return</span> value, <span class="nb">300</span>  <span class="cm">-- populate cache, expire after 300 s</span>
    <span class="kw">end</span>
    <span class="cm">-- return nil → client receives nil, nothing cached</span>
<span class="kw">end</span></code></pre>
</div>

<div class="callback-card" id="cb-on-write">
<div class="method-header"><span class="method-name">on_write(key, value, ttl)</span><span class="badge badge-cache">cache</span></div>
<div class="fires">Fires after every successful SET, SETEX, PSETEX, SETNX, or MSET. <code>ttl</code> is the expiry in seconds (0 = no TTL). Runs synchronously on the event loop thread — for write-heavy workloads use the <strong>write-behind</strong> pattern: buffer in this callback, flush to the DB in <code>on_tick</code>.</div>
<pre><code><span class="kw">local</span> pending = {}

<span class="kw">function</span> <span class="fn">on_write</span>(key, value, ttl)
    pending[key] = value  <span class="cm">-- buffer — instant return to client</span>
<span class="kw">end</span>

tick_ms = <span class="nb">2000</span>
<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">if</span> <span class="kw">not</span> next(pending) <span class="kw">then</span> <span class="kw">return</span> <span class="kw">end</span>
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db_upsert(k, v)
    <span class="kw">end</span>
    pending = {}
<span class="kw">end</span></code></pre>
</div>

<div class="callback-card" id="cb-on-delete-expire">
<div class="method-header"><span class="method-name">on_delete(key)</span>&ensp;<span class="method-name">on_expire(key)</span><span class="badge badge-cache">cache</span></div>
<div class="fires"><code>on_delete</code> fires after DEL. <code>on_expire</code> fires when the 100 ms background TTL sweep removes a key. <code>on_expire</code> does <em>not</em> delete from the DB by default — uncomment <code>on_delete(key)</code> below if you want expiry to propagate.</div>
<pre><code><span class="kw">function</span> <span class="fn">on_delete</span>(key)
    db:exec(<span class="st">"DELETE FROM kv WHERE key="</span> .. db:quote(key))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_expire</span>(key)
    socketley.log(<span class="st">"expired: "</span> .. key)
    <span class="cm">-- on_delete(key)  -- un-comment to propagate expiry to DB</span>
<span class="kw">end</span></code></pre>
</div>

<h3 id="db-sqlite">SQLite — lsqlite3</h3>
<p>Embedded, zero-config, no server required. Ideal for single-host deployments and local development.</p>
<pre><code>luarocks install lsqlite3</code></pre>
<pre><code><span class="cm">-- Attach: socketley create cache mydb -p 9000 --lua sqlite.lua -s</span>
<span class="kw">local</span> db, pending = <span class="kw">nil</span>, {}
tick_ms = <span class="nb">2000</span>

<span class="kw">function</span> <span class="fn">on_start</span>()
    db = require(<span class="st">"lsqlite3"</span>).open(<span class="st">"/tmp/cache.db"</span>)
    db:exec(<span class="st">"CREATE TABLE IF NOT EXISTS kv (key TEXT PRIMARY KEY, value TEXT)"</span>)
    socketley.log(<span class="st">"SQLite backend ready"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_miss</span>(key)
    <span class="kw">for</span> row <span class="kw">in</span> db:nrows(<span class="st">"SELECT value FROM kv WHERE key="</span> .. db:quote(key)) <span class="kw">do</span>
        <span class="kw">return</span> row.value, <span class="nb">300</span>  <span class="cm">-- value + TTL</span>
    <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_write</span>(key, value, ttl)
    pending[key] = value
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">if</span> <span class="kw">not</span> next(pending) <span class="kw">then</span> <span class="kw">return</span> <span class="kw">end</span>
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db:exec(<span class="st">"INSERT OR REPLACE INTO kv(key,value) VALUES("</span>
                ..db:quote(k)..<span class="st">","</span>..db:quote(v)..<span class="st">")"</span>)
    <span class="kw">end</span>
    pending = {}
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_delete</span>(key)
    pending[key] = <span class="kw">nil</span>
    db:exec(<span class="st">"DELETE FROM kv WHERE key="</span> .. db:quote(key))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_expire</span>(key)
    socketley.log(<span class="st">"expired: "</span> .. key)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_stop</span>()
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>  <span class="cm">-- flush before shutdown</span>
        db:exec(<span class="st">"INSERT OR REPLACE INTO kv(key,value) VALUES("</span>
                ..db:quote(k)..<span class="st">","</span>..db:quote(v)..<span class="st">")"</span>)
    <span class="kw">end</span>
    <span class="kw">if</span> db <span class="kw">then</span> db:close() <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<h3 id="db-mysql">MySQL / MariaDB — luasql-mysql</h3>
<pre><code>luarocks install luasql-mysql</code></pre>
<pre><code><span class="cm">-- Attach: socketley create cache mydb -p 9000 --lua mysql.lua -s</span>
<span class="cm">-- Schema: CREATE TABLE kv (k VARCHAR(512) PRIMARY KEY, v TEXT,</span>
<span class="cm">--                          updated_at TIMESTAMP DEFAULT NOW() ON UPDATE NOW());</span>
<span class="kw">local</span> env, db, pending = <span class="kw">nil</span>, <span class="kw">nil</span>, {}
tick_ms = <span class="nb">2000</span>

<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="kw">local</span> luasql = require(<span class="st">"luasql.mysql"</span>)
    env = luasql.mysql()
    db  = env:connect(<span class="st">"mydb"</span>, <span class="st">"user"</span>, <span class="st">"password"</span>, <span class="st">"127.0.0.1"</span>, <span class="nb">3306</span>)
    db:execute(<span class="st">"CREATE TABLE IF NOT EXISTS kv ("</span>
               ..<span class="st">"k VARCHAR(512) PRIMARY KEY, v TEXT)"</span>)
    socketley.log(<span class="st">"MySQL backend ready"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_miss</span>(key)
    <span class="kw">local</span> cur = db:execute(<span class="st">"SELECT v FROM kv WHERE k='"</span>
                           ..db:escape(key)..<span class="st">"'"</span>)
    <span class="kw">local</span> row = cur:fetch({}, <span class="st">"a"</span>)
    cur:close()
    <span class="kw">if</span> row <span class="kw">then</span> <span class="kw">return</span> row.v, <span class="nb">300</span> <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_write</span>(key, value, ttl)
    pending[key] = value
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">if</span> <span class="kw">not</span> next(pending) <span class="kw">then</span> <span class="kw">return</span> <span class="kw">end</span>
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db:execute(<span class="st">"INSERT INTO kv(k,v) VALUES('"</span>..db:escape(k)..<span class="st">"','"</span>
                   ..db:escape(v)..<span class="st">"') ON DUPLICATE KEY UPDATE v=VALUES(v)"</span>)
    <span class="kw">end</span>
    pending = {}
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_delete</span>(key)
    pending[key] = <span class="kw">nil</span>
    db:execute(<span class="st">"DELETE FROM kv WHERE k='"</span> .. db:escape(key) .. <span class="st">"'"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_expire</span>(key)
    socketley.log(<span class="st">"expired: "</span> .. key)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_stop</span>()
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db:execute(<span class="st">"INSERT INTO kv(k,v) VALUES('"</span>..db:escape(k)..<span class="st">"','"</span>
                   ..db:escape(v)..<span class="st">"') ON DUPLICATE KEY UPDATE v=VALUES(v)"</span>)
    <span class="kw">end</span>
    <span class="kw">if</span> db  <span class="kw">then</span> db:close()  <span class="kw">end</span>
    <span class="kw">if</span> env <span class="kw">then</span> env:close() <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<h3 id="db-postgres">PostgreSQL — luasql-postgres</h3>
<pre><code>luarocks install luasql-postgres</code></pre>
<pre><code><span class="cm">-- Attach: socketley create cache mydb -p 9000 --lua postgres.lua -s</span>
<span class="cm">-- Schema: CREATE TABLE IF NOT EXISTS kv (k TEXT PRIMARY KEY, v TEXT);</span>
<span class="kw">local</span> env, db, pending = <span class="kw">nil</span>, <span class="kw">nil</span>, {}
tick_ms = <span class="nb">2000</span>

<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="kw">local</span> luasql = require(<span class="st">"luasql.postgres"</span>)
    env = luasql.postgres()
    db  = env:connect(<span class="st">"host=127.0.0.1 dbname=mydb user=app password=secret"</span>)
    db:execute(<span class="st">"CREATE TABLE IF NOT EXISTS kv (k TEXT PRIMARY KEY, v TEXT)"</span>)
    socketley.log(<span class="st">"PostgreSQL backend ready"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_miss</span>(key)
    <span class="kw">local</span> cur = db:execute(<span class="st">"SELECT v FROM kv WHERE k='"</span>
                           ..db:escape(key)..<span class="st">"'"</span>)
    <span class="kw">local</span> row = cur:fetch({}, <span class="st">"a"</span>)
    cur:close()
    <span class="kw">if</span> row <span class="kw">then</span> <span class="kw">return</span> row.v, <span class="nb">300</span> <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_write</span>(key, value, ttl)
    pending[key] = value
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">if</span> <span class="kw">not</span> next(pending) <span class="kw">then</span> <span class="kw">return</span> <span class="kw">end</span>
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db:execute(<span class="st">"INSERT INTO kv(k,v) VALUES('"</span>..db:escape(k)..<span class="st">"','"</span>
                   ..db:escape(v)..<span class="st">"') ON CONFLICT(k) DO UPDATE SET v=EXCLUDED.v"</span>)
    <span class="kw">end</span>
    pending = {}
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_delete</span>(key)
    pending[key] = <span class="kw">nil</span>
    db:execute(<span class="st">"DELETE FROM kv WHERE k='"</span> .. db:escape(key) .. <span class="st">"'"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_expire</span>(key)
    socketley.log(<span class="st">"expired: "</span> .. key)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_stop</span>()
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db:execute(<span class="st">"INSERT INTO kv(k,v) VALUES('"</span>..db:escape(k)..<span class="st">"','"</span>
                   ..db:escape(v)..<span class="st">"') ON CONFLICT(k) DO UPDATE SET v=EXCLUDED.v"</span>)
    <span class="kw">end</span>
    <span class="kw">if</span> db  <span class="kw">then</span> db:close()  <span class="kw">end</span>
    <span class="kw">if</span> env <span class="kw">then</span> env:close() <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<h3 id="db-patterns">Write-Behind vs Write-Through</h3>
<table><thead><tr><th>Pattern</th><th>How</th><th>SET latency</th><th>Durability</th><th>Best for</th></tr></thead><tbody>
<tr><td><strong>Write-behind</strong></td><td>Buffer in <code>on_write</code>, flush in <code>on_tick</code></td><td>Cache only — instant</td><td>Up to <code>tick_ms</code> lag on crash</td><td>High write rate, latency-sensitive</td></tr>
<tr><td><strong>Write-through</strong></td><td>Call DB directly in <code>on_write</code></td><td>Cache + DB latency</td><td>Always in sync</td><td>Low write rate, strict durability</td></tr>
</tbody></table>
<div class="warn-box"><strong>Write-through saturation:</strong> At 1 ms/DB write, write-through saturates around 1 000 writes/s on a single-threaded event loop. Use write-behind for anything above that.</div>
<div class="info-box"><strong>Flush on shutdown:</strong> Always flush <code>pending</code> in <code>on_stop()</code> to avoid losing the last batch of writes when the cache is stopped cleanly.</div>


<h2 id="addons-mq">Message Queue Bridge</h2>
<p>Bridge connected clients to RabbitMQ, NATS, or Redis Streams using luarocks libraries inside server callbacks.</p>

<pre><code><span class="cm">-- nats-bridge.lua — forward all client messages to a NATS subject</span>
<span class="cm">-- Requires: luarocks install lua-nats (or similar binding)</span>
<span class="kw">local</span> nats

<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="kw">local</span> ok, mod = pcall(require, <span class="st">"nats"</span>)
    <span class="kw">if</span> ok <span class="kw">then</span>
        nats = mod.connect({ host = <span class="st">"127.0.0.1"</span>, port = <span class="nb">4222</span> })
        socketley.log(<span class="st">"NATS bridge connected"</span>)
    <span class="kw">else</span>
        socketley.log(<span class="st">"NATS not available: "</span> .. tostring(mod))
    <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="kw">if</span> nats <span class="kw">then</span>
        nats:publish(<span class="st">"socketley."</span> .. self.name, msg)
    <span class="kw">end</span>
    self.broadcast(msg)   <span class="cm">-- also relay to TCP clients</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_stop</span>()
    <span class="kw">if</span> nats <span class="kw">then</span> nats:close() <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<div class="info-box">
<strong>Tip — HTTP-based MQ:</strong> If your broker has an HTTP API (RabbitMQ Management, NATS JetStream), you can publish messages directly via <code>socketley.http</code> without any extra library:
<pre style="margin-top:0.5em;margin-bottom:0"><code>socketley.http({
    method = <span class="st">"POST"</span>,
    url    = <span class="st">"http://127.0.0.1:15672/api/exchanges/%2F/amq.default/publish"</span>,
    body   = <span class="st">'{"properties":{},"routing_key":"myqueue","payload":"'</span> .. msg .. <span class="st">'","payload_encoding":"string"}'</span>,
    headers = {
        [<span class="st">"Content-Type"</span>] = <span class="st">"application/json"</span>,
        [<span class="st">"Authorization"</span>] = <span class="st">"Basic Z3Vlc3Q6Z3Vlc3Q="</span>,  <span class="cm">-- guest:guest</span>
    },
})</code></pre>
</div>


<h2 id="addons-redis-session">Distributed Session / Shared State</h2>
<p>A single Socketley instance keeps state in plain Lua tables. For multi-instance deployments (load-balanced), shared state is needed: rate-limit counters, presence tracking, session data. <code>redis-lua</code> connects to an external Redis from within any Lua callback.</p>

<pre><code><span class="cm">-- luarocks install redis-lua</span>
<span class="kw">local</span> redis = require <span class="st">"redis"</span>
<span class="kw">local</span> r     = redis.connect(<span class="st">"127.0.0.1"</span>, <span class="nb">6379</span>)

<span class="kw">local</span> RATE_LIMIT = <span class="nb">20</span>  <span class="cm">-- max messages per second per IP</span>

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)
    r:sadd(<span class="st">"socketley:online"</span>, tostring(client_id))
    <span class="kw">local</span> key = <span class="st">"session:"</span> .. tostring(client_id)
    r:hset(key, <span class="st">"ip"</span>, self.peer_ip(client_id))
    r:expire(key, <span class="nb">3600</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id)
    r:srem(<span class="st">"socketley:online"</span>, tostring(client_id))
    r:del(<span class="st">"session:"</span> .. tostring(client_id))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="cm">-- Distributed rate limiting — shared across all server instances</span>
    <span class="kw">local</span> key = <span class="st">"rl:"</span> .. self.peer_ip(client_id)
    <span class="kw">local</span> n   = r:incr(key)
    <span class="kw">if</span> n == <span class="nb">1</span> <span class="kw">then</span> r:expire(key, <span class="nb">1</span>) <span class="kw">end</span>   <span class="cm">-- 1-second window</span>
    <span class="kw">if</span> n > RATE_LIMIT <span class="kw">then</span>
        self.send(client_id, <span class="st">"ERROR rate limit exceeded"</span>)
        self.disconnect(client_id)
        <span class="kw">return</span>
    <span class="kw">end</span>
    self.broadcast(msg)
<span class="kw">end</span></code></pre>

<div class="warn-box"><strong>Blocking calls.</strong> <code>redis-lua</code> uses synchronous sockets and blocks the io_uring event loop for the duration of each Redis round-trip. Keep calls in <code>on_start</code>/<code>on_stop</code> or rate-limit how often they fire in <code>on_client_message</code>. For high-frequency paths, batch writes in a local table and flush in <code>on_tick</code>.</div>

<p>Full example: <code>examples/server/redis-session.lua</code></p>


<h2 id="addons-session-ids">Session IDs &amp; Tracing</h2>
<p>Assign a UUID to each connection for end-to-end tracing across logs, metrics, and external systems. Pairs naturally with <code>cjson</code> (embed in outbound JSON envelopes) and <code>redis-lua</code> (use as the session store key).</p>

<pre><code><span class="cm">-- luarocks install uuid</span>
<span class="kw">local</span> uuid  = require <span class="st">"uuid"</span>
<span class="kw">local</span> cjson = require <span class="st">"cjson"</span>
uuid.seed()

<span class="kw">local</span> session_ids = {}

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)
    session_ids[client_id] = uuid()
    socketley.log(<span class="st">"connect sid="</span> .. session_ids[client_id]
                  .. <span class="st">" ip="</span> .. self.peer_ip(client_id))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id)
    socketley.log(<span class="st">"disconnect sid="</span> .. (session_ids[client_id] <span class="kw">or</span> <span class="st">"?"</span>))
    session_ids[client_id] = <span class="kw">nil</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="cm">-- Embed the session ID in every outbound message for distributed tracing</span>
    self.broadcast(cjson.encode({
        sid  = session_ids[client_id],
        from = client_id,
        data = msg,
    }))
<span class="kw">end</span></code></pre>

<div class="info-box"><strong>Tip — combine with redis-lua.</strong> Use the UUID as the Redis session store key (<code>r:hset("session:" .. session_ids[client_id], ...)</code>) so the same correlation ID flows from the TCP layer through your Redis session store and into your logs.</div>

<p>Full example: <code>examples/server/session-ids.lua</code></p>

</div><!-- #content-addons -->
