    <ul id="navList-socketley-sdk" style="display:none">
      <li class="open"><a href="#sdk-intro">Introduction</a><ul>
        <li><a href="#sdk-three-tiers">Three Tiers</a></li>
        <li><a href="#sdk-install">Installation</a></li>
        <li><a href="#sdk-quickstart">Quick Start</a></li>
      </ul></li>
      <li><a href="#sdk-t1">Tier 1: Daemon Control</a><ul>
        <li><a href="#sdk-t1-result">Result Type</a></li>
        <li><a href="#sdk-t1-runtime">Runtime Management</a></li>
        <li><a href="#sdk-t1-send">Send Behavior</a></li>
        <li><a href="#sdk-t1-cache">Cache Operations</a></li>
        <li><a href="#sdk-t1-action">Action Commands</a></li>
        <li><a href="#sdk-t1-raw">Raw Command</a></li>
        <li><a href="#sdk-t1-socket">Socket Path</a></li>
      </ul></li>
      <li><a href="#sdk-t2">Tier 2: Embed Engine</a><ul>
        <li><a href="#sdk-t2-build">Build &amp; Link</a></li>
        <li><a href="#sdk-t2-wrappers">Wrapper Classes</a></li>
        <li><a href="#sdk-t2-eventloop">event_loop</a></li>
        <li><a href="#sdk-t2-manager">runtime_manager</a></li>
        <li><a href="#sdk-t2-base">runtime_instance (Base)</a></li>
        <li><a href="#sdk-t2-callbacks">C++ Callbacks</a></li>
        <li><a href="#sdk-t2-server">server_instance</a></li>
        <li><a href="#sdk-t2-cache">cache_instance</a><ul>
          <li><a href="#sdk-t2-cache-strings">Strings</a></li>
          <li><a href="#sdk-t2-cache-lists">Lists</a></li>
          <li><a href="#sdk-t2-cache-sets">Sets</a></li>
          <li><a href="#sdk-t2-cache-hashes">Hashes</a></li>
          <li><a href="#sdk-t2-cache-ttl">TTL</a></li>
          <li><a href="#sdk-t2-cache-pubsub">Pub/Sub</a></li>
          <li><a href="#sdk-t2-cache-mgmt">Management</a></li>
          <li><a href="#sdk-t2-cache-textproto">Text Protocol</a></li>
        </ul></li>
        <li><a href="#sdk-t2-proxy">proxy_instance</a></li>
        <li><a href="#sdk-t2-client">client_instance</a></li>
        <li><a href="#sdk-t2-enums">Enums &amp; Constants</a></li>
      </ul></li>
      <li><a href="#sdk-t3">Tier 3: Daemon Attach</a><ul>
        <li><a href="#sdk-t3-api">API</a></li>
        <li><a href="#sdk-t3-lifecycle">Lifecycle</a></li>
        <li><a href="#sdk-t3-managed">Managed Mode</a></li>
      </ul></li>
      <li><a href="#sdk-patterns">Patterns &amp; Best Practices</a><ul>
        <li><a href="#sdk-pat-mixed">Mixed (Tier 2 + 3)</a></li>
        <li><a href="#sdk-pat-signals">Signal Handling</a></li>
        <li><a href="#sdk-pat-lua">Lua Integration</a></li>
        <li><a href="#sdk-pat-choosing">Choosing a Tier</a></li>
      </ul></li>
    </ul>
<div id="content-socketley-sdk" class="content" style="display:none">

<!-- ── Introduction ── -->
<h2 id="sdk-intro">C++ SDK</h2>

<p>Socketley ships a modular C++ SDK in <code>include/linux/socketley/</code> with a three-tier architecture. Each tier targets a different use case, from zero-dependency daemon control to embedding the full io_uring engine in your own binary.</p>

<h3 id="sdk-three-tiers">Three Tiers</h3>
<table>
<thead><tr><th>Tier</th><th>Header</th><th>Use Case</th><th>Dependencies</th></tr></thead>
<tbody>
<tr><td><span class="badge badge-tier1">Tier 1</span></td><td><code>socketley/control.h</code></td><td>Control a running daemon</td><td>None (POSIX only)</td></tr>
<tr><td><span class="badge badge-tier2">Tier 2</span></td><td><code>socketley/server.h</code><br><code>socketley/client.h</code><br><code>socketley/proxy.h</code><br><code>socketley/cache.h</code></td><td>Embed the full engine</td><td><code>libsocketley_sdk.a</code> + io_uring + OpenSSL</td></tr>
<tr><td><span class="badge badge-tier3">Tier 3</span></td><td><code>socketley/attach.h</code></td><td>Register with a daemon</td><td>None (builds on Tier 1)</td></tr>
</tbody>
</table>

<div class="info-box"><strong>Tiers 1 and 3 are fully self-contained.</strong> Copy the header anywhere, compile with <code>g++ -std=c++17</code>, and you're done &mdash; no library to link, no repo needed. Tier 2 requires building from source.</div>

<h3 id="sdk-install">Installation</h3>
<h4>Tier 1 &amp; 3 (header-only)</h4>
<p>Copy the header files from the SDK directory. No build step required:</p>
<pre><code><span class="cm"># Copy headers to your project</span>
cp -r include/linux/socketley/ /your/project/include/</code></pre>

<h4>Tier 2 (requires library)</h4>
<p>Build the SDK static library from the socketley source tree:</p>
<pre><code>./bin/premake5 gmake2
<span class="kw">cd</span> make && make config=release_x64 -j$(nproc)
<span class="cm"># Library: bin/Release/libsocketley_sdk.a</span></code></pre>

<h3 id="sdk-quickstart">Quick Start</h3>
<p><strong>Tier 1</strong> &mdash; Control a running daemon:</p>
<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/control.h&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>() {
    socketley::ctl::<span class="fn">create</span>(<span class="st">"server"</span>, <span class="st">"myapp"</span>, <span class="st">"-p 9000 -s"</span>);
    socketley::ctl::<span class="fn">send</span>(<span class="st">"myapp"</span>, <span class="st">"Hello!"</span>);
    socketley::ctl::<span class="fn">stop</span>(<span class="st">"myapp"</span>);
    socketley::ctl::<span class="fn">remove</span>(<span class="st">"myapp"</span>);
}
<span class="cm">// g++ -std=c++17 app.cpp -Iinclude/linux -o app</span></code></pre>

<p><strong>Tier 2</strong> &mdash; Embed the engine:</p>
<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/server.h&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>() {
    socketley::server <span class="fn">srv</span>(<span class="nb">9000</span>);
    srv.<span class="fn">on_message</span>([&amp;](<span class="kw">int</span> fd, std::string_view msg) {
        srv.<span class="fn">send</span>(fd, <span class="st">"echo: "</span> + std::string(msg));
    });
    srv.<span class="fn">start</span>();
}
<span class="cm">// g++ -std=c++23 app.cpp -I. -Iinclude/linux -Lbin/Release -lsocketley_sdk -luring -lssl -lcrypto</span></code></pre>

<p><strong>Tier 3</strong> &mdash; Register with daemon:</p>
<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/attach.h&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>() {
    <span class="cm">// Your own server setup here...</span>
    socketley::<span class="fn">daemon_attach</span>(<span class="st">"myservice"</span>, <span class="st">"server"</span>, <span class="nb">8080</span>);
    <span class="cm">// Now visible in: socketley ls</span>
    <span class="cm">// Auto-detach on exit()</span>
}
<span class="cm">// g++ -std=c++17 app.cpp -Iinclude/linux -o app</span></code></pre>

<!-- ══════════════════════════════════════════════════════════════
     TIER 1: DAEMON CONTROL
══════════════════════════════════════════════════════════════ -->
<h2 id="sdk-t1">Tier 1: Daemon Control</h2>
<p><code>#include &lt;socketley/control.h&gt;</code> &mdash; header-only, zero dependencies. Full programmatic control over a running socketley daemon through the same Unix socket IPC that the CLI uses.</p>

<h3 id="sdk-t1-result">Result Type</h3>
<p>Every <code>socketley::ctl</code> function returns this struct:</p>
<div class="method-card" id="sdk-result-struct">
<div class="method-header">
  <span class="method-name">socketley::result</span>
</div>
<pre><code><span class="kw">struct</span> result {
    <span class="kw">int</span>         exit_code;  <span class="cm">// 0 = success, 1 = bad input, 2 = fatal, -1 = connect failed</span>
    std::string data;       <span class="cm">// response body from daemon</span>
};</code></pre>
</div>

<h3 id="sdk-t1-runtime">Runtime Management</h3>
<p>All functions live in the <code>socketley::ctl</code> namespace.</p>

<div class="method-card" id="sdk-ctl-create">
<div class="method-header">
  <span class="method-name">create</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result create(const std::string&amp; type, const std::string&amp; name, const std::string&amp; flags = "")</p>
<p class="method-desc">Create a new runtime. Does not start it unless <code>-s</code> is in flags.</p>
<table>
<thead><tr><th>Parameter</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>type</code></td><td><code>"server"</code>, <code>"client"</code>, <code>"proxy"</code>, or <code>"cache"</code></td></tr>
<tr><td><code>name</code></td><td>Unique runtime name</td></tr>
<tr><td><code>flags</code></td><td>CLI flags string (e.g. <code>"-p 9000 -s --mode admin"</code>)</td></tr>
</tbody>
</table>
<p class="method-returns"><strong>Returns:</strong> <code>result</code> with exit_code 0 on success</p>
</div>

<div class="method-card" id="sdk-ctl-start">
<div class="method-header">
  <span class="method-name">start</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result start(const std::string&amp; name)</p>
<p class="method-desc">Start a created runtime. Transitions from <code>created</code>/<code>stopped</code> to <code>running</code>.</p>
<p class="method-returns"><strong>Returns:</strong> <code>result</code> &mdash; exit_code 1 if runtime not found or already running</p>
</div>

<div class="method-card" id="sdk-ctl-stop">
<div class="method-header">
  <span class="method-name">stop</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result stop(const std::string&amp; name)</p>
<p class="method-desc">Stop a running runtime. Gracefully tears down connections.</p>
</div>

<div class="method-card" id="sdk-ctl-remove">
<div class="method-header">
  <span class="method-name">remove</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result remove(const std::string&amp; name)</p>
<p class="method-desc">Remove a stopped runtime permanently. Deletes its persisted state.</p>
</div>

<h4 id="sdk-t1-send">Send Behavior</h4>
<p>The <code>send</code> method behaves differently depending on the runtime type:</p>

<div class="method-card" id="sdk-ctl-send">
<div class="method-header">
  <span class="method-name">send</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result send(const std::string&amp; name, const std::string&amp; message)</p>
<p class="method-desc">Send a text message to a runtime. Behavior depends on the runtime type:</p>
<table>
<thead><tr><th>Runtime</th><th>Behavior</th></tr></thead>
<tbody>
<tr><td><strong>Server</strong> (mode != in)</td><td>Broadcasts to all connected clients</td></tr>
<tr><td><strong>Client</strong> (mode != in)</td><td>Sends to the connected remote server</td></tr>
<tr><td><strong>Cache</strong></td><td>Not supported &mdash; returns error</td></tr>
<tr><td><strong>Proxy</strong></td><td>Not supported &mdash; returns error</td></tr>
</tbody>
</table>
<pre><code><span class="cm">// Server: broadcasts "hello" to all connected clients</span>
socketley::ctl::<span class="fn">send</span>(<span class="st">"my_server"</span>, <span class="st">"hello"</span>);

<span class="cm">// Client: sends "hello" to the remote server</span>
socketley::ctl::<span class="fn">send</span>(<span class="st">"my_client"</span>, <span class="st">"hello"</span>);

<span class="cm">// Cache/Proxy: returns error (exit_code != 0)</span>
<span class="kw">auto</span> r = socketley::ctl::<span class="fn">send</span>(<span class="st">"my_cache"</span>, <span class="st">"hello"</span>);
<span class="cm">// r.exit_code == 1</span></code></pre>
</div>

<div class="method-card" id="sdk-ctl-ls">
<div class="method-header">
  <span class="method-name">ls</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result ls()</p>
<p class="method-desc">List all runtimes with their type, port, state, and connection count.</p>
<p class="method-returns"><strong>Returns:</strong> <code>result</code> with tabular listing in <code>data</code></p>
</div>

<div class="method-card" id="sdk-ctl-ps">
<div class="method-header">
  <span class="method-name">ps</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result ps()</p>
<p class="method-desc">Show running runtimes with PIDs and uptime.</p>
</div>

<div class="method-card" id="sdk-ctl-stats">
<div class="method-header">
  <span class="method-name">stats</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result stats(const std::string&amp; name)</p>
<p class="method-desc">Get detailed statistics for a runtime: connections, messages, bytes in/out, uptime.</p>
</div>

<div class="method-card" id="sdk-ctl-show">
<div class="method-header">
  <span class="method-name">show</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result show(const std::string&amp; name)</p>
<p class="method-desc">Show the current configuration of a runtime (port, mode, flags, Lua script path, etc.).</p>
</div>

<div class="method-card" id="sdk-ctl-reload">
<div class="method-header">
  <span class="method-name">reload</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result reload(const std::string&amp; name)</p>
<p class="method-desc">Reload a runtime (stop + start). Connections are dropped and re-established.</p>
</div>

<div class="method-card" id="sdk-ctl-reload-lua">
<div class="method-header">
  <span class="method-name">reload_lua</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result reload_lua(const std::string&amp; name)</p>
<p class="method-desc">Hot-reload the Lua script without restarting the runtime. Existing connections stay alive.</p>
</div>

<div class="method-card" id="sdk-ctl-edit">
<div class="method-header">
  <span class="method-name">edit</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result edit(const std::string&amp; name, const std::string&amp; flags)</p>
<p class="method-desc">Edit runtime flags on a stopped runtime. Takes the same flags as <code>create</code>.</p>
</div>

<h3 id="sdk-t1-cache">Cache Operations</h3>
<p>Direct IPC access to cache data &mdash; no TCP connection needed. Every operation has a typed convenience function in <code>socketley::ctl</code>.</p>

<h4>Strings</h4>

<div class="method-card" id="sdk-ctl-cache-get">
<div class="method-header">
  <span class="method-name">cache_get</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_get(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Get a string value from a cache runtime. Returns <code>"nil"</code> in data if key doesn't exist.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-set">
<div class="method-header">
  <span class="method-name">cache_set</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_set(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-desc">Set a string value in a cache runtime.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-del">
<div class="method-header">
  <span class="method-name">cache_del</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_del(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Delete a key of any type from a cache runtime.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-exists">
<div class="method-header">
  <span class="method-name">cache_exists</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_exists(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Check if a key exists. Returns <code>"1"</code> or <code>"0"</code> in data.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-incr">
<div class="method-header">
  <span class="method-name">cache_incr / cache_decr</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_incr(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-sig">result cache_decr(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Increment or decrement a numeric string value by 1. Creates the key with value <code>"1"</code> or <code>"-1"</code> if it doesn't exist.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-incrby">
<div class="method-header">
  <span class="method-name">cache_incrby / cache_decrby</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_incrby(const std::string&amp; cache_name, const std::string&amp; key, int delta)</p>
<p class="method-sig">result cache_decrby(const std::string&amp; cache_name, const std::string&amp; key, int delta)</p>
<p class="method-desc">Increment or decrement a numeric string value by a given amount.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-append">
<div class="method-header">
  <span class="method-name">cache_append</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_append(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-desc">Append a string to an existing value. Returns the new length. Creates the key if it doesn't exist.</p>
</div>

<h4>Lists</h4>

<div class="method-card" id="sdk-ctl-cache-lpush">
<div class="method-header">
  <span class="method-name">cache_lpush / cache_rpush</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_lpush(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-sig">result cache_rpush(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-desc">Push a value to the head (<code>lpush</code>) or tail (<code>rpush</code>) of a list. Creates the list if it doesn't exist.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-lpop">
<div class="method-header">
  <span class="method-name">cache_lpop / cache_rpop</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_lpop(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-sig">result cache_rpop(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Pop and return the first (<code>lpop</code>) or last (<code>rpop</code>) element. Returns <code>"nil"</code> if empty.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-llen">
<div class="method-header">
  <span class="method-name">cache_llen</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_llen(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Get the length of a list. Returns count in data.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-lrange">
<div class="method-header">
  <span class="method-name">cache_lrange</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_lrange(const std::string&amp; cache_name, const std::string&amp; key, int start, int stop)</p>
<p class="method-desc">Get a range of elements from a list. Supports negative indices (<code>-1</code> = last element). Returns newline-separated values.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-lindex">
<div class="method-header">
  <span class="method-name">cache_lindex</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_lindex(const std::string&amp; cache_name, const std::string&amp; key, int index)</p>
<p class="method-desc">Get an element by index. Supports negative indices. Returns <code>"nil"</code> if out of range.</p>
</div>

<h4>Sets</h4>

<div class="method-card" id="sdk-ctl-cache-sadd">
<div class="method-header">
  <span class="method-name">cache_sadd</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_sadd(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; member)</p>
<p class="method-desc">Add a member to a set. Returns <code>"ok"</code> if added, <code>"exists"</code> if already present.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-srem">
<div class="method-header">
  <span class="method-name">cache_srem</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_srem(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; member)</p>
<p class="method-desc">Remove a member from a set. Returns <code>"1"</code> if removed, <code>"0"</code> if not found.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-sismember">
<div class="method-header">
  <span class="method-name">cache_sismember</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_sismember(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; member)</p>
<p class="method-desc">Check if a member exists in a set. Returns <code>"1"</code> or <code>"0"</code>.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-scard">
<div class="method-header">
  <span class="method-name">cache_scard</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_scard(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Get the number of members in a set.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-smembers">
<div class="method-header">
  <span class="method-name">cache_smembers</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_smembers(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Get all members of a set. Returns newline-separated members.</p>
</div>

<h4>Hashes</h4>

<div class="method-card" id="sdk-ctl-cache-hset">
<div class="method-header">
  <span class="method-name">cache_hset</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_hset(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; field, const std::string&amp; value)</p>
<p class="method-desc">Set a field in a hash. Creates the hash if it doesn't exist.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-hget">
<div class="method-header">
  <span class="method-name">cache_hget</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_hget(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; field)</p>
<p class="method-desc">Get a hash field value. Returns <code>"nil"</code> if field or key doesn't exist.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-hdel">
<div class="method-header">
  <span class="method-name">cache_hdel</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_hdel(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; field)</p>
<p class="method-desc">Delete a field from a hash. Returns <code>"1"</code> if removed, <code>"0"</code> if not found.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-hlen">
<div class="method-header">
  <span class="method-name">cache_hlen</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_hlen(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Get the number of fields in a hash.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-hgetall">
<div class="method-header">
  <span class="method-name">cache_hgetall</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_hgetall(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Get all fields and values from a hash. Returns alternating field/value pairs, newline-separated.</p>
</div>

<h4>TTL</h4>

<div class="method-card" id="sdk-ctl-cache-expire">
<div class="method-header">
  <span class="method-name">cache_expire</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_expire(const std::string&amp; cache_name, const std::string&amp; key, int seconds)</p>
<p class="method-desc">Set a TTL on a key. Returns <code>"ok"</code> if set, <code>"nil"</code> if key doesn't exist.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-ttl">
<div class="method-header">
  <span class="method-name">cache_ttl</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_ttl(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Get remaining TTL in seconds. Returns <code>-1</code> (no TTL), <code>-2</code> (key missing), or seconds remaining.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-persist">
<div class="method-header">
  <span class="method-name">cache_persist</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_persist(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Remove TTL from a key. Returns <code>"ok"</code> if removed, <code>"nil"</code> if key has no TTL or doesn't exist.</p>
</div>

<h4>Pub/Sub</h4>

<div class="method-card" id="sdk-ctl-cache-publish">
<div class="method-header">
  <span class="method-name">cache_publish</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_publish(const std::string&amp; cache_name, const std::string&amp; channel, const std::string&amp; message)</p>
<p class="method-desc">Publish a message to a channel. Returns subscriber count in data.</p>
</div>

<h4>Admin</h4>

<div class="method-card" id="sdk-ctl-cache-size">
<div class="method-header">
  <span class="method-name">cache_size</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_size(const std::string&amp; cache_name)</p>
<p class="method-desc">Get total key count in the cache.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-memory">
<div class="method-header">
  <span class="method-name">cache_memory</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_memory(const std::string&amp; cache_name)</p>
<p class="method-desc">Get memory usage. Returns <code>"max_memory used_memory"</code> in data.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-flush">
<div class="method-header">
  <span class="method-name">cache_flush</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_flush(const std::string&amp; cache_name, const std::string&amp; path = "")</p>
<p class="method-desc">Save cache snapshot to disk. If path is empty, uses the persistent path configured on the cache. Requires admin mode.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-load">
<div class="method-header">
  <span class="method-name">cache_load</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_load(const std::string&amp; cache_name, const std::string&amp; path = "")</p>
<p class="method-desc">Load cache snapshot from disk. Requires admin mode.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-keys">
<div class="method-header">
  <span class="method-name">cache_keys</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_keys(const std::string&amp; cache_name, const std::string&amp; pattern = "*")</p>
<p class="method-desc">Get all keys matching a glob pattern. Returns newline-separated key names.</p>
</div>

<h3 id="sdk-t1-action">Action Commands</h3>
<p>All <code>cache_*</code> functions above are convenience wrappers around <code>action</code> subcommands. You can also call them directly via <code>command()</code> for maximum flexibility:</p>
<pre><code><span class="cm">// These two are equivalent:</span>
socketley::ctl::<span class="fn">cache_lpush</span>(<span class="st">"store"</span>, <span class="st">"mylist"</span>, <span class="st">"item1"</span>);
socketley::ctl::<span class="fn">command</span>(<span class="st">"action store lpush mylist item1"</span>);</code></pre>
<p>The raw <code>action</code> syntax is useful for commands that don't have a convenience wrapper yet, or for dynamic command construction.</p>

<h4>Strings</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>get</code></td><td><code>action &lt;name&gt; get &lt;key&gt;</code></td><td>Value or <code>"nil"</code></td></tr>
<tr><td><code>set</code></td><td><code>action &lt;name&gt; set &lt;key&gt; &lt;value&gt;</code></td><td><code>"ok"</code></td></tr>
<tr><td><code>del</code></td><td><code>action &lt;name&gt; del &lt;key&gt;</code></td><td><code>"ok"</code> or <code>"nil"</code></td></tr>
<tr><td><code>exists</code></td><td><code>action &lt;name&gt; exists &lt;key&gt;</code></td><td><code>"1"</code> or <code>"0"</code></td></tr>
<tr><td><code>incr</code></td><td><code>action &lt;name&gt; incr &lt;key&gt;</code></td><td>New value</td></tr>
<tr><td><code>decr</code></td><td><code>action &lt;name&gt; decr &lt;key&gt;</code></td><td>New value</td></tr>
<tr><td><code>incrby</code></td><td><code>action &lt;name&gt; incrby &lt;key&gt; &lt;delta&gt;</code></td><td>New value</td></tr>
<tr><td><code>decrby</code></td><td><code>action &lt;name&gt; decrby &lt;key&gt; &lt;delta&gt;</code></td><td>New value</td></tr>
<tr><td><code>append</code></td><td><code>action &lt;name&gt; append &lt;key&gt; &lt;value&gt;</code></td><td>New length</td></tr>
</tbody>
</table>

<h4>Lists</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>lpush</code></td><td><code>action &lt;name&gt; lpush &lt;key&gt; &lt;value&gt;</code></td><td><code>"ok"</code></td></tr>
<tr><td><code>rpush</code></td><td><code>action &lt;name&gt; rpush &lt;key&gt; &lt;value&gt;</code></td><td><code>"ok"</code></td></tr>
<tr><td><code>lpop</code></td><td><code>action &lt;name&gt; lpop &lt;key&gt;</code></td><td>Value or <code>"nil"</code></td></tr>
<tr><td><code>rpop</code></td><td><code>action &lt;name&gt; rpop &lt;key&gt;</code></td><td>Value or <code>"nil"</code></td></tr>
<tr><td><code>llen</code></td><td><code>action &lt;name&gt; llen &lt;key&gt;</code></td><td>Count</td></tr>
<tr><td><code>lrange</code></td><td><code>action &lt;name&gt; lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</code></td><td>Newline-separated values</td></tr>
<tr><td><code>lindex</code></td><td><code>action &lt;name&gt; lindex &lt;key&gt; &lt;index&gt;</code></td><td>Value or <code>"nil"</code></td></tr>
</tbody>
</table>

<h4>Sets</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>sadd</code></td><td><code>action &lt;name&gt; sadd &lt;key&gt; &lt;member&gt;</code></td><td><code>"ok"</code> or <code>"exists"</code></td></tr>
<tr><td><code>srem</code></td><td><code>action &lt;name&gt; srem &lt;key&gt; &lt;member&gt;</code></td><td><code>"1"</code> or <code>"0"</code></td></tr>
<tr><td><code>sismember</code></td><td><code>action &lt;name&gt; sismember &lt;key&gt; &lt;member&gt;</code></td><td><code>"1"</code> or <code>"0"</code></td></tr>
<tr><td><code>scard</code></td><td><code>action &lt;name&gt; scard &lt;key&gt;</code></td><td>Count</td></tr>
<tr><td><code>smembers</code></td><td><code>action &lt;name&gt; smembers &lt;key&gt;</code></td><td>Newline-separated members</td></tr>
</tbody>
</table>

<h4>Hashes</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>hset</code></td><td><code>action &lt;name&gt; hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</code></td><td><code>"ok"</code></td></tr>
<tr><td><code>hget</code></td><td><code>action &lt;name&gt; hget &lt;key&gt; &lt;field&gt;</code></td><td>Value or <code>"nil"</code></td></tr>
<tr><td><code>hdel</code></td><td><code>action &lt;name&gt; hdel &lt;key&gt; &lt;field&gt;</code></td><td><code>"1"</code> or <code>"0"</code></td></tr>
<tr><td><code>hlen</code></td><td><code>action &lt;name&gt; hlen &lt;key&gt;</code></td><td>Count</td></tr>
<tr><td><code>hgetall</code></td><td><code>action &lt;name&gt; hgetall &lt;key&gt;</code></td><td>Alternating field/value, newline-separated</td></tr>
</tbody>
</table>

<h4>TTL</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>expire</code></td><td><code>action &lt;name&gt; expire &lt;key&gt; &lt;seconds&gt;</code></td><td><code>"ok"</code> or <code>"nil"</code></td></tr>
<tr><td><code>ttl</code></td><td><code>action &lt;name&gt; ttl &lt;key&gt;</code></td><td>Seconds remaining, <code>-1</code> (no TTL), or <code>-2</code> (missing key)</td></tr>
<tr><td><code>persist</code></td><td><code>action &lt;name&gt; persist &lt;key&gt;</code></td><td><code>"ok"</code> or <code>"nil"</code></td></tr>
</tbody>
</table>

<h4>Pub/Sub</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>publish</code></td><td><code>action &lt;name&gt; publish &lt;channel&gt; &lt;message&gt;</code></td><td>Subscriber count</td></tr>
</tbody>
</table>

<h4>Admin</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>size</code></td><td><code>action &lt;name&gt; size</code></td><td>Total key count</td></tr>
<tr><td><code>memory</code></td><td><code>action &lt;name&gt; memory</code></td><td><code>"max_memory used_memory"</code></td></tr>
<tr><td><code>flush</code></td><td><code>action &lt;name&gt; flush [path]</code></td><td><code>"ok"</code> (requires admin mode)</td></tr>
<tr><td><code>load</code></td><td><code>action &lt;name&gt; load [path]</code></td><td><code>"ok"</code> (requires admin mode)</td></tr>
<tr><td><code>keys</code></td><td><code>action &lt;name&gt; keys [pattern]</code></td><td>Newline-separated key names</td></tr>
<tr><td><code>mget</code></td><td><code>action &lt;name&gt; mget &lt;key1&gt; [key2] ...</code></td><td>Newline-separated values</td></tr>
<tr><td><code>mset</code></td><td><code>action &lt;name&gt; mset &lt;k1&gt; &lt;v1&gt; [k2] [v2] ...</code></td><td><code>"ok"</code></td></tr>
</tbody>
</table>

<pre><code><span class="cm">// Typed convenience functions (recommended)</span>
socketley::ctl::<span class="fn">cache_set</span>(<span class="st">"store"</span>, <span class="st">"user:1"</span>, <span class="st">"alice"</span>);
socketley::ctl::<span class="fn">cache_lpush</span>(<span class="st">"store"</span>, <span class="st">"queue"</span>, <span class="st">"job_a"</span>);
socketley::ctl::<span class="fn">cache_sadd</span>(<span class="st">"store"</span>, <span class="st">"tags:1"</span>, <span class="st">"vip"</span>);
socketley::ctl::<span class="fn">cache_hset</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>, <span class="st">"token"</span>, <span class="st">"abc123"</span>);
socketley::ctl::<span class="fn">cache_expire</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>, <span class="nb">3600</span>);

<span class="kw">auto</span> r = socketley::ctl::<span class="fn">cache_hget</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>, <span class="st">"token"</span>);
printf(<span class="st">"token = %s\n"</span>, r.data.c_str()); <span class="cm">// "abc123"</span></code></pre>

<h3 id="sdk-t1-raw">Raw Command</h3>
<div class="method-card" id="sdk-ctl-command">
<div class="method-header">
  <span class="method-name">command</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result command(const std::string&amp; cmd)</p>
<p class="method-sig">result command(const std::string&amp; socket_path, const std::string&amp; cmd)</p>
<p class="method-desc">Send any raw command string to the daemon. Supports glob patterns. The two-argument form lets you target a specific socket path.</p>
<pre><code><span class="kw">auto</span> r = socketley::ctl::<span class="fn">command</span>(<span class="st">"start fleet_srv_*"</span>);  <span class="cm">// glob pattern</span>
<span class="kw">auto</span> r = socketley::ctl::<span class="fn">command</span>(<span class="st">"/tmp/my.sock"</span>, <span class="st">"ls"</span>); <span class="cm">// custom socket</span></code></pre>
</div>

<h3 id="sdk-t1-socket">Socket Path Resolution</h3>
<p>The SDK automatically finds the daemon socket in this order:</p>
<ol>
<li><code>SOCKETLEY_SOCKET</code> environment variable</li>
<li><code>/run/socketley/socketley.sock</code></li>
<li><code>/tmp/socketley.sock</code></li>
</ol>

<!-- ══════════════════════════════════════════════════════════════
     TIER 2: EMBED ENGINE
══════════════════════════════════════════════════════════════ -->
<h2 id="sdk-t2">Tier 2: Embed Engine</h2>
<p>Tier 2 embeds the full socketley engine &mdash; io_uring event loop, runtime manager, and all four runtime types &mdash; directly in your own binary. Maximum performance (no IPC overhead), full control over the event loop.</p>

<h3 id="sdk-t2-build">Build &amp; Link</h3>
<div class="warn-box"><strong>Build requirement:</strong> Tier 2 requires the socketley source tree and <code>libsocketley_sdk.a</code>.<br>
<code>g++ -std=c++23 app.cpp -I. -Iinclude/linux -Lbin/Release -lsocketley_sdk -luring -lssl -lcrypto</code><br>
Add <code>-lluajit</code> if using Lua, or define <code>SOCKETLEY_NO_LUA</code> to build without it.</div>

<table>
<thead><tr><th>Header</th><th>Provides</th></tr></thead>
<tbody>
<tr><td><code>socketley/server.h</code></td><td><code>socketley::server</code> wrapper + <code>server_instance</code> raw API</td></tr>
<tr><td><code>socketley/client.h</code></td><td><code>socketley::client</code> wrapper + <code>client_instance</code> raw API</td></tr>
<tr><td><code>socketley/proxy.h</code></td><td><code>socketley::proxy</code> wrapper + <code>proxy_instance</code> raw API</td></tr>
<tr><td><code>socketley/cache.h</code></td><td><code>socketley::cache</code> wrapper + <code>cache_instance</code> raw API</td></tr>
<tr><td><code>socketley/core.h</code></td><td><code>event_loop</code>, <code>runtime_manager</code>, enums (included by above)</td></tr>
</tbody>
</table>

<h3 id="sdk-t2-wrappers">High-Level Wrapper Classes</h3>
<p>The recommended way to use Tier 2. Each wrapper manages its own event loop, runtime manager, and signal handlers internally. All config methods return <code>*this</code> for chaining. <code>start()</code> blocks until SIGINT/SIGTERM.</p>

<div class="warn-box"><strong>One <code>start()</code> per process</strong> &mdash; the signal handler points to one event loop. For multi-runtime in a single process, use the <a href="#sdk-t2-eventloop">raw API</a> below.</div>

<div class="method-card" id="sdk-wrap-server">
<div class="method-header">
  <span class="method-name">socketley::server</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">server(uint16_t port)</p>
<p class="method-desc">High-level TCP/UDP server. Handles event loop, signal handlers, and lifecycle internally.</p>

<h4>Config (chainable)</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>tls(cert, key)</code></td><td>Enable TLS with certificate and key paths</td></tr>
<tr><td><code>max_connections(n)</code></td><td>Limit concurrent connections</td></tr>
<tr><td><code>rate_limit(r)</code></td><td>Per-connection rate limit (msg/sec)</td></tr>
<tr><td><code>global_rate_limit(r)</code></td><td>Shared rate limit across all connections</td></tr>
<tr><td><code>idle_timeout(s)</code></td><td>Disconnect idle clients after <em>s</em> seconds</td></tr>
<tr><td><code>lua(path)</code></td><td>Load a Lua script</td></tr>
<tr><td><code>mode(m)</code></td><td><code>mode_inout</code>, <code>mode_in</code>, <code>mode_out</code>, <code>mode_master</code></td></tr>
<tr><td><code>udp()</code></td><td>Switch to UDP mode</td></tr>
<tr><td><code>http_dir(path)</code></td><td>Serve static files from directory</td></tr>
<tr><td><code>http_cache()</code></td><td>Enable in-memory HTTP file cache</td></tr>
<tr><td><code>upstream(addr)</code></td><td>Add an upstream connection target</td></tr>
<tr><td><code>master_pw(pw)</code></td><td>Set master mode password</td></tr>
<tr><td><code>drain()</code></td><td>Enable graceful shutdown (finish pending writes)</td></tr>
<tr><td><code>group(g)</code></td><td>Tag for dynamic proxy backend discovery</td></tr>
<tr><td><code>tick_interval(ms)</code></td><td>Set periodic tick interval in milliseconds</td></tr>
</tbody>
</table>

<h4>Callbacks (chainable)</h4>
<table>
<thead><tr><th>Method</th><th>Signature</th></tr></thead>
<tbody>
<tr><td><code>on_start(cb)</code></td><td><code>void()</code></td></tr>
<tr><td><code>on_stop(cb)</code></td><td><code>void()</code></td></tr>
<tr><td><code>on_connect(cb)</code></td><td><code>void(int fd)</code></td></tr>
<tr><td><code>on_disconnect(cb)</code></td><td><code>void(int fd)</code></td></tr>
<tr><td><code>on_message(cb)</code></td><td><code>void(int fd, string_view msg)</code></td></tr>
<tr><td><code>on_tick(cb)</code></td><td><code>void(double dt_ms)</code></td></tr>
</tbody>
</table>

<h4>Actions</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>send(fd, msg)</code></td><td>Send message to a specific client</td></tr>
<tr><td><code>broadcast(msg)</code></td><td>Send to all connected clients</td></tr>
<tr><td><code>disconnect(fd)</code></td><td>Disconnect a client</td></tr>
<tr><td><code>peer_ip(fd)</code></td><td>Get client's IP address</td></tr>
<tr><td><code>clients()</code></td><td>Get vector of all connected client fds</td></tr>
<tr><td><code>multicast(fds, msg)</code></td><td>Send to a subset of clients</td></tr>
<tr><td><code>set_data(fd, k, v)</code></td><td>Set per-connection metadata</td></tr>
<tr><td><code>get_data(fd, k)</code></td><td>Get per-connection metadata</td></tr>
</tbody>
</table>

<h4>Lifecycle &amp; Escape Hatches</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>start()</code></td><td>Initialize event loop, install signal handlers, run &mdash; blocks until SIGINT/SIGTERM</td></tr>
<tr><td><code>stop()</code></td><td>Request the event loop to stop</td></tr>
<tr><td><code>instance()</code></td><td>Access the underlying <code>server_instance*</code></td></tr>
<tr><td><code>manager()</code></td><td>Access the underlying <code>runtime_manager&amp;</code></td></tr>
<tr><td><code>loop()</code></td><td>Access the underlying <code>event_loop&amp;</code></td></tr>
</tbody>
</table>

<pre><code>socketley::server <span class="fn">srv</span>(<span class="nb">9000</span>);

srv.<span class="fn">on_connect</span>([](<span class="kw">int</span> fd) {
    printf(<span class="st">"client %d connected\n"</span>, fd);
});
srv.<span class="fn">on_message</span>([&amp;](<span class="kw">int</span> fd, std::string_view msg) {
    srv.<span class="fn">send</span>(fd, <span class="st">"echo: "</span> + std::string(msg));
});
srv.<span class="fn">on_disconnect</span>([](<span class="kw">int</span> fd) {
    printf(<span class="st">"client %d disconnected\n"</span>, fd);
});

srv.<span class="fn">start</span>();</code></pre>
</div>

<div class="method-card" id="sdk-wrap-client">
<div class="method-header">
  <span class="method-name">socketley::client</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-client">Client</span>
</div>
<p class="method-sig">client(std::string_view host, uint16_t port)</p>
<p class="method-desc">High-level TCP/UDP client with optional auto-reconnect.</p>

<h4>Config (chainable)</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>tls()</code></td><td>Enable TLS</td></tr>
<tr><td><code>tls_ca(ca)</code></td><td>Enable TLS with custom CA certificate</td></tr>
<tr><td><code>reconnect(max)</code></td><td>Auto-reconnect: 0 = infinite, &gt;0 = max attempts</td></tr>
<tr><td><code>mode(m)</code></td><td><code>client_mode_inout</code>, <code>client_mode_in</code>, <code>client_mode_out</code></td></tr>
<tr><td><code>udp()</code></td><td>Switch to UDP mode</td></tr>
<tr><td><code>lua(path)</code></td><td>Load a Lua script</td></tr>
<tr><td><code>tick_interval(ms)</code></td><td>Set periodic tick interval</td></tr>
</tbody>
</table>

<h4>Callbacks (chainable)</h4>
<table>
<thead><tr><th>Method</th><th>Signature</th></tr></thead>
<tbody>
<tr><td><code>on_start(cb)</code></td><td><code>void()</code></td></tr>
<tr><td><code>on_stop(cb)</code></td><td><code>void()</code></td></tr>
<tr><td><code>on_connect(cb)</code></td><td><code>void(int fd)</code></td></tr>
<tr><td><code>on_disconnect(cb)</code></td><td><code>void(int fd)</code></td></tr>
<tr><td><code>on_message(cb)</code></td><td><code>void(string_view msg)</code></td></tr>
<tr><td><code>on_tick(cb)</code></td><td><code>void(double dt_ms)</code></td></tr>
</tbody>
</table>

<h4>Actions &amp; Lifecycle</h4>
<p><code>send(msg)</code> &mdash; send to server. <code>start()</code> / <code>stop()</code> / <code>instance()</code> / <code>manager()</code> / <code>loop()</code>.</p>

<pre><code>socketley::client <span class="fn">cli</span>(<span class="st">"127.0.0.1"</span>, <span class="nb">9000</span>);
cli.<span class="fn">reconnect</span>(<span class="nb">0</span>);  <span class="cm">// infinite reconnect</span>
cli.<span class="fn">on_connect</span>([&amp;](<span class="kw">int</span>) { cli.<span class="fn">send</span>(<span class="st">"hello"</span>); });
cli.<span class="fn">on_message</span>([](std::string_view msg) {
    printf(<span class="st">"%.*s\n"</span>, (<span class="kw">int</span>)msg.size(), msg.data());
});
cli.<span class="fn">start</span>();</code></pre>
</div>

<div class="method-card" id="sdk-wrap-proxy">
<div class="method-header">
  <span class="method-name">socketley::proxy</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-proxy">Proxy</span>
</div>
<p class="method-sig">proxy(uint16_t port)</p>
<p class="method-desc">High-level HTTP/TCP reverse proxy with round-robin or random load balancing.</p>

<h4>Config (chainable)</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>backend(addr)</code></td><td>Add a backend target (call multiple times for load balancing)</td></tr>
<tr><td><code>strategy(s)</code></td><td><code>strategy_round_robin</code>, <code>strategy_random</code>, <code>strategy_lua</code></td></tr>
<tr><td><code>protocol(p)</code></td><td><code>protocol_http</code> or <code>protocol_tcp</code></td></tr>
<tr><td><code>tls(cert, key)</code></td><td>Enable TLS on the listen socket</td></tr>
<tr><td><code>max_connections(n)</code></td><td>Limit concurrent connections</td></tr>
<tr><td><code>idle_timeout(s)</code></td><td>Disconnect idle connections after <em>s</em> seconds</td></tr>
<tr><td><code>lua(path)</code></td><td>Load a Lua script (enables <code>strategy_lua</code>)</td></tr>
<tr><td><code>group(g)</code></td><td>Group tag for discovery</td></tr>
</tbody>
</table>

<h4>Callbacks &amp; Lifecycle</h4>
<p><code>on_start(cb)</code> / <code>on_stop(cb)</code>. <code>start()</code> / <code>stop()</code> / <code>instance()</code> / <code>manager()</code> / <code>loop()</code>.</p>

<pre><code>socketley::proxy <span class="fn">px</span>(<span class="nb">8080</span>);
px.<span class="fn">backend</span>(<span class="st">"127.0.0.1:9001"</span>)
  .<span class="fn">backend</span>(<span class="st">"127.0.0.1:9002"</span>)
  .<span class="fn">protocol</span>(protocol_tcp)
  .<span class="fn">strategy</span>(strategy_round_robin);
px.<span class="fn">start</span>();</code></pre>
</div>

<div class="method-card" id="sdk-wrap-cache">
<div class="method-header">
  <span class="method-name">socketley::cache</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">cache(uint16_t port)</p>
<p class="method-desc">High-level Redis-compatible in-memory cache with optional persistence and replication.</p>

<h4>Config (chainable)</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>persistent(path)</code></td><td>Auto-save/load cache data to disk</td></tr>
<tr><td><code>max_memory(bytes)</code></td><td>Set memory limit for cache store</td></tr>
<tr><td><code>eviction(policy)</code></td><td><code>evict_none</code>, <code>evict_allkeys_lru</code>, <code>evict_allkeys_random</code></td></tr>
<tr><td><code>resp()</code></td><td>Force RESP protocol mode (Redis-compatible binary protocol)</td></tr>
<tr><td><code>mode(m)</code></td><td><code>cache_mode_readonly</code>, <code>cache_mode_readwrite</code>, <code>cache_mode_admin</code></td></tr>
<tr><td><code>tls(cert, key)</code></td><td>Enable TLS on the listen socket</td></tr>
<tr><td><code>max_connections(n)</code></td><td>Limit concurrent connections</td></tr>
<tr><td><code>idle_timeout(s)</code></td><td>Disconnect idle connections after <em>s</em> seconds</td></tr>
<tr><td><code>replicate(target)</code></td><td>Set replication target (<code>"host:port"</code>)</td></tr>
<tr><td><code>lua(path)</code></td><td>Load a Lua script</td></tr>
<tr><td><code>group(g)</code></td><td>Group tag for discovery</td></tr>
</tbody>
</table>

<h4>Callbacks &amp; Lifecycle</h4>
<p><code>on_start(cb)</code> / <code>on_stop(cb)</code>. <code>start()</code> / <code>stop()</code> / <code>instance()</code> / <code>manager()</code> / <code>loop()</code>.</p>

<pre><code>socketley::cache <span class="fn">c</span>(<span class="nb">6379</span>);
c.<span class="fn">persistent</span>(<span class="st">"/var/data/store.dat"</span>)
 .<span class="fn">resp</span>()
 .<span class="fn">max_memory</span>(<span class="nb">256</span> * <span class="nb">1024</span> * <span class="nb">1024</span>)
 .<span class="fn">eviction</span>(evict_allkeys_lru);
c.<span class="fn">start</span>();</code></pre>
</div>

<h4>Raw Engine API</h4>
<p>For multi-runtime in a single process or custom event loop control, use the raw types (<code>event_loop</code>, <code>runtime_manager</code>, <code>server_instance</code>, etc.) documented below. The wrapper classes use this API internally &mdash; access it via the <code>instance()</code>, <code>manager()</code>, and <code>loop()</code> escape hatches.</p>

<h3 id="sdk-t2-eventloop">event_loop</h3>
<p>The io_uring event loop drives all I/O. One per process, shared by all runtimes.</p>

<div class="method-card" id="sdk-el-init">
<div class="method-header">
  <span class="method-name">event_loop::init</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">bool init()</p>
<p class="method-desc">Initialize the io_uring ring with SQPOLL. Must be called before any other event_loop method. Returns false if io_uring setup fails (missing kernel support).</p>
</div>

<div class="method-card" id="sdk-el-run">
<div class="method-header">
  <span class="method-name">event_loop::run</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">void run()</p>
<p class="method-desc">Enter the main event loop. Blocks until <code>request_stop()</code> is called (typically from a signal handler). Processes io_uring completions and dispatches them to runtime handlers.</p>
</div>

<div class="method-card" id="sdk-el-stop">
<div class="method-header">
  <span class="method-name">event_loop::request_stop</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">void request_stop()</p>
<p class="method-desc">Signal the event loop to stop. Safe to call from signal handlers. The loop exits after the current batch of completions is processed.</p>
</div>

<h3 id="sdk-t2-manager">runtime_manager</h3>
<p>Manages the lifecycle and lookup of all runtimes.</p>

<div class="method-card" id="sdk-mgr-create">
<div class="method-header">
  <span class="method-name">runtime_manager::create</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">bool create(runtime_type type, std::string_view name)</p>
<p class="method-desc">Create a new runtime in <code>created</code> state. Configure it via its type-specific setters before calling <code>start()</code>.</p>
<table>
<thead><tr><th>Parameter</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>type</code></td><td><code>runtime_server</code>, <code>runtime_client</code>, <code>runtime_proxy</code>, <code>runtime_cache</code></td></tr>
<tr><td><code>name</code></td><td>Unique runtime name</td></tr>
</tbody>
</table>
<p class="method-returns"><strong>Returns:</strong> <code>false</code> if name already exists</p>
</div>

<div class="method-card" id="sdk-mgr-start">
<div class="method-header">
  <span class="method-name">runtime_manager::start</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">bool start(std::string_view name, event_loop&amp; loop)</p>
<p class="method-desc">Start a runtime. Calls its <code>setup()</code> to bind/listen/connect and register with the event loop.</p>
<p class="method-returns"><strong>Returns:</strong> <code>false</code> if runtime not found, already running, or setup fails (e.g. port in use)</p>
</div>

<div class="method-card" id="sdk-mgr-stop">
<div class="method-header">
  <span class="method-name">runtime_manager::stop</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">bool stop(std::string_view name, event_loop&amp; loop)</p>
<p class="method-desc">Stop a running runtime. Calls its <code>teardown()</code> to gracefully close connections.</p>
</div>

<div class="method-card" id="sdk-mgr-remove">
<div class="method-header">
  <span class="method-name">runtime_manager::remove</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">bool remove(std::string_view name)</p>
<p class="method-desc">Delete a stopped runtime from the manager.</p>
</div>

<div class="method-card" id="sdk-mgr-get">
<div class="method-header">
  <span class="method-name">runtime_manager::get</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">runtime_instance* get(std::string_view name)</p>
<p class="method-desc">Look up a runtime by name. Returns <code>nullptr</code> if not found. Cast to the concrete type to access type-specific methods.</p>
<pre><code><span class="kw">auto</span>* srv = <span class="kw">static_cast</span>&lt;server_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"my_server"</span>));</code></pre>
</div>

<div class="method-card" id="sdk-mgr-list">
<div class="method-header">
  <span class="method-name">runtime_manager::list</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">const runtime_map&amp; list() const</p>
<p class="method-desc">Get all runtimes as an unordered map of <code>name &rarr; unique_ptr&lt;runtime_instance&gt;</code>.</p>
</div>

<div class="method-card" id="sdk-mgr-stopall">
<div class="method-header">
  <span class="method-name">runtime_manager::stop_all</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">void stop_all(event_loop&amp; loop)</p>
<p class="method-desc">Stop all running runtimes. Call this during shutdown, after the event loop exits.</p>
</div>

<div class="method-card" id="sdk-mgr-dispatch">
<div class="method-header">
  <span class="method-name">runtime_manager::dispatch_publish</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">void dispatch_publish(std::string_view cache_name, std::string_view channel, std::string_view message)</p>
<p class="method-desc">Dispatch a pub/sub message to all runtimes subscribed to the given channel. Used for cross-runtime pub/sub.</p>
</div>

<div class="method-card" id="sdk-mgr-group">
<div class="method-header">
  <span class="method-name">runtime_manager::get_by_group</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">std::vector&lt;runtime_instance*&gt; get_by_group(std::string_view group) const</p>
<p class="method-desc">Find all runtimes tagged with a specific group. Used by proxy for dynamic backend discovery.</p>
</div>

<h3 id="sdk-t2-base">runtime_instance (Base)</h3>
<p>Base class inherited by all four runtime types. Provides identity, configuration, TLS, limits, lifecycle, and Lua integration.</p>

<h4>Identity</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>get_name() &rarr; string_view</code></td><td>Runtime name</td></tr>
<tr><td><code>set_name(string_view)</code></td><td>Rename runtime</td></tr>
<tr><td><code>get_id() &rarr; string_view</code></td><td>Unique short ID</td></tr>
<tr><td><code>get_type() &rarr; runtime_type</code></td><td>Server, client, proxy, or cache</td></tr>
<tr><td><code>get_state() &rarr; runtime_state</code></td><td>Current lifecycle state</td></tr>
</tbody>
</table>

<h4>Configuration</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_port(uint16_t)</code></td><td>Listen/connect port</td></tr>
<tr><td><code>set_event_loop(event_loop*)</code></td><td><strong>Required</strong> &mdash; event loop reference</td></tr>
<tr><td><code>set_runtime_manager(runtime_manager*)</code></td><td><strong>Required</strong> &mdash; manager reference</td></tr>
<tr><td><code>set_cache_name(string_view)</code></td><td>Link to a cache runtime by name</td></tr>
<tr><td><code>set_target(string_view)</code></td><td>Target address (client type)</td></tr>
<tr><td><code>set_group(string_view)</code></td><td>Group tag (for proxy backend discovery)</td></tr>
<tr><td><code>set_log_file(string_view)</code></td><td>Log output path</td></tr>
</tbody>
</table>

<h4>TLS</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_tls(bool)</code></td><td>Enable/disable TLS</td></tr>
<tr><td><code>set_cert_path(string_view)</code></td><td>Server certificate path</td></tr>
<tr><td><code>set_key_path(string_view)</code></td><td>Private key path</td></tr>
<tr><td><code>set_ca_path(string_view)</code></td><td>CA certificate path (for client verification)</td></tr>
</tbody>
</table>

<h4>Limits</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_max_connections(uint32_t)</code></td><td>Connection limit (0 = unlimited)</td></tr>
<tr><td><code>set_rate_limit(double)</code></td><td>Per-connection rate limit (msgs/sec, 0 = unlimited)</td></tr>
<tr><td><code>set_global_rate_limit(double)</code></td><td>Aggregate rate limit across all connections</td></tr>
<tr><td><code>set_idle_timeout(uint32_t)</code></td><td>Disconnect after idle seconds (0 = disabled)</td></tr>
<tr><td><code>set_drain(bool)</code></td><td>Stop accepting new connections (graceful shutdown)</td></tr>
</tbody>
</table>

<h4>Lifecycle &amp; Stats</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>get_connection_count() &rarr; size_t</code></td><td>Current active connections</td></tr>
<tr><td><code>get_stats() &rarr; string</code></td><td>Formatted statistics string</td></tr>
<tr><td><code>get_created_time()</code></td><td>When the runtime was created</td></tr>
<tr><td><code>get_start_time()</code></td><td>When the runtime was last started</td></tr>
</tbody>
</table>

<h4>Lua Integration</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>load_lua_script(string_view)</code></td><td>Load and execute a Lua script file</td></tr>
<tr><td><code>reload_lua_script()</code></td><td>Hot-reload the current Lua script</td></tr>
<tr><td><code>get_lua_script_path() &rarr; string_view</code></td><td>Currently loaded script path</td></tr>
</tbody>
</table>

<h4>Bash Output</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_bash_output(bool)</code></td><td>Echo client messages to stdout</td></tr>
<tr><td><code>set_bash_prefix(bool)</code></td><td>Prefix output with client fd</td></tr>
<tr><td><code>set_bash_timestamp(bool)</code></td><td>Prefix output with timestamp</td></tr>
</tbody>
</table>

<h3 id="sdk-t2-callbacks">C++ Callbacks</h3>
<p>Set C++ callbacks directly on any runtime as an alternative to Lua scripts. These fire on the io_uring event loop thread.</p>

<div class="callback-card" id="sdk-cb-onstart">
<div class="method-header">
  <span class="method-name">set_on_start</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-all">All</span>
</div>
<p class="method-sig">void set_on_start(std::function&lt;void()&gt; cb)</p>
<p class="method-desc">Fires when the runtime transitions to <code>running</code> state.</p>
<p class="fires">Fires: once per start</p>
</div>

<div class="callback-card" id="sdk-cb-onstop">
<div class="method-header">
  <span class="method-name">set_on_stop</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-all">All</span>
</div>
<p class="method-sig">void set_on_stop(std::function&lt;void()&gt; cb)</p>
<p class="method-desc">Fires when the runtime is stopped.</p>
<p class="fires">Fires: once per stop</p>
</div>

<div class="callback-card" id="sdk-cb-onconnect">
<div class="method-header">
  <span class="method-name">set_on_connect</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void set_on_connect(std::function&lt;void(int fd)&gt; cb)</p>
<p class="method-desc">Fires when a new client connects. The <code>fd</code> is the client's file descriptor, used as the client ID in all subsequent operations.</p>
<p class="fires">Fires: per connection</p>
</div>

<div class="callback-card" id="sdk-cb-ondisconnect">
<div class="method-header">
  <span class="method-name">set_on_disconnect</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void set_on_disconnect(std::function&lt;void(int fd)&gt; cb)</p>
<p class="method-desc">Fires when a client disconnects (gracefully or on error).</p>
<p class="fires">Fires: per disconnection</p>
</div>

<div class="callback-card" id="sdk-cb-onclientmsg">
<div class="method-header">
  <span class="method-name">set_on_client_message</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void set_on_client_message(std::function&lt;void(int fd, std::string_view msg)&gt; cb)</p>
<p class="method-desc">Fires when a message arrives from a connected client. Messages are newline-delimited. WebSocket frames are automatically decoded.</p>
<p class="fires">Fires: per message</p>
</div>

<div class="callback-card" id="sdk-cb-onmessage">
<div class="method-header">
  <span class="method-name">set_on_message</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-all">All</span>
</div>
<p class="method-sig">void set_on_message(std::function&lt;void(std::string_view msg)&gt; cb)</p>
<p class="method-desc">Fires when a broadcast message is received (e.g. from <code>socketley send</code>).</p>
<p class="fires">Fires: per broadcast</p>
</div>

<div class="callback-card" id="sdk-cb-ontick">
<div class="method-header">
  <span class="method-name">set_on_tick</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-all">All</span>
</div>
<p class="method-sig">void set_on_tick(std::function&lt;void(double dt_ms)&gt; cb)</p>
<p class="method-desc">Fires periodically at the interval set by <code>set_tick_interval(ms)</code>. The <code>dt_ms</code> parameter is the actual elapsed time since the last tick.</p>
<pre><code>srv-&gt;<span class="fn">set_tick_interval</span>(<span class="nb">1000</span>);  <span class="cm">// 1 second</span>
srv-&gt;<span class="fn">set_on_tick</span>([](<span class="kw">double</span> dt) {
    printf(<span class="st">"tick: %.1f ms\n"</span>, dt);
});</code></pre>
</div>

<h3 id="sdk-t2-server">server_instance</h3>
<p><code>#include &lt;socketley/server.h&gt;</code> &mdash; TCP/UDP server with auto-WebSocket detection.</p>

<h4>Modes</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_mode(server_mode)</code></td><td><code>mode_inout</code> (bidirectional), <code>mode_in</code> (receive only), <code>mode_out</code> (broadcast only), <code>mode_master</code> (first connection is admin)</td></tr>
<tr><td><code>set_udp(bool)</code></td><td>Enable UDP datagram mode</td></tr>
<tr><td><code>set_http_dir(string_view)</code></td><td>Serve static files from directory (enables HTTP mode)</td></tr>
<tr><td><code>set_http_cache(bool)</code></td><td>Cache file contents in memory</td></tr>
<tr><td><code>set_master_pw(string_view)</code></td><td>Set password for master/replica authentication</td></tr>
<tr><td><code>set_master_forward(bool)</code></td><td>Enable forwarding writes to master in replica mode</td></tr>
</tbody>
</table>

<h4>Actions</h4>

<div class="method-card" id="sdk-srv-broadcast">
<div class="method-header">
  <span class="method-name">lua_broadcast</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void lua_broadcast(std::string_view msg)</p>
<p class="method-desc">Send a message to all connected clients. WebSocket clients receive it as a WebSocket frame.</p>
</div>

<div class="method-card" id="sdk-srv-sendto">
<div class="method-header">
  <span class="method-name">lua_send_to</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void lua_send_to(int client_id, std::string_view msg)</p>
<p class="method-desc">Send a message to a specific client by fd.</p>
</div>

<div class="method-card" id="sdk-srv-disconnect">
<div class="method-header">
  <span class="method-name">lua_disconnect</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void lua_disconnect(int client_fd)</p>
<p class="method-desc">Disconnect a client. Uses <code>SHUT_RD</code> (not <code>SHUT_RDWR</code>) so queued writes still reach the client before the connection closes.</p>
</div>

<div class="method-card" id="sdk-srv-peerip">
<div class="method-header">
  <span class="method-name">lua_peer_ip</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">std::string lua_peer_ip(int client_fd)</p>
<p class="method-desc">Get the IP address of a connected client. Returns IPv4 or IPv6 string.</p>
</div>

<div class="method-card" id="sdk-srv-clients">
<div class="method-header">
  <span class="method-name">lua_clients</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">std::vector&lt;int&gt; lua_clients() const</p>
<p class="method-desc">Get all connected client file descriptors.</p>
</div>

<div class="method-card" id="sdk-srv-multicast">
<div class="method-header">
  <span class="method-name">lua_multicast</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void lua_multicast(const std::vector&lt;int&gt;&amp; fds, std::string_view msg)</p>
<p class="method-desc">Send a message to a subset of clients. Uses a zero-copy shared buffer path internally.</p>
</div>

<h4>Metadata</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>lua_set_data(fd, key, val)</code></td><td>Set per-connection metadata</td></tr>
<tr><td><code>lua_get_data(fd, key)</code></td><td>Get per-connection metadata</td></tr>
<tr><td><code>lua_del_data(fd, key)</code></td><td>Delete per-connection metadata</td></tr>
<tr><td><code>lua_ws_headers(fd)</code></td><td>Get WebSocket upgrade headers (cookie, origin, protocol, auth)</td></tr>
</tbody>
</table>

<h4>Routing</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>route_client(fd, target_name)</code></td><td>Forward a client to another server runtime</td></tr>
<tr><td><code>unroute_client(fd)</code></td><td>Remove client routing</td></tr>
<tr><td><code>owner_send(fd, msg)</code></td><td>Send to parent server's client</td></tr>
<tr><td><code>owner_broadcast(msg)</code></td><td>Broadcast to parent server's clients</td></tr>
</tbody>
</table>

<h3 id="sdk-t2-cache">cache_instance</h3>
<p><code>#include &lt;socketley/cache.h&gt;</code> &mdash; Redis-compatible in-memory data store with RESP2 auto-detection.</p>

<h4>Modes</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_mode(cache_mode)</code></td><td><code>cache_mode_readonly</code> (GET only), <code>cache_mode_readwrite</code> (GET/SET/DEL), <code>cache_mode_admin</code> (all commands)</td></tr>
<tr><td><code>set_resp_forced(bool)</code></td><td>Force RESP2 wire protocol (for redis-benchmark compatibility)</td></tr>
</tbody>
</table>

<h4>Persistence &amp; Memory</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_persistent(string_view path)</code></td><td>RDB snapshot path (auto-load on start, auto-save on stop)</td></tr>
<tr><td><code>set_max_memory(size_t bytes)</code></td><td>Memory limit (0 = unlimited)</td></tr>
<tr><td><code>set_eviction(eviction_policy)</code></td><td><code>evict_none</code>, <code>evict_allkeys_lru</code>, <code>evict_allkeys_random</code></td></tr>
<tr><td><code>flush_to(string_view path)</code></td><td>Save cache to file</td></tr>
<tr><td><code>load_from(string_view path)</code></td><td>Load cache from file</td></tr>
</tbody>
</table>

<h4>Replication</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_replicate_target(string_view)</code></td><td>Leader address (makes this cache a follower)</td></tr>
<tr><td><code>get_repl_role()</code></td><td>Returns <code>repl_none</code>, <code>repl_leader</code>, or <code>repl_follower</code></td></tr>
</tbody>
</table>

<h4 id="sdk-t2-cache-strings">Strings</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_set</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_set(const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-desc">Set a string value. Overwrites any existing key regardless of type.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> on success</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_get</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">std::string lua_get(const std::string&amp; key)</p>
<p class="method-desc">Get a string value by key.</p>
<p class="method-returns"><strong>Returns:</strong> The value, or empty string if key doesn't exist</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_del</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_del(const std::string&amp; key)</p>
<p class="method-desc">Delete a key of any type.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if the key existed and was deleted</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">store_direct</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">void store_direct(const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-desc">Direct write into the backing store, bypassing protocol parsing. Used internally by server <code>--cache</code> integration.</p>
</div>

<h4 id="sdk-t2-cache-lists">Lists</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_lpush / lua_rpush</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_lpush(const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-sig">bool lua_rpush(const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-desc">Push a value to the head (<code>lpush</code>) or tail (<code>rpush</code>) of a list. Creates the list if it doesn't exist.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> on success, <code>false</code> on type conflict (key exists but isn't a list)</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_lpop / lua_rpop</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">std::string lua_lpop(const std::string&amp; key)</p>
<p class="method-sig">std::string lua_rpop(const std::string&amp; key)</p>
<p class="method-desc">Pop and return the first (<code>lpop</code>) or last (<code>rpop</code>) element of a list.</p>
<p class="method-returns"><strong>Returns:</strong> The value, or empty string if the list is empty or doesn't exist</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_llen</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">int lua_llen(const std::string&amp; key)</p>
<p class="method-desc">Get the length of a list.</p>
<p class="method-returns"><strong>Returns:</strong> Element count, or <code>0</code> if key doesn't exist</p>
</div>

<h4 id="sdk-t2-cache-sets">Sets</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_sadd</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">int lua_sadd(const std::string&amp; key, const std::string&amp; member)</p>
<p class="method-desc">Add a member to a set. Creates the set if it doesn't exist.</p>
<p class="method-returns"><strong>Returns:</strong> <code>1</code> if added, <code>0</code> if already exists, <code>-1</code> on type conflict</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_srem</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_srem(const std::string&amp; key, const std::string&amp; member)</p>
<p class="method-desc">Remove a member from a set.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if the member was removed</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_sismember</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_sismember(const std::string&amp; key, const std::string&amp; member)</p>
<p class="method-desc">Check if a member exists in a set.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if the member is in the set</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_scard</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">int lua_scard(const std::string&amp; key)</p>
<p class="method-desc">Get the number of members in a set.</p>
<p class="method-returns"><strong>Returns:</strong> Member count, or <code>0</code> if key doesn't exist</p>
</div>

<h4 id="sdk-t2-cache-hashes">Hashes</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_hset</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_hset(const std::string&amp; key, const std::string&amp; field, const std::string&amp; value)</p>
<p class="method-desc">Set a field in a hash. Creates the hash if it doesn't exist.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> on success</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_hget</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">std::string lua_hget(const std::string&amp; key, const std::string&amp; field)</p>
<p class="method-desc">Get the value of a hash field.</p>
<p class="method-returns"><strong>Returns:</strong> The value, or empty string if field or key doesn't exist</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_hdel</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_hdel(const std::string&amp; key, const std::string&amp; field)</p>
<p class="method-desc">Delete a field from a hash.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if the field was removed</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_hlen</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">int lua_hlen(const std::string&amp; key)</p>
<p class="method-desc">Get the number of fields in a hash.</p>
<p class="method-returns"><strong>Returns:</strong> Field count, or <code>0</code> if key doesn't exist</p>
</div>

<h4 id="sdk-t2-cache-ttl">TTL / Expiry</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_expire</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_expire(const std::string&amp; key, int seconds)</p>
<p class="method-desc">Set a TTL on a key. The key is automatically deleted after the timeout.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if the timeout was set, <code>false</code> if key doesn't exist</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_ttl</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">int lua_ttl(const std::string&amp; key)</p>
<p class="method-desc">Get the remaining time-to-live of a key in seconds.</p>
<p class="method-returns"><strong>Returns:</strong> Seconds remaining, <code>-1</code> if key has no TTL, <code>-2</code> if key doesn't exist</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_persist</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_persist(const std::string&amp; key)</p>
<p class="method-desc">Remove the TTL from a key, making it persistent.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if the timeout was removed, <code>false</code> if key doesn't exist or had no TTL</p>
</div>

<h4 id="sdk-t2-cache-pubsub">Pub/Sub</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">publish</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">int publish(const std::string&amp; channel, const std::string&amp; message)</p>
<p class="method-desc">Publish a message to a channel. All clients subscribed to the channel (via SUBSCRIBE command or Lua <code>socketley.subscribe()</code>) receive the message.</p>
<p class="method-returns"><strong>Returns:</strong> Number of subscribers that received the message</p>
</div>

<h5>Receiving Published Messages</h5>
<p>The <code>publish()</code> method above sends messages. To <strong>receive</strong> them, use one of these approaches:</p>

<table>
<thead><tr><th>Method</th><th>How</th><th>Best for</th></tr></thead>
<tbody>
<tr><td>Lua callback</td><td><code>socketley.subscribe(cache_name, channel, fn)</code> in any runtime's Lua script</td><td>Cross-runtime event handling (recommended)</td></tr>
<tr><td>RESP client</td><td>Connect via TCP, send <code>SUBSCRIBE channel</code>, receive RESP push messages</td><td>External Redis-compatible clients</td></tr>
<tr><td>Text-mode client</td><td>Connect via TCP, send <code>subscribe channel</code>, receive <code>message &lt;channel&gt; &lt;payload&gt;\n</code></td><td>Simple scripting / netcat</td></tr>
</tbody>
</table>

<div class="info-box"><strong>Lua is the primary receive mechanism.</strong> Tier 1 SDK (IPC) cannot receive async push messages &mdash; it's request/response only. Use <code>socketley.subscribe()</code> in a Lua script attached to any runtime to react to published messages. See <a href="#addons-pubsub">Cross-Runtime Pub/Sub</a> for the full API.</div>

<p><strong>Example:</strong> A server that broadcasts cache events to all TCP clients:</p>
<pre><code><span class="cm">-- notify.lua (attach to a server runtime)</span>
<span class="kw">function</span> <span class="fn">on_start</span>()
    socketley.<span class="fn">subscribe</span>(<span class="st">"store"</span>, <span class="st">"events"</span>, <span class="kw">function</span>(ch, msg)
        self.<span class="fn">broadcast</span>(<span class="st">"event: "</span> .. msg)
    <span class="kw">end</span>)
<span class="kw">end</span></code></pre>

<h4 id="sdk-t2-cache-mgmt">Management</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">get_size</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">uint32_t get_size()</p>
<p class="method-desc">Get the total number of keys in the cache store.</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">store_memory_used</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">size_t store_memory_used()</p>
<p class="method-desc">Get the approximate memory used by the cache store in bytes.</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">flush_to / load_from</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool flush_to(std::string_view path)</p>
<p class="method-sig">bool load_from(std::string_view path)</p>
<p class="method-desc">Save or load the entire cache to/from a binary snapshot file. Requires admin mode.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> on success</p>
</div>

<h4 id="sdk-t2-cache-textproto">Text-Protocol Command Reference</h4>
<p>The cache runtime supports 40+ commands via the text protocol (line-based, newline-delimited) and RESP2 (Redis wire protocol). Both protocols support the same command set. Text protocol is used by default; RESP2 is auto-detected or forced with <code>--resp-forced</code>.</p>
<p>Access these commands via TCP connections, <code>execute()</code> in Tier 2 code, or interactive mode (<code>-i</code> flag):</p>

<div class="method-card">
<div class="method-header">
  <span class="method-name">execute</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">std::string execute(const std::string&amp; command)</p>
<p class="method-desc">Execute a text-protocol command string directly on the cache instance and return the response. Bypasses the network layer.</p>
<pre><code>std::string val  = cache-&gt;<span class="fn">execute</span>(<span class="st">"INCR counter"</span>);       <span class="cm">// "1"</span>
std::string list = cache-&gt;<span class="fn">execute</span>(<span class="st">"LRANGE mylist 0 -1"</span>); <span class="cm">// "a\nb\nc"</span>
std::string info = cache-&gt;<span class="fn">execute</span>(<span class="st">"DBSIZE"</span>);              <span class="cm">// "42"</span></code></pre>
</div>

<h5>Strings</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>SET</code></td><td><code>SET key value [EX s] [PX ms] [NX|XX]</code></td><td>Set value with optional expiry and condition flags</td></tr>
<tr><td><code>GET</code></td><td><code>GET key</code></td><td>Get string value</td></tr>
<tr><td><code>DEL</code></td><td><code>DEL key</code></td><td>Delete key</td></tr>
<tr><td><code>EXISTS</code></td><td><code>EXISTS key</code></td><td>Check if key exists (1/0)</td></tr>
<tr><td><code>INCR</code></td><td><code>INCR key</code></td><td>Increment integer value by 1</td></tr>
<tr><td><code>DECR</code></td><td><code>DECR key</code></td><td>Decrement integer value by 1</td></tr>
<tr><td><code>INCRBY</code></td><td><code>INCRBY key delta</code></td><td>Increment by arbitrary integer</td></tr>
<tr><td><code>DECRBY</code></td><td><code>DECRBY key delta</code></td><td>Decrement by arbitrary integer</td></tr>
<tr><td><code>APPEND</code></td><td><code>APPEND key suffix</code></td><td>Append to string, returns new length</td></tr>
<tr><td><code>STRLEN</code></td><td><code>STRLEN key</code></td><td>Get string length</td></tr>
<tr><td><code>GETSET</code></td><td><code>GETSET key value</code></td><td>Set value and return old value</td></tr>
<tr><td><code>MGET</code></td><td><code>MGET key [key ...]</code></td><td>Get multiple values</td></tr>
<tr><td><code>MSET</code></td><td><code>MSET key value [key value ...]</code></td><td>Set multiple key-value pairs</td></tr>
<tr><td><code>SETNX</code></td><td><code>SETNX key value</code></td><td>Set only if key does not exist</td></tr>
<tr><td><code>SETEX</code></td><td><code>SETEX key seconds value</code></td><td>Set with expiry in seconds</td></tr>
<tr><td><code>PSETEX</code></td><td><code>PSETEX key ms value</code></td><td>Set with expiry in milliseconds</td></tr>
</tbody>
</table>

<h5>Lists</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>LPUSH</code></td><td><code>LPUSH key value</code></td><td>Push to head</td></tr>
<tr><td><code>RPUSH</code></td><td><code>RPUSH key value</code></td><td>Push to tail</td></tr>
<tr><td><code>LPOP</code></td><td><code>LPOP key</code></td><td>Pop from head</td></tr>
<tr><td><code>RPOP</code></td><td><code>RPOP key</code></td><td>Pop from tail</td></tr>
<tr><td><code>LLEN</code></td><td><code>LLEN key</code></td><td>List length</td></tr>
<tr><td><code>LINDEX</code></td><td><code>LINDEX key index</code></td><td>Get element by index</td></tr>
<tr><td><code>LRANGE</code></td><td><code>LRANGE key start stop</code></td><td>Get range of elements (0-based, -1 = last)</td></tr>
</tbody>
</table>

<h5>Sets</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>SADD</code></td><td><code>SADD key member</code></td><td>Add member to set</td></tr>
<tr><td><code>SREM</code></td><td><code>SREM key member</code></td><td>Remove member from set</td></tr>
<tr><td><code>SISMEMBER</code></td><td><code>SISMEMBER key member</code></td><td>Check membership (1/0)</td></tr>
<tr><td><code>SCARD</code></td><td><code>SCARD key</code></td><td>Set cardinality</td></tr>
<tr><td><code>SMEMBERS</code></td><td><code>SMEMBERS key</code></td><td>List all members</td></tr>
</tbody>
</table>

<h5>Hashes</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>HSET</code></td><td><code>HSET key field value</code></td><td>Set hash field</td></tr>
<tr><td><code>HGET</code></td><td><code>HGET key field</code></td><td>Get hash field value</td></tr>
<tr><td><code>HDEL</code></td><td><code>HDEL key field</code></td><td>Delete hash field</td></tr>
<tr><td><code>HLEN</code></td><td><code>HLEN key</code></td><td>Number of fields in hash</td></tr>
<tr><td><code>HGETALL</code></td><td><code>HGETALL key</code></td><td>Get all field-value pairs</td></tr>
</tbody>
</table>

<h5>TTL / Expiry</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>EXPIRE</code></td><td><code>EXPIRE key seconds</code></td><td>Set TTL in seconds</td></tr>
<tr><td><code>PEXPIRE</code></td><td><code>PEXPIRE key ms</code></td><td>Set TTL in milliseconds</td></tr>
<tr><td><code>TTL</code></td><td><code>TTL key</code></td><td>Remaining TTL in seconds (-1 = no TTL, -2 = missing)</td></tr>
<tr><td><code>PTTL</code></td><td><code>PTTL key</code></td><td>Remaining TTL in milliseconds</td></tr>
<tr><td><code>PERSIST</code></td><td><code>PERSIST key</code></td><td>Remove TTL</td></tr>
<tr><td><code>EXPIREAT</code></td><td><code>EXPIREAT key timestamp</code></td><td>Set expiry at Unix timestamp (seconds)</td></tr>
<tr><td><code>PEXPIREAT</code></td><td><code>PEXPIREAT key timestamp</code></td><td>Set expiry at Unix timestamp (milliseconds)</td></tr>
</tbody>
</table>

<h5>Query &amp; Introspection</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>TYPE</code></td><td><code>TYPE key</code></td><td>Returns <code>"string"</code>, <code>"list"</code>, <code>"set"</code>, <code>"hash"</code>, or <code>"none"</code></td></tr>
<tr><td><code>KEYS</code></td><td><code>KEYS pattern</code></td><td>Find keys matching glob pattern (<code>*</code>, <code>?</code>)</td></tr>
<tr><td><code>SCAN</code></td><td><code>SCAN cursor [MATCH pattern] [COUNT n]</code></td><td>Incrementally iterate keys (cursor-based)</td></tr>
<tr><td><code>DBSIZE</code></td><td><code>DBSIZE</code></td><td>Total key count</td></tr>
</tbody>
</table>

<h5>Pub/Sub</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>PUBLISH</code></td><td><code>PUBLISH channel message</code></td><td>Publish to channel, returns subscriber count</td></tr>
<tr><td><code>SUBSCRIBE</code></td><td><code>SUBSCRIBE channel</code></td><td>Subscribe to channel (push mode)</td></tr>
<tr><td><code>UNSUBSCRIBE</code></td><td><code>UNSUBSCRIBE channel</code></td><td>Unsubscribe from channel</td></tr>
</tbody>
</table>

<h5>Admin</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>PING</code></td><td><code>PING</code></td><td>Returns <code>PONG</code></td></tr>
<tr><td><code>INFO</code></td><td><code>INFO</code></td><td>Server info (keys, memory, connections, uptime)</td></tr>
<tr><td><code>MEMORY</code></td><td><code>MEMORY</code></td><td>Max and used memory</td></tr>
<tr><td><code>FLUSH</code></td><td><code>FLUSH [path]</code></td><td>Save snapshot to disk (admin mode)</td></tr>
<tr><td><code>LOAD</code></td><td><code>LOAD [path]</code></td><td>Load snapshot from disk (admin mode)</td></tr>
</tbody>
</table>

<h3 id="sdk-t2-proxy">proxy_instance</h3>
<p><code>#include &lt;socketley/proxy.h&gt;</code> &mdash; HTTP or TCP reverse proxy with load balancing.</p>

<h4>Protocol &amp; Strategy</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_protocol(proxy_protocol)</code></td><td><code>protocol_http</code> or <code>protocol_tcp</code></td></tr>
<tr><td><code>set_strategy(proxy_strategy)</code></td><td><code>strategy_round_robin</code>, <code>strategy_random</code>, <code>strategy_lua</code></td></tr>
</tbody>
</table>

<h4>Backends</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>add_backend(string_view addr)</code></td><td>Add backend (<code>"host:port"</code> or <code>"@group"</code> for dynamic discovery)</td></tr>
<tr><td><code>clear_backends()</code></td><td>Remove all backends</td></tr>
<tr><td><code>get_backends()</code></td><td>Get current backend list</td></tr>
</tbody>
</table>

<h3 id="sdk-t2-client">client_instance</h3>
<p><code>#include &lt;socketley/client.h&gt;</code> &mdash; TCP or UDP client that connects to a remote server.</p>

<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_mode(client_mode)</code></td><td><code>client_mode_inout</code>, <code>client_mode_in</code>, <code>client_mode_out</code></td></tr>
<tr><td><code>set_udp(bool)</code></td><td>Use UDP datagrams</td></tr>
<tr><td><code>set_target(string_view)</code></td><td>Target address (<code>"host:port"</code>)</td></tr>
<tr><td><code>set_reconnect(int)</code></td><td>Reconnect attempts (-1 = disabled, 0 = infinite)</td></tr>
<tr><td><code>lua_send(string_view msg)</code></td><td>Send data to the connected server</td></tr>
</tbody>
</table>

<h3 id="sdk-t2-enums">Enums &amp; Constants</h3>
<pre><code><span class="cm">// Runtime types</span>
<span class="kw">enum</span> runtime_type  { runtime_server, runtime_client, runtime_proxy, runtime_cache };
<span class="kw">enum</span> runtime_state { runtime_created, runtime_running, runtime_stopped, runtime_failed };

<span class="cm">// Server modes</span>
<span class="kw">enum</span> server_mode { mode_inout, mode_in, mode_out, mode_master };

<span class="cm">// Cache modes</span>
<span class="kw">enum</span> cache_mode { cache_mode_readonly, cache_mode_readwrite, cache_mode_admin };

<span class="cm">// Cache eviction</span>
<span class="kw">enum</span> eviction_policy { evict_none, evict_allkeys_lru, evict_allkeys_random };

<span class="cm">// Proxy settings</span>
<span class="kw">enum</span> proxy_protocol { protocol_http, protocol_tcp };
<span class="kw">enum</span> proxy_strategy { strategy_round_robin, strategy_random, strategy_lua };

<span class="cm">// Client modes</span>
<span class="kw">enum</span> client_mode { client_mode_inout, client_mode_in, client_mode_out };</code></pre>

<!-- ══════════════════════════════════════════════════════════════
     TIER 3: DAEMON ATTACH
══════════════════════════════════════════════════════════════ -->
<h2 id="sdk-t3">Tier 3: Daemon Attach</h2>
<p><code>#include &lt;socketley/attach.h&gt;</code> &mdash; header-only, zero dependencies. Register your own process as a runtime in a running daemon.</p>

<h3 id="sdk-t3-api">API</h3>

<div class="method-card" id="sdk-attach">
<div class="method-header">
  <span class="method-name">daemon_attach</span>
  <span class="badge badge-tier3">Tier 3</span>
</div>
<p class="method-sig">bool socketley::daemon_attach(const std::string&amp; name, const std::string&amp; type, uint16_t port)</p>
<p class="method-desc">Register the current process with the daemon. After calling, your process appears in <code>socketley ls</code>, <code>socketley stats</code>, and <code>socketley ps</code>. Automatically deregisters on <code>exit()</code> via <code>atexit()</code>.</p>
<table>
<thead><tr><th>Parameter</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code></td><td>Name to register under</td></tr>
<tr><td><code>type</code></td><td><code>"server"</code>, <code>"client"</code>, <code>"proxy"</code>, or <code>"cache"</code></td></tr>
<tr><td><code>port</code></td><td>Port your service is listening on</td></tr>
</tbody>
</table>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if daemon accepted the registration, <code>false</code> if daemon not running (service works standalone)</p>
</div>

<div class="method-card" id="sdk-detach">
<div class="method-header">
  <span class="method-name">daemon_detach</span>
  <span class="badge badge-tier3">Tier 3</span>
</div>
<p class="method-sig">void socketley::daemon_detach(const std::string&amp; name)</p>
<p class="method-sig">void socketley::daemon_detach()</p>
<p class="method-desc">Explicitly deregister a runtime. The no-argument form deregisters the name from the last <code>daemon_attach()</code> call.</p>
</div>

<h3 id="sdk-t3-lifecycle">Lifecycle</h3>
<p>The typical Tier 3 pattern:</p>
<ol>
<li>Start your own server (any framework, any language with C++ FFI)</li>
<li>Call <code>daemon_attach()</code> &mdash; registers with daemon</li>
<li>Run your accept loop / event loop</li>
<li>On shutdown: <code>daemon_detach()</code> is called automatically via <code>atexit()</code></li>
</ol>

<div class="info-box"><strong>Graceful degradation:</strong> If the daemon isn't running, <code>daemon_attach()</code> returns <code>false</code> and your service continues working in standalone mode. This makes Tier 3 safe to use unconditionally.</div>

<h3 id="sdk-t3-managed">Managed Mode</h3>
<p>When a binary is registered via <code>socketley add</code>, the daemon fork+exec's it with two environment variables:</p>
<table>
<thead><tr><th>Variable</th><th>Value</th></tr></thead>
<tbody>
<tr><td><code>SOCKETLEY_MANAGED=1</code></td><td>Always <code>"1"</code> for managed binaries</td></tr>
<tr><td><code>SOCKETLEY_NAME=&lt;name&gt;</code></td><td>The runtime name assigned by <code>--name</code> or derived from the binary path</td></tr>
</tbody>
</table>
<p><code>daemon_attach()</code> detects these automatically:</p>
<ul>
<li>Uses <code>SOCKETLEY_NAME</code> as the runtime name (overriding the <code>name</code> parameter)</li>
<li>Sends <code>--managed</code> flag in the attach IPC command so the daemon updates the existing entry instead of creating a new one</li>
<li>Skips the <code>atexit()</code> self-removal &mdash; the daemon owns the lifecycle</li>
</ul>
<p>No code changes are needed in the binary &mdash; the same <code>daemon_attach()</code> call works both standalone and managed.</p>

<div class="info-box"><strong>Managed vs Attached:</strong> <code>attach</code> gives the daemon visibility only. <code>add</code> gives full lifecycle management: auto-restart on crash (~2s), re-launch on daemon boot, and proper <code>stop</code>/<code>start</code> cycling. See the <code>socketley add</code> command in the CLI reference.</div>

<!-- ══════════════════════════════════════════════════════════════
     PATTERNS & BEST PRACTICES
══════════════════════════════════════════════════════════════ -->
<h2 id="sdk-patterns">Patterns &amp; Best Practices</h2>

<h3 id="sdk-pat-mixed">Mixed: Tier 2 + Tier 3</h3>
<p>Embed the full engine for maximum performance, then register with the daemon for fleet visibility:</p>
<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/server.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;socketley/attach.h&gt;</span>

socketley::server <span class="fn">srv</span>(<span class="nb">9000</span>);
srv.<span class="fn">on_message</span>([&amp;](<span class="kw">int</span> fd, std::string_view msg) {
    srv.<span class="fn">send</span>(fd, msg);
});

<span class="cm">// Register with daemon (Tier 3)</span>
socketley::<span class="fn">daemon_attach</span>(<span class="st">"app_srv"</span>, <span class="st">"server"</span>, <span class="nb">9000</span>);

srv.<span class="fn">start</span>();  <span class="cm">// daemon sees the runtime</span>
<span class="cm">// daemon_detach() called automatically via atexit()</span></code></pre>

<div class="info-box"><strong>Multiple runtimes:</strong> <code>daemon_attach()</code> can only auto-detach one name via <code>atexit()</code>. For additional runtimes, use <code>socketley::ctl::command("attach ...")</code> and manually detach on shutdown.</div>

<h3 id="sdk-pat-signals">Signal Handling</h3>
<pre><code><span class="cm">// Always ignore SIGPIPE — io_uring writes CAN trigger it</span>
signal(SIGPIPE, SIG_IGN);

<span class="cm">// Use a global event_loop pointer for signal handlers</span>
<span class="kw">static</span> event_loop* g_loop = <span class="kw">nullptr</span>;
<span class="cm">// ... after init ...</span>
g_loop = &amp;loop;

<span class="cm">// Graceful shutdown on Ctrl-C / kill</span>
signal(SIGINT,  [](<span class="kw">int</span>) { <span class="kw">if</span> (g_loop) g_loop-&gt;<span class="fn">request_stop</span>(); });
signal(SIGTERM, [](<span class="kw">int</span>) { <span class="kw">if</span> (g_loop) g_loop-&gt;<span class="fn">request_stop</span>(); });</code></pre>
<div class="warn-box"><strong>SIGPIPE is critical.</strong> Without <code>signal(SIGPIPE, SIG_IGN)</code>, a disconnected client can kill your entire process when io_uring delivers a write to a closed socket.</div>
<div class="info-box"><strong>Wrapper classes handle all of this automatically.</strong> <code>socketley::server</code>, <code>socketley::client</code>, <code>socketley::proxy</code>, and <code>socketley::cache</code> install SIGPIPE, SIGINT, and SIGTERM handlers internally. Manual signal setup is only needed with the raw API.</div>

<h3 id="sdk-pat-lua">Lua Integration</h3>
<p>Tier 2 runtimes can load Lua scripts just like daemon-managed runtimes. The Lua callbacks and C++ callbacks work together &mdash; C++ callbacks fire first, then Lua callbacks (if both are set).</p>
<pre><code><span class="kw">auto</span>* srv = <span class="kw">static_cast</span>&lt;server_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"chat"</span>));

<span class="cm">// Try loading Lua script</span>
<span class="kw">bool</span> lua_ok = srv-&gt;<span class="fn">load_lua_script</span>(<span class="st">"chat.lua"</span>);
<span class="kw">if</span> (!lua_ok) {
    <span class="cm">// Fallback to C++ callbacks</span>
    srv-&gt;<span class="fn">set_on_client_message</span>([srv](<span class="kw">int</span>, std::string_view msg) {
        srv-&gt;<span class="fn">lua_broadcast</span>(msg);
    });
}</code></pre>
<div class="info-box">Build with <code>-lluajit</code> to enable Lua support, or define <code>SOCKETLEY_NO_LUA</code> to compile without it.</div>

<h3 id="sdk-pat-choosing">Choosing a Tier</h3>
<table>
<thead><tr><th>Use Case</th><th>Tier</th><th>Why</th></tr></thead>
<tbody>
<tr><td>Deployment scripts, CI/CD</td><td><span class="badge badge-tier1">Tier 1</span></td><td>Header-only, zero deps, simple API</td></tr>
<tr><td>Monitoring dashboards</td><td><span class="badge badge-tier1">Tier 1</span></td><td>Query stats, list runtimes</td></tr>
<tr><td>Custom game server</td><td><span class="badge badge-tier2">Tier 2</span></td><td>Full control, max performance, C++ callbacks</td></tr>
<tr><td>IoT gateway</td><td><span class="badge badge-tier2">Tier 2</span></td><td>Embed engine, multiple protocols</td></tr>
<tr><td>Legacy service integration</td><td><span class="badge badge-tier3">Tier 3</span></td><td>Register existing service with daemon fleet</td></tr>
<tr><td>Auto-restarting service</td><td><span class="badge badge-tier3">Tier 3</span> + <code>add</code></td><td>Daemon manages lifecycle: auto-restart, boot re-launch</td></tr>
<tr><td>Microservice with monitoring</td><td><span class="badge badge-mixed">Mixed</span></td><td>Embedded engine + daemon visibility</td></tr>
</tbody>
</table>

</div><!-- #content-socketley-sdk -->
