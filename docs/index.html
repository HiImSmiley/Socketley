<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Socketley Documentation</title>
<link rel="stylesheet" href="css/style.css">
</head>
<body>

<button class="menu-toggle" id="menuToggle" aria-label="Toggle menu">&#9776;</button>
<div class="overlay" id="overlay"></div>

<aside class="sidebar" id="sidebar">
  <div class="sidebar-header">
    <div class="brand">
      <h1>Socketley</h1>
      <p>Documentation</p>
      <a class="github-link" href="https://github.com/HiImSmiley/Socketley" target="_blank" rel="noopener">
        <svg viewBox="0 0 16 16"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
        GitHub
      </a>
    </div>
  </div>

  <!-- Tab Switcher -->
  <div class="tab-switcher">
    <button class="tab-btn" data-tab="socketley">Socketley</button>
    <button class="tab-btn" data-tab="lua">Lua</button>
    <button class="tab-btn" data-tab="examples">Examples</button>
  </div>

  <!-- Socketley Sub-tabs (CLI | C++ SDK) -->
  <div id="skSubTabs" class="sub-tab-switcher" style="display:none">
    <button class="sub-tab-btn active" data-subtab="cli" data-subtab-group="sk">CLI</button>
    <button class="sub-tab-btn" data-subtab="sdk" data-subtab-group="sk">C++ SDK</button>
  </div>

  <!-- Lua Sub-tabs (API | Addons) -->
  <div id="luaSubTabs" class="sub-tab-switcher" style="display:none">
    <button class="sub-tab-btn active" data-subtab="api" data-subtab-group="lua">API</button>
    <button class="sub-tab-btn" data-subtab="addons" data-subtab-group="lua">Addons</button>
  </div>

  <!-- Examples Sub-tabs (CLI | C++ SDK) -->
  <div id="exSubTabs" class="sub-tab-switcher" style="display:none">
    <button class="sub-tab-btn active" data-subtab="cli" data-subtab-group="ex">CLI</button>
    <button class="sub-tab-btn" data-subtab="sdk" data-subtab-group="ex">C++ SDK</button>
  </div>

  <!-- Search -->
  <div class="search-box">
    <input type="text" id="search" placeholder="Search docs..." autocomplete="off">
  </div>

  <nav>
    <!-- ── Socketley Nav ── -->
    <ul id="navList-socketley">
      <li><a href="#getting-started">Getting Started</a><ul>
        <li><a href="#gs-install">Installation</a></li>
        <li><a href="#gs-first-server">Your First Server</a></li>
        <li><a href="#gs-next">Where to Go Next</a></li>
      </ul></li>
      <li><a href="#concepts">Key Concepts</a><ul>
        <li><a href="#concept-runtimes">Runtimes</a></li>
        <li><a href="#concept-websocket">WebSocket Auto-Detection</a></li>
        <li><a href="#concept-cache">Cache Attachment</a></li>
        <li><a href="#concept-http">HTTP Serving</a></li>
        <li><a href="#concept-names">Runtime Name Networking</a></li>
        <li><a href="#concept-groups">Group-Based Discovery</a></li>
        <li><a href="#concept-lua">Writing Lua Scripts</a></li>
      </ul></li>
      <li><a href="#cli-commands">CLI Commands</a><ul>
        <li><a href="#cmd-create">create</a></li>
        <li><a href="#cmd-start-stop">start / stop / remove</a></li>
        <li><a href="#cmd-send">send</a></li>
        <li><a href="#cmd-stats">stats</a></li>
        <li><a href="#cmd-reload">reload / reload-lua</a></li>
        <li><a href="#cmd-show-edit">show / edit</a></li>
        <li><a href="#cmd-ls-ps">ls / ps / owner</a></li>
        <li><a href="#cmd-daemon">daemon</a></li>
        <li><a href="#cmd-cluster">cluster</a></li>
      </ul></li>
      <li><a href="#cli-flags">CLI Flags</a><ul>
        <li><a href="#flags-daemon">Daemon</a></li>
        <li><a href="#flags-common">Common</a></li>
        <li><a href="#flags-server">Server</a></li>
        <li><a href="#flags-client">Client</a></li>
        <li><a href="#flags-cache">Cache</a></li>
        <li><a href="#flags-proxy">Proxy</a></li>
      </ul></li>
      <li><a href="#runtime-types">Runtime Types</a><ul>
        <li><a href="#rt-server">Server</a></li>
        <li><a href="#rt-client">Client</a></li>
        <li><a href="#rt-proxy">Proxy</a></li>
        <li><a href="#rt-cache">Cache</a></li>
      </ul></li>
      <li><a href="#cache-protocol">Cache Protocol</a><ul>
        <li><a href="#cp-strings">Strings</a></li>
        <li><a href="#cp-lists">Lists</a></li>
        <li><a href="#cp-sets">Sets</a></li>
        <li><a href="#cp-hashes">Hashes</a></li>
        <li><a href="#cp-ttl">TTL / Expiry</a></li>
        <li><a href="#cp-pubsub">Pub/Sub</a></li>
        <li><a href="#cp-memory">Memory &amp; Admin</a></li>
        <li><a href="#cp-resp">RESP2</a></li>
      </ul></li>
      <li><a href="#configuration">Configuration</a><ul>
        <li><a href="#config-flag">--lua Flag</a></li>
        <li><a href="#config-runtimes">runtimes Table</a></li>
        <li><a href="#config-daemon">Daemon Config</a></li>
      </ul></li>
    </ul>

    <!-- ── Lua Nav ── -->
    <ul id="navList-lua" style="display:none">
      <li class="open"><a href="#lua-scripting">Lua Scripting</a><ul>
        <li><a href="#lua-attaching">Attaching Scripts</a></li>
        <li><a href="#lua-bindings">How Bindings Work</a></li>
        <li><a href="#lua-globals">Globals &amp; self</a></li>
      </ul></li>
      <li><a href="#callbacks">Callbacks</a><ul>
        <li><a href="#cb-on-start">on_start / on_stop</a></li>
        <li><a href="#cb-on-message">on_message</a></li>
        <li><a href="#cb-on-client-message">on_client_message</a></li>
        <li><a href="#cb-on-connect">on_connect / on_disconnect</a></li>
        <li><a href="#cb-on-send">on_send</a></li>
        <li><a href="#cb-on-tick">on_tick</a></li>
        <li><a href="#cb-on-route">on_route</a></li>
        <li><a href="#cb-on-master-auth">on_master_auth</a></li>
      </ul></li>
      <li><a href="#server-api">Server API</a><ul>
        <li><a href="#srv-broadcast">broadcast / send</a></li>
        <li><a href="#srv-connections">connections</a></li>
        <li><a href="#srv-master">Master Mode</a></li>
      </ul></li>
      <li><a href="#client-api">Client API</a><ul>
        <li><a href="#cli-send">send</a></li>
        <li><a href="#cli-connections">connections</a></li>
      </ul></li>
      <li><a href="#cache-api">Cache API</a><ul>
        <li><a href="#cache-strings">Strings</a></li>
        <li><a href="#cache-lists">Lists</a></li>
        <li><a href="#cache-sets">Sets</a></li>
        <li><a href="#cache-hashes">Hashes</a></li>
        <li><a href="#cache-ttl">TTL / Expiry</a></li>
        <li><a href="#cache-pubsub">Pub/Sub</a></li>
      </ul></li>
      <li><a href="#proxy-api">Proxy API</a><ul>
        <li><a href="#proxy-connections">connections</a></li>
        <li><a href="#proxy-routing">Lua Routing</a></li>
      </ul></li>
      <li><a href="#runtime-mgmt">Runtime Management</a><ul>
        <li><a href="#mgmt-create">create / start / stop</a></li>
        <li><a href="#mgmt-send">send / list / get</a></li>
        <li><a href="#mgmt-ownership">Ownership</a></li>
      </ul></li>
      <li><a href="#client-routing">Client Routing</a><ul>
        <li><a href="#route-route">route / unroute</a></li>
        <li><a href="#route-owner-send">owner_send / owner_broadcast</a></li>
      </ul></li>
      <li><a href="#cluster-api">Cluster API</a><ul>
        <li><a href="#cluster-daemons">daemons / runtimes</a></li>
        <li><a href="#cluster-group">group / stats</a></li>
      </ul></li>
    </ul>

    <!-- ── Addons Nav ── -->
    <ul id="navList-addons" style="display:none">
      <li class="open"><a href="#addons-overview">Overview</a></li>
      <li><a href="#addons-auth">Auth Middleware</a><ul>
        <li><a href="#addons-auth-ip">IP Allowlist</a></li>
        <li><a href="#addons-auth-token">Token Auth</a></li>
      </ul></li>
      <li><a href="#addons-rate-limit">Rate Limiting</a></li>
      <li><a href="#addons-clients-multicast">Client Enumeration &amp; Multicast</a></li>
      <li><a href="#addons-metadata">Per-Connection Metadata</a></li>
      <li><a href="#addons-timers">Timers</a></li>
      <li><a href="#addons-proxy-hooks">Proxy Data Hooks</a></li>
      <li><a href="#addons-pubsub">Cross-Runtime Pub/Sub</a></li>
      <li><a href="#addons-cluster-events">Cluster Events</a><ul>
        <li><a href="#addons-cluster-join">on_cluster_join / leave</a></li>
        <li><a href="#addons-group-change">on_group_change</a></li>
      </ul></li>
      <li><a href="#addons-http">HTTP Calls</a><ul>
        <li><a href="#addons-http-api">socketley.http API</a></li>
        <li><a href="#addons-http-https">HTTPS</a></li>
      </ul></li>
      <li><a href="#addons-service-discovery">Service Discovery</a></li>
      <li><a href="#addons-metrics">Metrics Push</a></li>
      <li><a href="#db-backend">DB Backend Hooks</a><ul>
        <li><a href="#cb-on-miss">on_miss</a></li>
        <li><a href="#cb-on-write">on_write</a></li>
        <li><a href="#cb-on-delete-expire">on_delete / on_expire</a></li>
        <li><a href="#db-sqlite">SQLite</a></li>
        <li><a href="#db-mysql">MySQL / MariaDB</a></li>
        <li><a href="#db-postgres">PostgreSQL</a></li>
        <li><a href="#db-patterns">Write-Behind vs Write-Through</a></li>
      </ul></li>
      <li><a href="#addons-mq">Message Queue Bridge</a></li>
      <li><a href="#addons-redis-session">Distributed State</a></li>
      <li><a href="#addons-session-ids">Session IDs</a></li>
    </ul>

    <!-- ── Examples Nav ── -->
    <ul id="navList-examples" style="display:none">
      <li class="open"><a href="#ex-getting-started">Getting Started</a><ul>
        <li><a href="#ex-hello-server">Hello Server</a></li>
        <li><a href="#ex-hello-client">Hello Client</a></li>
        <li><a href="#ex-combined">Combined Setup</a></li>
        <li><a href="#ex-bash-output">Bash Output</a></li>
      </ul></li>
      <li><a href="#ex-server-client">Server &amp; Client</a><ul>
        <li><a href="#ex-echo-server">Echo Server</a></li>
        <li><a href="#ex-broadcast">Broadcast</a></li>
        <li><a href="#ex-bidirectional">Bidirectional</a></li>
        <li><a href="#ex-modes">Message Modes</a></li>
      </ul></li>
      <li><a href="#ex-proxy-cat">Proxy</a><ul>
        <li><a href="#ex-http-proxy">HTTP Proxy</a></li>
        <li><a href="#ex-load-balancer">Load Balancer</a></li>
        <li><a href="#ex-group-discovery">Group Discovery</a></li>
        <li><a href="#ex-tcp-proxy">TCP Proxy</a></li>
        <li><a href="#ex-name-backend">Named Backends</a></li>
        <li><a href="#ex-lua-routing">Lua Routing</a></li>
      </ul></li>
      <li><a href="#ex-cache-cat">Cache</a><ul>
        <li><a href="#ex-basic-cache">Basic Cache</a></li>
        <li><a href="#ex-persistent-cache">Persistent</a></li>
        <li><a href="#ex-cache-modes">Access Modes</a></li>
        <li><a href="#ex-resp-mode">RESP Mode</a></li>
        <li><a href="#ex-datastructures">Data Structures</a></li>
        <li><a href="#ex-pubsub">Pub/Sub</a></li>
        <li><a href="#ex-replication">Replication</a></li>
        <li><a href="#ex-db-backend">DB Backend</a></li>
        <li><a href="#ex-cache-integration">Cache + Server</a></li>
      </ul></li>
      <li><a href="#ex-server-addons">Server Addons</a><ul>
        <li><a href="#ex-ip-allowlist">IP Allowlist</a></li>
        <li><a href="#ex-token-auth">Token Auth</a></li>
        <li><a href="#ex-rate-limit">Rate Limiting</a></li>
        <li><a href="#ex-session-ids">Session IDs</a></li>
        <li><a href="#ex-redis-session">Redis Sessions</a></li>
        <li><a href="#ex-service-discovery">Service Discovery</a></li>
        <li><a href="#ex-ws-session">WebSocket Sessions</a></li>
        <li><a href="#ex-http-dashboard">HTTP Dashboard</a></li>
      </ul></li>
      <li><a href="#ex-lua-config">Lua Configuration</a><ul>
        <li><a href="#ex-simple-config">Simple Config</a></li>
        <li><a href="#ex-callbacks">Callbacks</a></li>
        <li><a href="#ex-conn-callbacks">Connection Callbacks</a></li>
        <li><a href="#ex-custom-routing">Custom Routing</a></li>
        <li><a href="#ex-full-setup">Full Setup</a></li>
      </ul></li>
      <li><a href="#ex-advanced">Advanced</a><ul>
        <li><a href="#ex-microservices">Microservices</a></li>
        <li><a href="#ex-high-availability">High Availability</a></li>
        <li><a href="#ex-logging-pipeline">Logging Pipeline</a></li>
        <li><a href="#ex-dev-env">Development Env</a></li>
        <li><a href="#ex-game-routing">Game Routing</a></li>
        <li><a href="#ex-udp-echo">UDP Echo</a></li>
      </ul></li>
    </ul>

    <!-- ── Socketley SDK Nav ── -->
    <ul id="navList-socketley-sdk" style="display:none">
      <li class="open"><a href="#sdk-intro">Introduction</a><ul>
        <li><a href="#sdk-three-tiers">Three Tiers</a></li>
        <li><a href="#sdk-install">Installation</a></li>
        <li><a href="#sdk-quickstart">Quick Start</a></li>
      </ul></li>
      <li><a href="#sdk-t1">Tier 1: Daemon Control</a><ul>
        <li><a href="#sdk-t1-result">Result Type</a></li>
        <li><a href="#sdk-t1-runtime">Runtime Management</a></li>
        <li><a href="#sdk-t1-send">Send Behavior</a></li>
        <li><a href="#sdk-t1-cache">Cache Operations</a></li>
        <li><a href="#sdk-t1-action">Action Commands</a></li>
        <li><a href="#sdk-t1-raw">Raw Command</a></li>
        <li><a href="#sdk-t1-socket">Socket Path</a></li>
      </ul></li>
      <li><a href="#sdk-t2">Tier 2: Embed Engine</a><ul>
        <li><a href="#sdk-t2-build">Build &amp; Link</a></li>
        <li><a href="#sdk-t2-eventloop">event_loop</a></li>
        <li><a href="#sdk-t2-manager">runtime_manager</a></li>
        <li><a href="#sdk-t2-base">runtime_instance (Base)</a></li>
        <li><a href="#sdk-t2-callbacks">C++ Callbacks</a></li>
        <li><a href="#sdk-t2-server">server_instance</a></li>
        <li><a href="#sdk-t2-cache">cache_instance</a><ul>
          <li><a href="#sdk-t2-cache-strings">Strings</a></li>
          <li><a href="#sdk-t2-cache-lists">Lists</a></li>
          <li><a href="#sdk-t2-cache-sets">Sets</a></li>
          <li><a href="#sdk-t2-cache-hashes">Hashes</a></li>
          <li><a href="#sdk-t2-cache-ttl">TTL</a></li>
          <li><a href="#sdk-t2-cache-pubsub">Pub/Sub</a></li>
          <li><a href="#sdk-t2-cache-mgmt">Management</a></li>
          <li><a href="#sdk-t2-cache-textproto">Text Protocol</a></li>
        </ul></li>
        <li><a href="#sdk-t2-proxy">proxy_instance</a></li>
        <li><a href="#sdk-t2-client">client_instance</a></li>
        <li><a href="#sdk-t2-enums">Enums &amp; Constants</a></li>
      </ul></li>
      <li><a href="#sdk-t3">Tier 3: Daemon Attach</a><ul>
        <li><a href="#sdk-t3-api">API</a></li>
        <li><a href="#sdk-t3-lifecycle">Lifecycle</a></li>
      </ul></li>
      <li><a href="#sdk-patterns">Patterns &amp; Best Practices</a><ul>
        <li><a href="#sdk-pat-mixed">Mixed (Tier 2 + 3)</a></li>
        <li><a href="#sdk-pat-signals">Signal Handling</a></li>
        <li><a href="#sdk-pat-lua">Lua Integration</a></li>
        <li><a href="#sdk-pat-choosing">Choosing a Tier</a></li>
      </ul></li>
    </ul>

    <!-- ── Examples SDK Nav ── -->
    <ul id="navList-examples-sdk" style="display:none">
      <li class="open"><a href="#exsdk-tier1">Tier 1: Daemon Control</a><ul>
        <li><a href="#exsdk-control-basics">Control Basics</a></li>
        <li><a href="#exsdk-cache-ops">Cache Operations</a></li>
        <li><a href="#exsdk-fleet">Fleet Manager</a></li>
      </ul></li>
      <li><a href="#exsdk-daemon-workflows">Daemon Workflows</a><ul>
        <li><a href="#exsdk-dw-lua-echo">Lua Echo Server</a></li>
        <li><a href="#exsdk-dw-cache-full">Full Cache Operations</a></li>
        <li><a href="#exsdk-dw-server-cache">Server + Cache</a></li>
        <li><a href="#exsdk-dw-monitoring">Monitoring Dashboard</a></li>
        <li><a href="#exsdk-dw-pubsub">Pub/Sub Callbacks</a></li>
      </ul></li>
      <li><a href="#exsdk-tier2">Tier 2: Embedded Engine</a><ul>
        <li><a href="#exsdk-echo">Echo Server</a></li>
        <li><a href="#exsdk-multi">Multi-Runtime</a></li>
        <li><a href="#exsdk-chat">Chat Server (Lua)</a></li>
        <li><a href="#exsdk-proxy-lb">Proxy Load Balancer</a></li>
      </ul></li>
      <li><a href="#exsdk-tier3">Tier 3: Daemon Attach</a><ul>
        <li><a href="#exsdk-attach">Attached Service</a></li>
      </ul></li>
      <li><a href="#exsdk-mixed">Mixed: Engine + Attach</a><ul>
        <li><a href="#exsdk-fullstack">Full Stack</a></li>
      </ul></li>
    </ul>
  </nav>
</aside>

<!-- ═══════════════════════════════════════════
     SOCKETLEY TAB CONTENT
═══════════════════════════════════════════ -->
<main id="content-socketley" class="content">

<!-- ── GETTING STARTED ── -->
<h2 id="getting-started">Getting Started</h2>
<p>Socketley is a high-performance Linux daemon and CLI that manages network runtimes (servers, clients, proxies, Redis-compatible caches) in a Docker-like style &mdash; with clustering, TLS, WebSocket, Lua scripting, and io_uring async I/O. Wire them together into anything from a chat app to a microservices backend.</p>

<div class="info-box"><strong>What you can build:</strong>
<ul style="margin:6px 0 0;padding-left:20px">
<li><strong>Real-time web apps</strong> &mdash; <code>--http</code> serves your HTML, auto-injects a WebSocket connection, Lua handles messages</li>
<li><strong>Redis-compatible caches</strong> &mdash; drop-in replacement, 2.5&ndash;3.9x faster than Redis with pipelining</li>
<li><strong>Load-balanced microservices</strong> &mdash; proxy runtimes target backends by name, not hardcoded ports</li>
<li><strong>Cache-backed APIs</strong> &mdash; clients send <code>cache set key val</code> through your server, no separate connection needed</li>
<li><strong>Game servers with lobby routing</strong> &mdash; create sub-servers on the fly, route players between them with Lua</li>
</ul></div>

<div class="info-box"><strong>Source code:</strong> <a href="https://github.com/HiImSmiley/Socketley" target="_blank" rel="noopener">github.com/HiImSmiley/Socketley</a></div>

<h3 id="gs-install">Installation</h3>
<h4>From source (recommended)</h4>
<pre><code>git clone https://github.com/HiImSmiley/Socketley.git
<span class="kw">cd</span> socketley
./bin/premake5 gmake2
<span class="kw">cd</span> make && make config=release_x64 -j$(nproc)</code></pre>
<p>Binary output: <code>bin/Release/socketley</code></p>

<h4>System-wide install</h4>
<pre><code>sudo bash packaging/install.sh
<span class="cm"># Or build a .deb:</span>
bash packaging/build-deb.sh && sudo dpkg -i socketley_*.deb</code></pre>

<h3 id="gs-first-server">Your First Server</h3>
<p>Let's build a working server in under a minute. Each step shows what's happening behind the scenes.</p>

<p><strong>1. The daemon is already running.</strong> When installed via package (<code>dpkg -i</code> or <code>install.sh</code>), the daemon runs as a systemd service automatically. No manual startup needed.</p>

<p><strong>2. Create a server called "hello" on port 9000</strong> &mdash; the <code>-s</code> flag starts it immediately:</p>
<pre><code>socketley create server hello -p 9000 -s</code></pre>
<p>Your server is now listening. Any TCP client or WebSocket client can connect to port 9000.</p>

<p><strong>3. Connect with netcat</strong> in another terminal:</p>
<pre><code>nc localhost 9000</code></pre>
<p>You're connected. Anything broadcast to "hello" will appear here.</p>

<p><strong>4. Broadcast a message</strong> from a third terminal:</p>
<pre><code>socketley send hello <span class="st">"Hi everyone!"</span></code></pre>
<p>The netcat client receives "Hi everyone!" &mdash; <code>send</code> broadcasts to all connected clients.</p>

<p><strong>5. Add Lua behavior.</strong> Create a file called <code>echo.lua</code>:</p>
<pre><code><span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    self.broadcast(<span class="st">"["</span> .. client_id .. <span class="st">"] "</span> .. msg)
<span class="kw">end</span></code></pre>
<p>Now create a server that uses it:</p>
<pre><code>socketley create server chat -p 9001 --lua echo.lua -s</code></pre>
<p>Every message from a client gets broadcast to all others, prefixed with the sender's ID.</p>

<p><strong>6. Check what's running:</strong></p>
<pre><code>socketley ls</code></pre>
<pre><code>ID        NAME    TYPE    PORT  CONN  OWNED BY  STATUS       CREATED
a1b2c3    hello   server  9000  1     -         Up 2 min     3 min ago
d4e5f6    chat    server  9001  0     -         Up 30 sec    30 sec ago</code></pre>

<p><strong>7. Clean up</strong> when you're done:</p>
<pre><code>socketley remove hello chat</code></pre>

<h3 id="gs-next">Where to Go Next</h3>
<ul>
<li><strong>Want Lua scripting?</strong> &rarr; <a href="#concept-lua">Writing Lua Scripts</a></li>
<li><strong>Building a web app?</strong> &rarr; <a href="#concept-http">HTTP Serving</a> (serve HTML + auto WebSocket)</li>
<li><strong>Need a cache?</strong> &rarr; <a href="#concept-cache">Cache Attachment</a></li>
<li><strong>Load balancing?</strong> &rarr; <a href="#concept-names">Runtime Name Networking</a> and <a href="#concept-groups">Group Discovery</a></li>
<li><strong>See all examples</strong> &rarr; <a href="#ex-getting-started">Examples tab</a></li>
<li><strong>Full Lua API reference</strong> &rarr; <a href="#lua-scripting">Lua tab</a></li>
</ul>
<details style="margin-top:12px"><summary><strong>Building from source (advanced)</strong></summary>
<pre><code>./bin/premake5 gmake2
<span class="kw">cd</span> make
make config=release_x64 -j$(nproc)   <span class="cm"># Release</span>
make config=debug_x64 -j$(nproc)     <span class="cm"># Debug</span></code></pre>
<p>Requirements: Linux with io_uring (kernel 5.11+), GCC/Clang with C++20. All dependencies vendored.</p>
</details>

<!-- ── KEY CONCEPTS ── -->
<h2 id="concepts">Key Concepts</h2>
<p>Socketley's power comes from how its pieces connect. Each concept below unlocks a new capability.</p>

<h3 id="concept-runtimes">Runtimes</h3>
<p>A <strong>runtime</strong> is a long-living named network process &mdash; a server, client, proxy, or cache. You create it once, then start and stop it as needed. Think of it like a Docker container for a network socket.</p>

<p><strong>Lifecycle:</strong> <code>create</code> &rarr; <code>start</code> &rarr; <code>stop</code> &rarr; <code>start</code> again &rarr; <code>remove</code>. Runtimes survive daemon restarts (state is persisted to disk), so you can reboot your machine and everything comes back up.</p>

<pre><code><span class="cm"># Create but don't start yet</span>
socketley create server api -p 9000

<span class="cm"># Start when ready</span>
socketley start api

<span class="cm"># Stop (keeps config, can restart later)</span>
socketley stop api

<span class="cm"># Remove permanently</span>
socketley remove api</code></pre>

<p><strong>Glob patterns</strong> let you manage many runtimes at once:</p>
<pre><code>socketley stop <span class="st">'api*'</span>          <span class="cm"># Stop all runtimes starting with "api"</span>
socketley start <span class="st">'*'</span>            <span class="cm"># Start everything</span>
socketley remove <span class="st">'test-?'</span>      <span class="cm"># Remove test-1, test-2, etc.</span></code></pre>

<p><strong>Interactive mode</strong> (<code>-i</code>) pipes stdin/stdout through the runtime &mdash; you type messages and see responses in real time:</p>
<pre><code>socketley start api -i</code></pre>

<h3 id="concept-websocket">WebSocket Auto-Detection</h3>
<p>Every Socketley server automatically detects WebSocket connections. <strong>No flag needed.</strong> When a client sends an HTTP upgrade request, the server completes the handshake and switches to WebSocket framing. Regular TCP clients continue working on the same port.</p>

<pre><code><span class="cm"># This server accepts both TCP and WebSocket connections on port 9000</span>
socketley create server app -p 9000 -s

<span class="cm"># TCP client</span>
nc localhost 9000

<span class="cm"># WebSocket client (browser JavaScript)</span>
<span class="cm"># const ws = new WebSocket("ws://localhost:9000")</span></code></pre>

<p>The <code>on_websocket(client_id, headers)</code> Lua callback fires after a WebSocket handshake completes, giving you access to the upgrade headers for session tracking:</p>
<pre><code><span class="kw">function</span> <span class="fn">on_websocket</span>(client_id, headers)
    socketley.log(<span class="st">"WS connected: "</span> .. (headers.origin <span class="kw">or</span> <span class="st">"unknown"</span>))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="cm">-- Works for both TCP and WebSocket clients</span>
    self.broadcast(msg)
<span class="kw">end</span></code></pre>

<p>You can also call <code>self.ws_headers(client_id)</code> at any time to retrieve the stored headers (<code>cookie</code>, <code>origin</code>, <code>sec-websocket-protocol</code>, <code>authorization</code>).</p>

<div class="info-box"><strong>How detection works:</strong> The server inspects the first 4 bytes of each new connection. If they're <code>GET </code>, it parses the HTTP upgrade headers. Otherwise it treats the connection as raw TCP. This happens per-connection, so mixed traffic just works.</div>

<h3 id="concept-cache">Cache Attachment</h3>
<p>The <code>--cache &lt;name&gt;</code> flag on a server lets clients access a cache <em>through</em> the server. Clients send <code>cache &lt;command&gt;</code> messages, and the server forwards them to the linked cache runtime. The response goes back only to the sender &mdash; never broadcast.</p>

<pre><code><span class="cm"># 1. Create a cache</span>
socketley create cache store -p 9001 -s

<span class="cm"># 2. Create a server linked to that cache</span>
socketley create server api -p 9000 --cache store -s

<span class="cm"># 3. A client connected to the server can now run cache commands</span>
nc localhost 9000
cache set user:1 Alice       <span class="cm"># → ok</span>
cache get user:1             <span class="cm"># → Alice</span>
Hello everyone!              <span class="cm"># → broadcast normally (no "cache" prefix)</span></code></pre>

<p>This means your clients don't need a separate connection to the cache. Regular messages still work as normal &mdash; only messages starting with <code>cache </code> are intercepted.</p>

<p>In Lua orchestration files, use the <code>cache_name</code> key:</p>
<pre><code>runtimes = {
    { type = <span class="st">"cache"</span>,  name = <span class="st">"store"</span>, port = <span class="nb">9001</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"api"</span>,   port = <span class="nb">9000</span>, cache_name = <span class="st">"store"</span>, start = <span class="kw">true</span> },
}</code></pre>

<h3 id="concept-http">HTTP Serving</h3>
<p>The <code>--http &lt;directory&gt;</code> flag turns a server into a static file server with automatic WebSocket integration. This is how you build real-time web UIs on Socketley.</p>

<pre><code><span class="cm"># Serve files from ./public/ on port 8080</span>
socketley create server web -p 8080 --http ./public -s</code></pre>

<p><strong>What happens:</strong></p>
<ul>
<li>HTTP GET requests serve files from the directory (HTML, CSS, JS, images, fonts, WASM, etc.)</li>
<li><strong>HTML files automatically get a WebSocket connection script injected</strong> before <code>&lt;/head&gt;</code>:
<pre><code>&lt;script&gt;<span class="kw">const</span> socketley=<span class="kw">new</span> WebSocket(<span class="st">"ws://"+location.host</span>)&lt;/script&gt;</code></pre></li>
<li>Your page loads with a live WebSocket connection to the same server &mdash; zero configuration</li>
<li>WebSocket messages from the browser arrive in your Lua callbacks just like any other client</li>
</ul>

<p><strong>Full example:</strong> Create <code>public/index.html</code>:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;&lt;head&gt;&lt;title&gt;Live&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;div id=<span class="st">"log"</span>&gt;&lt;/div&gt;
  &lt;script&gt;
    socketley.onmessage = e =&gt; {
      document.getElementById(<span class="st">"log"</span>).innerHTML += e.data + <span class="st">"&lt;br&gt;"</span>
    }
  &lt;/script&gt;
&lt;/body&gt;&lt;/html&gt;</code></pre>
<p>Then serve it:</p>
<pre><code>socketley create server web -p 8080 --http ./public --lua handler.lua -s</code></pre>
<p>Open <code>http://localhost:8080</code> in a browser &mdash; the page auto-connects via WebSocket. Your <code>handler.lua</code> receives messages from the browser through <code>on_client_message</code>.</p>

<p><strong>Production mode:</strong> Add <code>--http-cache</code> to pre-load all files into memory at startup instead of reading from disk on each request. The cache is rebuilt on <code>reload-lua</code>.</p>
<pre><code>socketley create server web -p 8080 --http ./dist --http-cache -s</code></pre>

<div class="info-box">Supported file types: <code>.html</code>, <code>.css</code>, <code>.js</code>, <code>.json</code>, <code>.png</code>, <code>.jpg</code>, <code>.gif</code>, <code>.svg</code>, <code>.ico</code>, <code>.woff2</code>, <code>.woff</code>, <code>.ttf</code>, <code>.wasm</code>, <code>.webp</code>, <code>.mp4</code>, <code>.webm</code>, <code>.mp3</code>, <code>.ogg</code>, <code>.pdf</code>, <code>.xml</code>, <code>.txt</code>, and more. Unknown extensions serve as <code>application/octet-stream</code>.</div>

<h3 id="concept-names">Runtime Name Networking</h3>
<p>Runtime names are first-class network identifiers. Instead of hardcoding IP addresses and ports, you can reference runtimes by name &mdash; Socketley resolves them at startup.</p>

<p><strong>Proxy backends by name:</strong></p>
<pre><code><span class="cm"># Create three servers (ports assigned automatically or manually)</span>
socketley create server api1 -p 9001 -s
socketley create server api2 -p 9002 -s
socketley create server api3 -p 9003 -s

<span class="cm"># Proxy references them by name &mdash; no hardcoded ports</span>
socketley create proxy gateway -p 8080 --backend api1,api2,api3 -s</code></pre>
<p>If you change a server's port, the proxy picks up the new address on next reload. No config file edits needed.</p>

<p><strong>Client targets by name:</strong> Clients can also target runtimes by name, resolved at connect time.</p>

<p><strong>Why this matters:</strong> You can build entire architectures without a single hardcoded address. Names are stable identifiers; ports are implementation details.</p>

<h3 id="concept-groups">Group-Based Discovery</h3>
<p>Groups take runtime name networking one step further: tag runtimes with <code>-g &lt;name&gt;</code>, then use <code>@groupname</code> as a proxy backend. The proxy discovers all running members of that group <strong>at connection time</strong> &mdash; no restarts, no config changes.</p>

<pre><code><span class="cm"># Tag servers with a group</span>
socketley create server api1 -p 9001 -g api -s
socketley create server api2 -p 9002 -g api -s

<span class="cm"># Proxy targets the group &mdash; discovers members dynamically</span>
socketley create proxy gw -p 8080 --backend @api -s

<span class="cm"># Add a new member while the proxy is running &mdash; no restart needed</span>
socketley create server api3 -p 9003 -g api -s
<span class="cm"># Next connection is automatically routed to api1, api2, or api3</span></code></pre>

<p><strong>How it works:</strong> When a new connection arrives at the proxy, <code>@api</code> is expanded into the list of all <em>running</em> runtimes tagged with group <code>api</code>. The configured strategy (round-robin, random, lua) then picks from that pool. Stopped members are excluded automatically.</p>

<p><strong>Mix and match:</strong> You can combine group backends with static addresses and runtime names in the same proxy:</p>
<pre><code>socketley create proxy gw -p 8080 --backend @api,10.0.0.5:9000,legacy-server -s</code></pre>

<p><strong>Use cases:</strong> Auto-scaling (Lua scripts creating new servers join the group automatically), blue-green deploys (swap group tags with <code>socketley edit</code>), microservice pools, game lobby routing.</p>

<div class="info-box"><strong>Naming:</strong> The <code>@</code> prefix distinguishes group references from runtime names and IP:port addresses. Group names can be any non-empty string.</div>

<h3 id="concept-lua">Writing Lua Scripts</h3>
<p>Lua scripts give you full control over how your runtimes behave. There are two ways to use them:</p>

<p><strong>1. Per-runtime scripts</strong> &mdash; attach behavior to a single runtime:</p>
<pre><code>socketley create server myapp -p 9000 --lua handler.lua -s</code></pre>

<p><strong>2. Orchestration scripts</strong> &mdash; define and configure multiple runtimes in one file:</p>
<pre><code>socketley --lua setup.lua</code></pre>

<p><strong>The callback model:</strong> You define functions, Socketley calls them at the right time. Here's a minimal script:</p>
<pre><code><span class="kw">function</span> <span class="fn">on_start</span>()
    socketley.log(<span class="st">"Server started!"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    self.send(client_id, <span class="st">"You said: "</span> .. msg)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)
    self.send(client_id, <span class="st">"Welcome!"</span>)
<span class="kw">end</span></code></pre>

<p><strong>Available callbacks</strong> (see the <a href="#lua-scripting">Lua tab</a> for the full API reference):</p>
<table><thead><tr><th>Callback</th><th>Fires when...</th></tr></thead><tbody>
<tr><td>on_start / on_stop</td><td>Runtime starts or stops</td></tr>
<tr><td>on_message(msg)</td><td>Any message received (server broadcast)</td></tr>
<tr><td>on_client_message(id, msg)</td><td>A specific client sends a message</td></tr>
<tr><td>on_connect / on_disconnect(id)</td><td>Client connects or disconnects</td></tr>
<tr><td>on_websocket(id, headers)</td><td>WebSocket handshake completes</td></tr>
<tr><td>on_auth(id)</td><td>Client TCP accepted, before on_connect (return false to reject)</td></tr>
<tr><td>on_tick()</td><td>Periodic timer fires</td></tr>
<tr><td>on_route(method, path)</td><td>Proxy needs a backend (return index)</td></tr>
<tr><td>on_master_auth(id, pw)</td><td>Client attempts master authentication</td></tr>
</tbody></table>

<p><strong>Error handling:</strong> Lua errors are logged but the runtime keeps running. The one exception is <code>on_auth</code> &mdash; if the script errors, the client is rejected (fail-closed).</p>

<p><strong>Hot reload:</strong> Change your Lua script, then reload without restarting the runtime:</p>
<pre><code>socketley reload-lua myapp</code></pre>

<p><strong>Debugging:</strong> Use <code>socketley.log("message")</code> in your scripts. Combine with the <code>--log &lt;file&gt;</code> flag to write output to a file.</p>

<div class="info-box"><strong>Libraries:</strong> You can <code>require()</code> any Lua module. Install libraries with <code>luarocks install &lt;name&gt;</code> for database drivers, JSON parsers, etc. The <code>io</code> library is enabled for shell commands via <code>io.popen()</code>.</div>

<!-- ── CLI COMMANDS ── -->
<h2 id="cli-commands">CLI Commands</h2>
<p>All commands talk to the daemon via Unix socket (<code>/tmp/socketley.sock</code>). The daemon is auto-started if not running. Most name arguments accept glob patterns: <code>'*'</code>, <code>?</code>, <code>[abc]</code>.</p>

<div class="info-box">Quote glob patterns to prevent shell expansion: <code>socketley start '*'</code> not <code>socketley start *</code>.</div>

<div class="cli-card" id="cmd-create">
  <div class="cli-name">socketley create &lt;type&gt; &lt;name&gt; [flags]</div>
  <div class="cli-desc">Define a new runtime with its configuration. Types: <code>server</code>, <code>client</code>, <code>proxy</code>, <code>cache</code>. Add <code>-s</code> to start immediately. Config is persisted &mdash; you only create once.</div>
</div>
<pre><code>socketley create server myapp -p 9000 -s
socketley create cache store -p 9001 --persistent /tmp/data.bin --maxmemory 256M -s
socketley create client bot -t 127.0.0.1:9000 --reconnect -s
socketley create server api1 -p 9001 -g api -s
socketley create proxy gw -p 8080 --backend @api -s</code></pre>

<div class="cli-card" id="cmd-start-stop">
  <div class="cli-name">socketley start &lt;name|pattern&gt;... [-i]</div>
  <div class="cli-desc">Start one or more runtimes. Use <code>-i</code> for interactive mode &mdash; stdin/stdout are piped through the runtime so you can type messages and see responses live. Ctrl+C to detach. Also attaches to already-running runtimes.</div>
</div>
<div class="cli-card">
  <div class="cli-name">socketley stop &lt;name|pattern&gt;...</div>
  <div class="cli-desc">Gracefully stop running runtimes. Config is preserved &mdash; you can <code>start</code> again later. Use <code>'*'</code> (quoted) to stop all.</div>
</div>
<div class="cli-card">
  <div class="cli-name">socketley remove &lt;name|pattern&gt;...</div>
  <div class="cli-desc">Stop and permanently delete runtimes. This removes all persisted config.</div>
</div>

<div class="cli-card" id="cmd-send">
  <div class="cli-name">socketley send &lt;name&gt; [message]</div>
  <div class="cli-desc">Broadcast a message to all connected clients of a runtime. Supports stdin piping: <code>echo "hi" | socketley send myapp</code></div>
</div>

<div class="cli-card" id="cmd-stats">
  <div class="cli-name">socketley stats &lt;name|pattern&gt;...</div>
  <div class="cli-desc">Show live statistics: connection count, total messages, bytes in/out, uptime.</div>
</div>

<div class="cli-card" id="cmd-reload">
  <div class="cli-name">socketley reload &lt;name|pattern&gt;...</div>
  <div class="cli-desc">Full restart (stop + start). Re-applies all config including port changes.</div>
</div>
<div class="cli-card">
  <div class="cli-name">socketley reload-lua &lt;name|pattern&gt;...</div>
  <div class="cli-desc">Hot-reload the Lua script without restarting. Connections stay open, state resets. Also rebuilds the HTTP file cache if <code>--http-cache</code> is set.</div>
</div>

<div class="cli-card" id="cmd-show-edit">
  <div class="cli-name">socketley show &lt;name|pattern&gt;...</div>
  <div class="cli-desc">Print runtime config as pretty JSON. Useful for verifying flags before starting.</div>
</div>
<div class="cli-card">
  <div class="cli-name">socketley edit &lt;name&gt; [flags]</div>
  <div class="cli-desc">Modify a runtime's config. With flags: apply directly (<code>socketley edit myapp -p 9001</code>). Without flags: opens <code>$EDITOR</code> for interactive editing. Add <code>-r</code> to auto-reload-lua after saving.</div>
</div>

<div class="cli-card" id="cmd-ls-ps">
  <div class="cli-name">socketley ls / ps / owner &lt;name&gt;</div>
  <div class="cli-desc"><code>ls</code> = list all runtimes (running and stopped), <code>ps</code> = running only, <code>owner</code> = show parent/child relationships for Lua-created runtimes.</div>
</div>
<pre><code>ID        NAME            TYPE    PORT    CONN  OWNED BY    STATUS              CREATED
a1b2c3    api-server      server  9000    3     -           Up 2 hours          3 hours ago
d4e5f6    my-client       client  -       1     -           Up 45 minutes       1 hour ago</code></pre>

<div class="cli-card" id="cmd-daemon">
  <div class="cli-name">socketley daemon [flags]</div>
  <div class="cli-desc">Start the background daemon. When installed via package, the daemon runs as a systemd service automatically &mdash; you don't need this command. Use it explicitly for cluster mode, custom logging, or when running from the build directory (development mode).</div>
</div>
<pre><code><span class="cm"># Installed: daemon is managed by systemd (no manual start needed)</span>
sudo systemctl start socketley

<span class="cm"># Development mode (running from build directory)</span>
./bin/Release/socketley daemon &amp;

<span class="cm"># Configure cluster mode on running daemons</span>
socketley daemon --name api1 --cluster /shared/cluster
socketley daemon --name api2 --cluster /shared/cluster</code></pre>

<div class="cli-card" id="cmd-cluster">
  <div class="cli-name">socketley cluster &lt;subcommand&gt;</div>
  <div class="cli-desc">Inspect the cluster. Requires a running daemon with cluster mode enabled (<code>daemon --name</code> + <code>daemon --cluster</code>). The cluster directory is read from the daemon automatically. Subcommands:</div>
</div>
<table><thead><tr><th>Subcommand</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ls</code></td><td>List all daemons with runtime counts and heartbeat status</td></tr>
<tr><td><code>ps</code></td><td>List all runtimes across every daemon in the cluster</td></tr>
<tr><td><code>group &lt;name&gt;</code></td><td>Show all members of a specific group</td></tr>
<tr><td><code>show &lt;daemon&gt;</code></td><td>Print a daemon's raw cluster JSON file</td></tr>
<tr><td><code>stats</code></td><td>Aggregate summary: daemon counts, runtime totals, group membership</td></tr>
<tr><td><code>watch</code></td><td>Live-refresh the cluster view every 2&nbsp;seconds (Ctrl+C to stop)</td></tr>
</tbody></table>
<pre><code>socketley cluster ls
socketley cluster ps
socketley cluster group api
socketley cluster stats
socketley cluster watch</code></pre>

<!-- ── CLI FLAGS ── -->
<h2 id="cli-flags">CLI Flags</h2>

<h3 id="flags-daemon">Daemon Flags</h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td>--name &lt;name&gt; / -n</td><td>Name this daemon instance. Required for cluster mode</td></tr>
<tr><td>--cluster &lt;dir&gt;</td><td>Enable cluster mode. Publishes runtime state every 2&nbsp;seconds and scans for peers. Host address is set automatically via <code>gethostname()</code></td></tr>
<tr><td>--log-level &lt;level&gt;</td><td>Daemon log verbosity: <code>debug</code>, <code>info</code> (default), <code>warn</code>, <code>error</code></td></tr>
</tbody></table>

<h3 id="flags-common">Common Flags (all types)</h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td>-p &lt;port&gt;</td><td>Port number</td></tr>
<tr><td>-s</td><td>Start immediately after creation</td></tr>
<tr><td>--test</td><td>Dry run &mdash; validate config without starting</td></tr>
<tr><td>--log &lt;file&gt;</td><td>Log state transitions and <code>socketley.log()</code> output to file</td></tr>
<tr><td>-w &lt;file&gt;</td><td>Write every received message to file</td></tr>
<tr><td>--lua &lt;file&gt;</td><td>Attach Lua script to this runtime</td></tr>
<tr><td>-b / -bp / -bt / -bpt</td><td>Bash output: raw / +prefix / +timestamp / both</td></tr>
<tr><td>--max-connections &lt;n&gt;</td><td>Connection limit (alias: <code>--max-conn</code>). 0 = unlimited</td></tr>
<tr><td>--rate-limit &lt;n&gt;</td><td>Messages/sec per connection (token bucket). 0 = unlimited</td></tr>
<tr><td>--drain</td><td>Graceful shutdown &mdash; flush pending writes before closing connections</td></tr>
<tr><td>--tls</td><td>Enable TLS encryption (requires <code>--cert</code> + <code>--key</code>, or <code>--ca</code>)</td></tr>
<tr><td>--cert / --key / --ca</td><td>TLS certificate, key, CA paths (PEM format)</td></tr>
<tr><td>-g / --group &lt;name&gt;</td><td>Assign to a <a href="#concept-groups">group</a> for dynamic proxy backend discovery via <code>@groupname</code></td></tr>
</tbody></table>

<h3 id="flags-server">Server Flags</h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td>--mode &lt;inout|in|out|master&gt;</td><td>Message flow direction. <code>master</code> = one privileged client broadcasts</td></tr>
<tr><td>--udp</td><td>Use UDP instead of TCP</td></tr>
<tr><td>--cache &lt;name&gt;</td><td>Link to a cache runtime &mdash; clients send <code>cache &lt;cmd&gt;</code> for passthrough</td></tr>
<tr><td>--http &lt;dir&gt;</td><td>Serve static files from directory. HTML files get an auto-injected WebSocket connection script</td></tr>
<tr><td>--http-cache</td><td>Pre-load all files into memory at startup (production mode)</td></tr>
<tr><td>--master-pw &lt;password&gt;</td><td>Static password for master mode authentication</td></tr>
<tr><td>--master-forward</td><td>Forward non-master messages to the master client</td></tr>
</tbody></table>
<div class="info-box"><strong>WebSocket:</strong> Auto-detected on every server &mdash; no flag needed. TCP and WebSocket clients coexist on the same port.</div>

<h3 id="flags-client">Client Flags</h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td>-t &lt;host:port&gt;</td><td>Target server address</td></tr>
<tr><td>--mode &lt;inout|in|out&gt;</td><td>Message flow direction</td></tr>
<tr><td>--udp</td><td>Use UDP instead of TCP</td></tr>
<tr><td>--reconnect [max]</td><td>Auto-reconnect with exponential backoff (1s &rarr; 2s &rarr; ... &rarr; 30s cap). 0 = infinite retries</td></tr>
</tbody></table>

<h3 id="flags-cache">Cache Flags</h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td>--persistent &lt;file&gt;</td><td>Persist store to disk on shutdown / <code>flush</code>. Auto-loaded on start</td></tr>
<tr><td>--maxmemory &lt;size&gt;</td><td>Memory limit. Suffixes: <code>K</code>, <code>M</code>, <code>G</code>. 0 = unlimited</td></tr>
<tr><td>--eviction &lt;policy&gt;</td><td><code>noeviction</code> (default), <code>allkeys-lru</code>, <code>allkeys-random</code></td></tr>
<tr><td>--mode &lt;readwrite|readonly|admin&gt;</td><td>Access control. <code>admin</code> enables FLUSH/LOAD commands</td></tr>
<tr><td>--resp</td><td>Force RESP2 protocol (Redis wire protocol). Also auto-detected</td></tr>
<tr><td>--replicate &lt;host:port&gt;</td><td>Connect as read-only follower to a leader cache</td></tr>
</tbody></table>

<h3 id="flags-proxy">Proxy Flags</h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td>--backend &lt;addr&gt;</td><td>Comma-separated backends: IP:port, runtime names, or <code>@group</code> for <a href="#concept-groups">dynamic group discovery</a></td></tr>
<tr><td>--strategy &lt;s&gt;</td><td><code>round-robin</code> (default), <code>random</code>, or <code>lua</code></td></tr>
<tr><td>--protocol &lt;p&gt;</td><td><code>http</code> (default, per-request routing) or <code>tcp</code> (raw byte forwarding, connection-sticky)</td></tr>
</tbody></table>

<!-- ── RUNTIME TYPES ── -->
<h2 id="runtime-types">Runtime Types</h2>

<h3 id="rt-server">Server</h3>
<p>A TCP/UDP listener that accepts connections, broadcasts messages, and runs Lua callbacks on every event. Servers are the most versatile runtime type &mdash; they can serve static files, auto-detect WebSocket upgrades, link to caches, and route clients to sub-servers.</p>

<ul>
<li><strong>WebSocket auto-detection:</strong> Every server detects WebSocket upgrades automatically. TCP and WS clients coexist on the same port with zero configuration.</li>
<li><strong>HTTP static serving:</strong> <code>--http &lt;dir&gt;</code> serves files and auto-injects a WebSocket connection into HTML pages. Add <code>--http-cache</code> for in-memory serving.</li>
<li><strong>Cache attachment:</strong> <code>--cache &lt;name&gt;</code> lets clients run cache commands through the server connection.</li>
<li><strong>Master mode:</strong> <code>--mode master</code> designates one client as the broadcaster. Others listen (or forward via <code>--master-forward</code>).</li>
<li><strong>Client routing:</strong> Lua scripts can <code>self.route(client_id, "sub-server")</code> to move clients between servers on the fly.</li>
<li><strong>UDP mode:</strong> <code>--udp</code> for datagram-based communication.</li>
<li><strong>Full Lua API:</strong> broadcast, send, disconnect, per-connection metadata, client enumeration, multicast, timers, and more.</li>
</ul>

<pre><code><span class="cm"># Real-time web app: static files + WebSocket + Lua</span>
socketley create server web -p 8080 --http ./public --lua app.lua -s

<span class="cm"># API server with cache access</span>
socketley create server api -p 9000 --cache store --lua api.lua -s

<span class="cm"># Master-controlled broadcast</span>
socketley create server ctrl -p 9000 --mode master --master-pw secret -s</code></pre>

<h3 id="rt-client">Client</h3>
<p>A TCP/UDP connector that connects to a server and exchanges messages. Clients are ideal for building bots, bridges between servers, or automated testing.</p>

<ul>
<li><strong>Auto-reconnect:</strong> <code>--reconnect</code> with exponential backoff (1s &rarr; 2s &rarr; ... &rarr; 30s cap). Survives server restarts.</li>
<li><strong>Message modes:</strong> <code>inout</code> (bidirectional), <code>in</code> (receive only), <code>out</code> (send only).</li>
<li><strong>Server routing:</strong> Lua scripts on a parent server can route clients between sub-servers for game lobbies, chat rooms, etc.</li>
<li><strong>UDP mode:</strong> <code>--udp</code> for datagram-based communication.</li>
</ul>

<pre><code><span class="cm"># Auto-reconnecting bot</span>
socketley create client bot -t 127.0.0.1:9000 --reconnect --lua bot.lua -s

<span class="cm"># Receive-only listener</span>
socketley create client listener -t 127.0.0.1:9000 --mode in -b -s</code></pre>

<h3 id="rt-proxy">Proxy</h3>
<p>An HTTP or TCP reverse proxy that distributes traffic across backend servers. Backends can be IP:port addresses, runtime names, or <code>@group</code> references for dynamic discovery.</p>

<ul>
<li><strong>Runtime name backends:</strong> <code>--backend api1,api2</code> instead of <code>--backend 127.0.0.1:9001,127.0.0.1:9002</code>.</li>
<li><strong>Group discovery:</strong> <code>--backend @api</code> dynamically routes to all running members of group <code>api</code>. New members are picked up at connection time &mdash; no proxy restart needed. See <a href="#concept-groups">Group-Based Discovery</a>.</li>
<li><strong>Load balancing:</strong> Round-robin, random, or Lua-based custom routing via <code>on_route(method, path)</code>.</li>
<li><strong>Protocol modes:</strong> <code>http</code> for per-request routing, <code>tcp</code> for raw byte forwarding (connection-sticky).</li>
<li><strong>Data hooks:</strong> <code>on_proxy_request</code> and <code>on_proxy_response</code> Lua callbacks let you inspect/modify/drop traffic in flight.</li>
</ul>

<pre><code><span class="cm"># Dynamic group discovery &mdash; proxy auto-discovers backends</span>
socketley create server api1 -p 9001 -g api -s
socketley create server api2 -p 9002 -g api -s
socketley create proxy gw -p 8080 --backend @api -s

<span class="cm"># Load balancer with runtime name backends</span>
socketley create proxy lb -p 8080 --backend api1,api2,api3 -s

<span class="cm"># Lua-routed HTTP proxy</span>
socketley create proxy gw2 -p 8081 --backend api1,api2 --strategy lua --lua router.lua -s

<span class="cm"># Raw TCP proxy</span>
socketley create proxy tcp-gw -p 8080 --backend 10.0.0.1:9000 --protocol tcp -s</code></pre>

<h3 id="rt-cache">Cache</h3>
<p>A Redis-compatible in-memory store with strings, lists, sets, hashes, TTL, pub/sub, persistence, replication, and LRU eviction. With RESP2 mode, you can use <code>redis-cli</code> and any Redis client library directly &mdash; benchmarks show 2.5&ndash;3.9x faster than Redis with pipelining.</p>

<ul>
<li><strong>Redis compatibility:</strong> <code>--resp</code> enables the RESP2 wire protocol. Also auto-detected.</li>
<li><strong>Persistence:</strong> <code>--persistent &lt;file&gt;</code> saves to disk on stop, auto-loads on start.</li>
<li><strong>Replication:</strong> <code>--replicate &lt;host:port&gt;</code> for leader-follower setups. Follower syncs full dump then receives ongoing commands.</li>
<li><strong>Eviction:</strong> <code>allkeys-lru</code> or <code>allkeys-random</code> when <code>--maxmemory</code> is reached.</li>
<li><strong>Pub/Sub:</strong> SUBSCRIBE/PUBLISH commands, plus cross-runtime Lua subscriptions via <code>socketley.subscribe()</code>.</li>
<li><strong>DB backend hooks:</strong> Attach Lua scripts with <code>on_miss</code>, <code>on_write</code>, <code>on_delete</code> callbacks to connect any database. See <a href="#db-backend">DB Backend Hooks</a>.</li>
<li><strong>Access modes:</strong> <code>readwrite</code> (default), <code>readonly</code>, or <code>admin</code> (enables FLUSH/LOAD).</li>
</ul>

<pre><code><span class="cm"># Redis-compatible cache with persistence and LRU eviction</span>
socketley create cache store -p 6379 --resp --persistent /tmp/data.bin --maxmemory 256M --eviction allkeys-lru -s
redis-cli -p 6379 SET mykey myval

<span class="cm"># Leader-follower replication</span>
socketley create cache leader   -p 9000 -s
socketley create cache follower -p 9001 --replicate 127.0.0.1:9000 -s</code></pre>

<!-- ── CACHE PROTOCOL ── -->
<h2 id="cache-protocol">Cache Protocol</h2>
<p>TCP newline-terminated plaintext commands. Also supports RESP2 (auto-detected or forced with <code>--resp</code>). One type per key &mdash; operations on the wrong type return an error.</p>

<h3 id="cp-strings">Strings</h3>
<table><thead><tr><th>Command</th><th>Response</th></tr></thead><tbody>
<tr><td>set key value</td><td><code>ok</code> or <code>error: type conflict</code></td></tr>
<tr><td>get key</td><td>Value or <code>nil</code></td></tr>
<tr><td>del key</td><td><code>ok</code> or <code>nil</code> (any type)</td></tr>
<tr><td>exists key</td><td><code>1</code> or <code>0</code></td></tr>
<tr><td>size</td><td>Total key count</td></tr>
</tbody></table>

<h3 id="cp-lists">Lists (deque-backed)</h3>
<table><thead><tr><th>Command</th><th>Response</th></tr></thead><tbody>
<tr><td>lpush / rpush key value</td><td><code>ok</code></td></tr>
<tr><td>lpop / rpop key</td><td>Value or <code>nil</code></td></tr>
<tr><td>llen key</td><td>Number</td></tr>
<tr><td>lindex key index</td><td>Value or <code>nil</code></td></tr>
<tr><td>lrange key start stop</td><td>Multi-line values + <code>end</code></td></tr>
</tbody></table>

<h3 id="cp-sets">Sets</h3>
<table><thead><tr><th>Command</th><th>Response</th></tr></thead><tbody>
<tr><td>sadd key member</td><td><code>ok</code>, <code>exists</code>, or error</td></tr>
<tr><td>srem key member</td><td><code>ok</code> or <code>nil</code></td></tr>
<tr><td>sismember key member</td><td><code>1</code> or <code>0</code></td></tr>
<tr><td>scard key</td><td>Number</td></tr>
<tr><td>smembers key</td><td>Multi-line members + <code>end</code></td></tr>
</tbody></table>

<h3 id="cp-hashes">Hashes</h3>
<table><thead><tr><th>Command</th><th>Response</th></tr></thead><tbody>
<tr><td>hset key field value</td><td><code>ok</code></td></tr>
<tr><td>hget key field</td><td>Value or <code>nil</code></td></tr>
<tr><td>hdel key field</td><td><code>ok</code> or <code>nil</code></td></tr>
<tr><td>hlen key</td><td>Number</td></tr>
<tr><td>hgetall key</td><td>Multi-line <code>field value</code> pairs + <code>end</code></td></tr>
</tbody></table>

<h3 id="cp-ttl">TTL / Expiry</h3>
<table><thead><tr><th>Command</th><th>Response</th></tr></thead><tbody>
<tr><td>expire key seconds</td><td><code>ok</code> or <code>nil</code></td></tr>
<tr><td>ttl key</td><td>Seconds remaining, <code>-1</code> (no TTL), or <code>-2</code> (not found)</td></tr>
<tr><td>persist key</td><td><code>ok</code> or <code>nil</code></td></tr>
</tbody></table>

<h3 id="cp-pubsub">Pub/Sub</h3>
<table><thead><tr><th>Command</th><th>Response</th></tr></thead><tbody>
<tr><td>subscribe channel</td><td><code>ok</code></td></tr>
<tr><td>unsubscribe channel</td><td><code>ok</code></td></tr>
<tr><td>publish channel message</td><td>Subscriber count</td></tr>
</tbody></table>
<p>Subscribers receive: <code>message &lt;channel&gt; &lt;payload&gt;\n</code></p>

<h3 id="cp-memory">Memory &amp; Admin</h3>
<table><thead><tr><th>Command</th><th>Response</th></tr></thead><tbody>
<tr><td>maxmemory</td><td>Limit in bytes (0 = unlimited)</td></tr>
<tr><td>memory</td><td>Current usage in bytes</td></tr>
<tr><td>flush [path]</td><td>Persist to disk (admin mode required)</td></tr>
<tr><td>load [path]</td><td>Load from disk (admin mode required)</td></tr>
</tbody></table>

<h3 id="cp-resp">RESP2 Protocol</h3>
<p>Force with <code>--resp</code> flag or auto-detected on first RESP byte. Fully compatible with <code>redis-cli</code> and Redis client libraries. Supports SET (with EX, PX, NX, XX), GET, DEL, EXISTS, PING, DBSIZE, INCR/DECR, APPEND, STRLEN, MGET, MSET, TYPE, KEYS, SCAN, and all list/set/hash/TTL/pub-sub operations.</p>
<pre><code>socketley create cache myredis -p 6379 --resp -s
redis-cli -p 6379 SET mykey myval

<span class="cm"># Replication (follower syncs from leader)</span>
socketley create cache leader   -p 9000 -s
socketley create cache follower -p 9001 --replicate 127.0.0.1:9000 -s</code></pre>

<!-- ── CONFIGURATION ── -->
<h2 id="configuration">Configuration</h2>

<h3 id="config-flag">The --lua Flag</h3>
<p>Attach a Lua script to a single runtime at creation time:</p>
<pre><code>socketley create server myserver -p 9000 --lua handler.lua -s</code></pre>
<p>Load an orchestration file that defines multiple runtimes:</p>
<pre><code>socketley --lua setup.lua</code></pre>

<h3 id="config-runtimes">The runtimes Table</h3>
<p>Orchestration files define runtimes in a Lua table. All CLI flags have table equivalents:</p>
<pre><code>runtimes = {
    { type = <span class="st">"server"</span>, name = <span class="st">"api"</span>,   port = <span class="nb">9000</span>, group = <span class="st">"web"</span>,
      cache_name = <span class="st">"store"</span>, http = <span class="st">"./public"</span>, http_cache = <span class="kw">true</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"cache"</span>,  name = <span class="st">"store"</span>, port = <span class="nb">9001</span>, persistent = <span class="st">"/tmp/data.bin"</span>,
      maxmemory = <span class="st">"256M"</span>, eviction = <span class="st">"allkeys-lru"</span>, resp = <span class="kw">true</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"proxy"</span>,  name = <span class="st">"gw"</span>,    port = <span class="nb">8080</span>,
      backends = { <span class="st">"@web"</span> }, strategy = <span class="st">"round-robin"</span>, start = <span class="kw">true</span> },
}</code></pre>
<table><thead><tr><th>Key</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>type</td><td>string</td><td>Required. <code>"server"</code>, <code>"client"</code>, <code>"proxy"</code>, or <code>"cache"</code></td></tr>
<tr><td>name</td><td>string</td><td>Required. Unique runtime name</td></tr>
<tr><td>port</td><td>number</td><td>Port number. 0 = internal only (no network bind)</td></tr>
<tr><td>start</td><td>boolean</td><td>Start immediately after creation</td></tr>
<tr><td>mode</td><td>string</td><td><code>"inout"</code> / <code>"in"</code> / <code>"out"</code> / <code>"master"</code></td></tr>
<tr><td>target</td><td>string</td><td>Client target address (<code>"host:port"</code>)</td></tr>
<tr><td>lua / config</td><td>string</td><td>Lua script path for this runtime</td></tr>
<tr><td>cache_name</td><td>string</td><td>Link server to a cache runtime (equivalent of <code>--cache</code>)</td></tr>
<tr><td>http</td><td>string</td><td>Static file serving directory (equivalent of <code>--http</code>)</td></tr>
<tr><td>http_cache</td><td>boolean</td><td>Pre-load files into memory (equivalent of <code>--http-cache</code>)</td></tr>
<tr><td>persistent</td><td>string</td><td>Cache persistence file path</td></tr>
<tr><td>maxmemory</td><td>string</td><td>Cache memory limit (<code>"256M"</code>, <code>"1G"</code>)</td></tr>
<tr><td>eviction</td><td>string</td><td>Eviction policy: <code>"noeviction"</code>, <code>"allkeys-lru"</code>, <code>"allkeys-random"</code></td></tr>
<tr><td>resp</td><td>boolean</td><td>Force RESP2 protocol mode (cache)</td></tr>
<tr><td>replicate</td><td>string</td><td>Leader address for cache replication (<code>"host:port"</code>)</td></tr>
<tr><td>group</td><td>string</td><td>Group tag for <a href="#concept-groups">dynamic proxy discovery</a> (<code>-g</code>)</td></tr>
<tr><td>backends</td><td>table</td><td>Proxy backends array (IP:port, runtime names, or <code>"@group"</code>)</td></tr>
<tr><td>strategy</td><td>string</td><td>Proxy strategy: <code>"round-robin"</code>, <code>"random"</code>, <code>"lua"</code></td></tr>
<tr><td>protocol</td><td>string</td><td>Proxy protocol: <code>"http"</code> or <code>"tcp"</code></td></tr>
<tr><td>udp</td><td>boolean</td><td>UDP mode (server/client)</td></tr>
<tr><td>reconnect</td><td>boolean/number</td><td>Auto-reconnect for clients. <code>true</code> = infinite, number = max attempts</td></tr>
<tr><td>rate_limit</td><td>number</td><td>Messages/sec per connection</td></tr>
<tr><td>max_connections</td><td>number</td><td>Connection limit</td></tr>
<tr><td>drain</td><td>boolean</td><td>Graceful shutdown</td></tr>
<tr><td>tls</td><td>boolean</td><td>Enable TLS encryption</td></tr>
<tr><td>cert / key / ca</td><td>string</td><td>TLS certificate, key, CA file paths</td></tr>
<tr><td>master_pw</td><td>string</td><td>Master mode password</td></tr>
<tr><td>master_forward</td><td>boolean</td><td>Forward non-master messages to master</td></tr>
</tbody></table>

<h3 id="config-daemon">Daemon Config</h3>
<p><code>/etc/socketley/config.lua</code> or <code>~/.config/socketley/config.lua</code>:</p>
<pre><code>config = {
    log_level    = <span class="st">"info"</span>,
    metrics_port = <span class="nb">9100</span>   <span class="cm">-- GET /metrics exposes Prometheus counters</span>
}</code></pre>
<p>The <code>metrics_port</code> enables a Prometheus-compatible endpoint at <code>http://localhost:9100/metrics</code> with per-runtime connection counts, message rates, and byte counters.</p>


</main>

<!-- ═══════════════════════════════════════════
     SOCKETLEY SDK TAB CONTENT
═══════════════════════════════════════════ -->
<div id="content-socketley-sdk" class="content" style="display:none">

<!-- ── Introduction ── -->
<h2 id="sdk-intro">C++ SDK</h2>

<p>Socketley ships a modular C++ SDK in <code>include/linux/socketley/</code> with a three-tier architecture. Each tier targets a different use case, from zero-dependency daemon control to embedding the full io_uring engine in your own binary.</p>

<h3 id="sdk-three-tiers">Three Tiers</h3>
<table>
<thead><tr><th>Tier</th><th>Header</th><th>Use Case</th><th>Dependencies</th></tr></thead>
<tbody>
<tr><td><span class="badge badge-tier1">Tier 1</span></td><td><code>socketley/control.h</code></td><td>Control a running daemon</td><td>None (POSIX only)</td></tr>
<tr><td><span class="badge badge-tier2">Tier 2</span></td><td><code>socketley/server.h</code><br><code>socketley/client.h</code><br><code>socketley/proxy.h</code><br><code>socketley/cache.h</code></td><td>Embed the full engine</td><td><code>libsocketley_sdk.a</code> + io_uring + OpenSSL</td></tr>
<tr><td><span class="badge badge-tier3">Tier 3</span></td><td><code>socketley/attach.h</code></td><td>Register with a daemon</td><td>None (builds on Tier 1)</td></tr>
</tbody>
</table>

<div class="info-box"><strong>Tiers 1 and 3 are fully self-contained.</strong> Copy the header anywhere, compile with <code>g++ -std=c++17</code>, and you're done &mdash; no library to link, no repo needed. Tier 2 requires building from source.</div>

<h3 id="sdk-install">Installation</h3>
<h4>Tier 1 &amp; 3 (header-only)</h4>
<p>Copy the header files from the SDK directory. No build step required:</p>
<pre><code><span class="cm"># Copy headers to your project</span>
cp -r include/linux/socketley/ /your/project/include/</code></pre>

<h4>Tier 2 (requires library)</h4>
<p>Build the SDK static library from the socketley source tree:</p>
<pre><code>./bin/premake5 gmake2
<span class="kw">cd</span> make && make config=release_x64 -j$(nproc)
<span class="cm"># Library: bin/Release/libsocketley_sdk.a</span></code></pre>

<h3 id="sdk-quickstart">Quick Start</h3>
<p><strong>Tier 1</strong> &mdash; Control a running daemon:</p>
<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/control.h&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>() {
    socketley::ctl::<span class="fn">create</span>(<span class="st">"server"</span>, <span class="st">"myapp"</span>, <span class="st">"-p 9000 -s"</span>);
    socketley::ctl::<span class="fn">send</span>(<span class="st">"myapp"</span>, <span class="st">"Hello!"</span>);
    socketley::ctl::<span class="fn">stop</span>(<span class="st">"myapp"</span>);
    socketley::ctl::<span class="fn">remove</span>(<span class="st">"myapp"</span>);
}
<span class="cm">// g++ -std=c++17 app.cpp -Iinclude/linux -o app</span></code></pre>

<p><strong>Tier 2</strong> &mdash; Embed the engine:</p>
<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/server.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;csignal&gt;</span>

<span class="kw">static</span> event_loop* g_loop = <span class="kw">nullptr</span>;

<span class="kw">int</span> <span class="fn">main</span>() {
    signal(SIGPIPE, SIG_IGN);
    event_loop loop; loop.<span class="fn">init</span>();
    g_loop = &amp;loop;
    runtime_manager mgr;

    mgr.<span class="fn">create</span>(runtime_server, <span class="st">"srv"</span>);
    <span class="kw">auto</span>* srv = <span class="kw">static_cast</span>&lt;server_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"srv"</span>));
    srv-&gt;<span class="fn">set_port</span>(<span class="nb">9000</span>);
    srv-&gt;<span class="fn">set_mode</span>(mode_inout);
    srv-&gt;<span class="fn">set_event_loop</span>(&amp;loop);
    srv-&gt;<span class="fn">set_runtime_manager</span>(&amp;mgr);

    mgr.<span class="fn">start</span>(<span class="st">"srv"</span>, loop);

    signal(SIGINT, [](<span class="kw">int</span>) { g_loop-&gt;<span class="fn">request_stop</span>(); });
    loop.<span class="fn">run</span>();
    mgr.<span class="fn">stop_all</span>(loop);
}
<span class="cm">// g++ -std=c++23 app.cpp -I. -Iinclude/linux -Lbin/Release -lsocketley_sdk -luring -lssl -lcrypto</span></code></pre>

<p><strong>Tier 3</strong> &mdash; Register with daemon:</p>
<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/attach.h&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>() {
    <span class="cm">// Your own server setup here...</span>
    socketley::<span class="fn">daemon_attach</span>(<span class="st">"myservice"</span>, <span class="st">"server"</span>, <span class="nb">8080</span>);
    <span class="cm">// Now visible in: socketley ls</span>
    <span class="cm">// Auto-detach on exit()</span>
}
<span class="cm">// g++ -std=c++17 app.cpp -Iinclude/linux -o app</span></code></pre>

<!-- ══════════════════════════════════════════════════════════════
     TIER 1: DAEMON CONTROL
══════════════════════════════════════════════════════════════ -->
<h2 id="sdk-t1">Tier 1: Daemon Control</h2>
<p><code>#include &lt;socketley/control.h&gt;</code> &mdash; header-only, zero dependencies. Full programmatic control over a running socketley daemon through the same Unix socket IPC that the CLI uses.</p>

<h3 id="sdk-t1-result">Result Type</h3>
<p>Every <code>socketley::ctl</code> function returns this struct:</p>
<div class="method-card" id="sdk-result-struct">
<div class="method-header">
  <span class="method-name">socketley::result</span>
</div>
<pre><code><span class="kw">struct</span> result {
    <span class="kw">int</span>         exit_code;  <span class="cm">// 0 = success, 1 = bad input, 2 = fatal, -1 = connect failed</span>
    std::string data;       <span class="cm">// response body from daemon</span>
};</code></pre>
</div>

<h3 id="sdk-t1-runtime">Runtime Management</h3>
<p>All functions live in the <code>socketley::ctl</code> namespace.</p>

<div class="method-card" id="sdk-ctl-create">
<div class="method-header">
  <span class="method-name">create</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result create(const std::string&amp; type, const std::string&amp; name, const std::string&amp; flags = "")</p>
<p class="method-desc">Create a new runtime. Does not start it unless <code>-s</code> is in flags.</p>
<table>
<thead><tr><th>Parameter</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>type</code></td><td><code>"server"</code>, <code>"client"</code>, <code>"proxy"</code>, or <code>"cache"</code></td></tr>
<tr><td><code>name</code></td><td>Unique runtime name</td></tr>
<tr><td><code>flags</code></td><td>CLI flags string (e.g. <code>"-p 9000 -s --mode admin"</code>)</td></tr>
</tbody>
</table>
<p class="method-returns"><strong>Returns:</strong> <code>result</code> with exit_code 0 on success</p>
</div>

<div class="method-card" id="sdk-ctl-start">
<div class="method-header">
  <span class="method-name">start</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result start(const std::string&amp; name)</p>
<p class="method-desc">Start a created runtime. Transitions from <code>created</code>/<code>stopped</code> to <code>running</code>.</p>
<p class="method-returns"><strong>Returns:</strong> <code>result</code> &mdash; exit_code 1 if runtime not found or already running</p>
</div>

<div class="method-card" id="sdk-ctl-stop">
<div class="method-header">
  <span class="method-name">stop</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result stop(const std::string&amp; name)</p>
<p class="method-desc">Stop a running runtime. Gracefully tears down connections.</p>
</div>

<div class="method-card" id="sdk-ctl-remove">
<div class="method-header">
  <span class="method-name">remove</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result remove(const std::string&amp; name)</p>
<p class="method-desc">Remove a stopped runtime permanently. Deletes its persisted state.</p>
</div>

<h4 id="sdk-t1-send">Send Behavior</h4>
<p>The <code>send</code> method behaves differently depending on the runtime type:</p>

<div class="method-card" id="sdk-ctl-send">
<div class="method-header">
  <span class="method-name">send</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result send(const std::string&amp; name, const std::string&amp; message)</p>
<p class="method-desc">Send a text message to a runtime. Behavior depends on the runtime type:</p>
<table>
<thead><tr><th>Runtime</th><th>Behavior</th></tr></thead>
<tbody>
<tr><td><strong>Server</strong> (mode != in)</td><td>Broadcasts to all connected clients</td></tr>
<tr><td><strong>Client</strong> (mode != in)</td><td>Sends to the connected remote server</td></tr>
<tr><td><strong>Cache</strong></td><td>Not supported &mdash; returns error</td></tr>
<tr><td><strong>Proxy</strong></td><td>Not supported &mdash; returns error</td></tr>
</tbody>
</table>
<pre><code><span class="cm">// Server: broadcasts "hello" to all connected clients</span>
socketley::ctl::<span class="fn">send</span>(<span class="st">"my_server"</span>, <span class="st">"hello"</span>);

<span class="cm">// Client: sends "hello" to the remote server</span>
socketley::ctl::<span class="fn">send</span>(<span class="st">"my_client"</span>, <span class="st">"hello"</span>);

<span class="cm">// Cache/Proxy: returns error (exit_code != 0)</span>
<span class="kw">auto</span> r = socketley::ctl::<span class="fn">send</span>(<span class="st">"my_cache"</span>, <span class="st">"hello"</span>);
<span class="cm">// r.exit_code == 1</span></code></pre>
</div>

<div class="method-card" id="sdk-ctl-ls">
<div class="method-header">
  <span class="method-name">ls</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result ls()</p>
<p class="method-desc">List all runtimes with their type, port, state, and connection count.</p>
<p class="method-returns"><strong>Returns:</strong> <code>result</code> with tabular listing in <code>data</code></p>
</div>

<div class="method-card" id="sdk-ctl-ps">
<div class="method-header">
  <span class="method-name">ps</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result ps()</p>
<p class="method-desc">Show running runtimes with PIDs and uptime.</p>
</div>

<div class="method-card" id="sdk-ctl-stats">
<div class="method-header">
  <span class="method-name">stats</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result stats(const std::string&amp; name)</p>
<p class="method-desc">Get detailed statistics for a runtime: connections, messages, bytes in/out, uptime.</p>
</div>

<div class="method-card" id="sdk-ctl-show">
<div class="method-header">
  <span class="method-name">show</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result show(const std::string&amp; name)</p>
<p class="method-desc">Show the current configuration of a runtime (port, mode, flags, Lua script path, etc.).</p>
</div>

<div class="method-card" id="sdk-ctl-reload">
<div class="method-header">
  <span class="method-name">reload</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result reload(const std::string&amp; name)</p>
<p class="method-desc">Reload a runtime (stop + start). Connections are dropped and re-established.</p>
</div>

<div class="method-card" id="sdk-ctl-reload-lua">
<div class="method-header">
  <span class="method-name">reload_lua</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result reload_lua(const std::string&amp; name)</p>
<p class="method-desc">Hot-reload the Lua script without restarting the runtime. Existing connections stay alive.</p>
</div>

<div class="method-card" id="sdk-ctl-edit">
<div class="method-header">
  <span class="method-name">edit</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result edit(const std::string&amp; name, const std::string&amp; flags)</p>
<p class="method-desc">Edit runtime flags on a stopped runtime. Takes the same flags as <code>create</code>.</p>
</div>

<h3 id="sdk-t1-cache">Cache Operations</h3>
<p>Direct IPC access to cache data &mdash; no TCP connection needed. Every operation has a typed convenience function in <code>socketley::ctl</code>.</p>

<h4>Strings</h4>

<div class="method-card" id="sdk-ctl-cache-get">
<div class="method-header">
  <span class="method-name">cache_get</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_get(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Get a string value from a cache runtime. Returns <code>"nil"</code> in data if key doesn't exist.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-set">
<div class="method-header">
  <span class="method-name">cache_set</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_set(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-desc">Set a string value in a cache runtime.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-del">
<div class="method-header">
  <span class="method-name">cache_del</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_del(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Delete a key of any type from a cache runtime.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-exists">
<div class="method-header">
  <span class="method-name">cache_exists</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_exists(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Check if a key exists. Returns <code>"1"</code> or <code>"0"</code> in data.</p>
</div>

<h4>Lists</h4>

<div class="method-card" id="sdk-ctl-cache-lpush">
<div class="method-header">
  <span class="method-name">cache_lpush / cache_rpush</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_lpush(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-sig">result cache_rpush(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-desc">Push a value to the head (<code>lpush</code>) or tail (<code>rpush</code>) of a list. Creates the list if it doesn't exist.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-lpop">
<div class="method-header">
  <span class="method-name">cache_lpop / cache_rpop</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_lpop(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-sig">result cache_rpop(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Pop and return the first (<code>lpop</code>) or last (<code>rpop</code>) element. Returns <code>"nil"</code> if empty.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-llen">
<div class="method-header">
  <span class="method-name">cache_llen</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_llen(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Get the length of a list. Returns count in data.</p>
</div>

<h4>Sets</h4>

<div class="method-card" id="sdk-ctl-cache-sadd">
<div class="method-header">
  <span class="method-name">cache_sadd</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_sadd(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; member)</p>
<p class="method-desc">Add a member to a set. Returns <code>"ok"</code> if added, <code>"exists"</code> if already present.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-srem">
<div class="method-header">
  <span class="method-name">cache_srem</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_srem(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; member)</p>
<p class="method-desc">Remove a member from a set. Returns <code>"1"</code> if removed, <code>"0"</code> if not found.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-sismember">
<div class="method-header">
  <span class="method-name">cache_sismember</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_sismember(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; member)</p>
<p class="method-desc">Check if a member exists in a set. Returns <code>"1"</code> or <code>"0"</code>.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-scard">
<div class="method-header">
  <span class="method-name">cache_scard</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_scard(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Get the number of members in a set.</p>
</div>

<h4>Hashes</h4>

<div class="method-card" id="sdk-ctl-cache-hset">
<div class="method-header">
  <span class="method-name">cache_hset</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_hset(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; field, const std::string&amp; value)</p>
<p class="method-desc">Set a field in a hash. Creates the hash if it doesn't exist.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-hget">
<div class="method-header">
  <span class="method-name">cache_hget</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_hget(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; field)</p>
<p class="method-desc">Get a hash field value. Returns <code>"nil"</code> if field or key doesn't exist.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-hdel">
<div class="method-header">
  <span class="method-name">cache_hdel</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_hdel(const std::string&amp; cache_name, const std::string&amp; key, const std::string&amp; field)</p>
<p class="method-desc">Delete a field from a hash. Returns <code>"1"</code> if removed, <code>"0"</code> if not found.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-hlen">
<div class="method-header">
  <span class="method-name">cache_hlen</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_hlen(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Get the number of fields in a hash.</p>
</div>

<h4>TTL</h4>

<div class="method-card" id="sdk-ctl-cache-expire">
<div class="method-header">
  <span class="method-name">cache_expire</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_expire(const std::string&amp; cache_name, const std::string&amp; key, int seconds)</p>
<p class="method-desc">Set a TTL on a key. Returns <code>"ok"</code> if set, <code>"nil"</code> if key doesn't exist.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-ttl">
<div class="method-header">
  <span class="method-name">cache_ttl</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_ttl(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Get remaining TTL in seconds. Returns <code>-1</code> (no TTL), <code>-2</code> (key missing), or seconds remaining.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-persist">
<div class="method-header">
  <span class="method-name">cache_persist</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_persist(const std::string&amp; cache_name, const std::string&amp; key)</p>
<p class="method-desc">Remove TTL from a key. Returns <code>"ok"</code> if removed, <code>"nil"</code> if key has no TTL or doesn't exist.</p>
</div>

<h4>Pub/Sub</h4>

<div class="method-card" id="sdk-ctl-cache-publish">
<div class="method-header">
  <span class="method-name">cache_publish</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_publish(const std::string&amp; cache_name, const std::string&amp; channel, const std::string&amp; message)</p>
<p class="method-desc">Publish a message to a channel. Returns subscriber count in data.</p>
</div>

<h4>Admin</h4>

<div class="method-card" id="sdk-ctl-cache-size">
<div class="method-header">
  <span class="method-name">cache_size</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_size(const std::string&amp; cache_name)</p>
<p class="method-desc">Get total key count in the cache.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-memory">
<div class="method-header">
  <span class="method-name">cache_memory</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_memory(const std::string&amp; cache_name)</p>
<p class="method-desc">Get memory usage. Returns <code>"max_memory used_memory"</code> in data.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-flush">
<div class="method-header">
  <span class="method-name">cache_flush</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_flush(const std::string&amp; cache_name, const std::string&amp; path = "")</p>
<p class="method-desc">Save cache snapshot to disk. If path is empty, uses the persistent path configured on the cache. Requires admin mode.</p>
</div>

<div class="method-card" id="sdk-ctl-cache-load">
<div class="method-header">
  <span class="method-name">cache_load</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">result cache_load(const std::string&amp; cache_name, const std::string&amp; path = "")</p>
<p class="method-desc">Load cache snapshot from disk. Requires admin mode.</p>
</div>

<h3 id="sdk-t1-action">Action Commands</h3>
<p>All <code>cache_*</code> functions above are convenience wrappers around <code>action</code> subcommands. You can also call them directly via <code>command()</code> for maximum flexibility:</p>
<pre><code><span class="cm">// These two are equivalent:</span>
socketley::ctl::<span class="fn">cache_lpush</span>(<span class="st">"store"</span>, <span class="st">"mylist"</span>, <span class="st">"item1"</span>);
socketley::ctl::<span class="fn">command</span>(<span class="st">"action store lpush mylist item1"</span>);</code></pre>
<p>The raw <code>action</code> syntax is useful for commands that don't have a convenience wrapper yet, or for dynamic command construction.</p>

<h4>Strings</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>get</code></td><td><code>action &lt;name&gt; get &lt;key&gt;</code></td><td>Value or <code>"nil"</code></td></tr>
<tr><td><code>set</code></td><td><code>action &lt;name&gt; set &lt;key&gt; &lt;value&gt;</code></td><td><code>"ok"</code></td></tr>
<tr><td><code>del</code></td><td><code>action &lt;name&gt; del &lt;key&gt;</code></td><td><code>"ok"</code> or <code>"nil"</code></td></tr>
<tr><td><code>exists</code></td><td><code>action &lt;name&gt; exists &lt;key&gt;</code></td><td><code>"1"</code> or <code>"0"</code></td></tr>
</tbody>
</table>

<h4>Lists</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>lpush</code></td><td><code>action &lt;name&gt; lpush &lt;key&gt; &lt;value&gt;</code></td><td><code>"ok"</code></td></tr>
<tr><td><code>rpush</code></td><td><code>action &lt;name&gt; rpush &lt;key&gt; &lt;value&gt;</code></td><td><code>"ok"</code></td></tr>
<tr><td><code>lpop</code></td><td><code>action &lt;name&gt; lpop &lt;key&gt;</code></td><td>Value or <code>"nil"</code></td></tr>
<tr><td><code>rpop</code></td><td><code>action &lt;name&gt; rpop &lt;key&gt;</code></td><td>Value or <code>"nil"</code></td></tr>
<tr><td><code>llen</code></td><td><code>action &lt;name&gt; llen &lt;key&gt;</code></td><td>Count</td></tr>
</tbody>
</table>

<h4>Sets</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>sadd</code></td><td><code>action &lt;name&gt; sadd &lt;key&gt; &lt;member&gt;</code></td><td><code>"ok"</code> or <code>"exists"</code></td></tr>
<tr><td><code>srem</code></td><td><code>action &lt;name&gt; srem &lt;key&gt; &lt;member&gt;</code></td><td><code>"1"</code> or <code>"0"</code></td></tr>
<tr><td><code>sismember</code></td><td><code>action &lt;name&gt; sismember &lt;key&gt; &lt;member&gt;</code></td><td><code>"1"</code> or <code>"0"</code></td></tr>
<tr><td><code>scard</code></td><td><code>action &lt;name&gt; scard &lt;key&gt;</code></td><td>Count</td></tr>
</tbody>
</table>

<h4>Hashes</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>hset</code></td><td><code>action &lt;name&gt; hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</code></td><td><code>"ok"</code></td></tr>
<tr><td><code>hget</code></td><td><code>action &lt;name&gt; hget &lt;key&gt; &lt;field&gt;</code></td><td>Value or <code>"nil"</code></td></tr>
<tr><td><code>hdel</code></td><td><code>action &lt;name&gt; hdel &lt;key&gt; &lt;field&gt;</code></td><td><code>"1"</code> or <code>"0"</code></td></tr>
<tr><td><code>hlen</code></td><td><code>action &lt;name&gt; hlen &lt;key&gt;</code></td><td>Count</td></tr>
</tbody>
</table>

<h4>TTL</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>expire</code></td><td><code>action &lt;name&gt; expire &lt;key&gt; &lt;seconds&gt;</code></td><td><code>"ok"</code> or <code>"nil"</code></td></tr>
<tr><td><code>ttl</code></td><td><code>action &lt;name&gt; ttl &lt;key&gt;</code></td><td>Seconds remaining, <code>-1</code> (no TTL), or <code>-2</code> (missing key)</td></tr>
<tr><td><code>persist</code></td><td><code>action &lt;name&gt; persist &lt;key&gt;</code></td><td><code>"ok"</code> or <code>"nil"</code></td></tr>
</tbody>
</table>

<h4>Pub/Sub</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>publish</code></td><td><code>action &lt;name&gt; publish &lt;channel&gt; &lt;message&gt;</code></td><td>Subscriber count</td></tr>
</tbody>
</table>

<h4>Admin</h4>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Returns</th></tr></thead>
<tbody>
<tr><td><code>size</code></td><td><code>action &lt;name&gt; size</code></td><td>Total key count</td></tr>
<tr><td><code>memory</code></td><td><code>action &lt;name&gt; memory</code></td><td><code>"max_memory used_memory"</code></td></tr>
<tr><td><code>flush</code></td><td><code>action &lt;name&gt; flush [path]</code></td><td><code>"ok"</code> (requires admin mode)</td></tr>
<tr><td><code>load</code></td><td><code>action &lt;name&gt; load [path]</code></td><td><code>"ok"</code> (requires admin mode)</td></tr>
</tbody>
</table>

<pre><code><span class="cm">// Typed convenience functions (recommended)</span>
socketley::ctl::<span class="fn">cache_set</span>(<span class="st">"store"</span>, <span class="st">"user:1"</span>, <span class="st">"alice"</span>);
socketley::ctl::<span class="fn">cache_lpush</span>(<span class="st">"store"</span>, <span class="st">"queue"</span>, <span class="st">"job_a"</span>);
socketley::ctl::<span class="fn">cache_sadd</span>(<span class="st">"store"</span>, <span class="st">"tags:1"</span>, <span class="st">"vip"</span>);
socketley::ctl::<span class="fn">cache_hset</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>, <span class="st">"token"</span>, <span class="st">"abc123"</span>);
socketley::ctl::<span class="fn">cache_expire</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>, <span class="nb">3600</span>);

<span class="kw">auto</span> r = socketley::ctl::<span class="fn">cache_hget</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>, <span class="st">"token"</span>);
printf(<span class="st">"token = %s\n"</span>, r.data.c_str()); <span class="cm">// "abc123"</span></code></pre>

<h3 id="sdk-t1-raw">Raw Command</h3>
<div class="method-card" id="sdk-ctl-command">
<div class="method-header">
  <span class="method-name">command</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-sig">result command(const std::string&amp; cmd)</p>
<p class="method-sig">result command(const std::string&amp; socket_path, const std::string&amp; cmd)</p>
<p class="method-desc">Send any raw command string to the daemon. Supports glob patterns. The two-argument form lets you target a specific socket path.</p>
<pre><code><span class="kw">auto</span> r = socketley::ctl::<span class="fn">command</span>(<span class="st">"start fleet_srv_*"</span>);  <span class="cm">// glob pattern</span>
<span class="kw">auto</span> r = socketley::ctl::<span class="fn">command</span>(<span class="st">"/tmp/my.sock"</span>, <span class="st">"ls"</span>); <span class="cm">// custom socket</span></code></pre>
</div>

<h3 id="sdk-t1-socket">Socket Path Resolution</h3>
<p>The SDK automatically finds the daemon socket in this order:</p>
<ol>
<li><code>SOCKETLEY_SOCKET</code> environment variable</li>
<li><code>/run/socketley/socketley.sock</code></li>
<li><code>/tmp/socketley.sock</code></li>
</ol>

<!-- ══════════════════════════════════════════════════════════════
     TIER 2: EMBED ENGINE
══════════════════════════════════════════════════════════════ -->
<h2 id="sdk-t2">Tier 2: Embed Engine</h2>
<p>Tier 2 embeds the full socketley engine &mdash; io_uring event loop, runtime manager, and all four runtime types &mdash; directly in your own binary. Maximum performance (no IPC overhead), full control over the event loop.</p>

<h3 id="sdk-t2-build">Build &amp; Link</h3>
<div class="warn-box"><strong>Build requirement:</strong> Tier 2 requires the socketley source tree and <code>libsocketley_sdk.a</code>.<br>
<code>g++ -std=c++23 app.cpp -I. -Iinclude/linux -Lbin/Release -lsocketley_sdk -luring -lssl -lcrypto</code><br>
Add <code>-lluajit</code> if using Lua, or define <code>SOCKETLEY_NO_LUA</code> to build without it.</div>

<table>
<thead><tr><th>Header</th><th>Provides</th></tr></thead>
<tbody>
<tr><td><code>socketley/core.h</code></td><td><code>event_loop</code>, <code>runtime_manager</code>, enums, logging</td></tr>
<tr><td><code>socketley/server.h</code></td><td><code>server_instance</code> (TCP/UDP server with callbacks)</td></tr>
<tr><td><code>socketley/client.h</code></td><td><code>client_instance</code> (TCP/UDP connector)</td></tr>
<tr><td><code>socketley/proxy.h</code></td><td><code>proxy_instance</code> (HTTP/TCP reverse proxy)</td></tr>
<tr><td><code>socketley/cache.h</code></td><td><code>cache_instance</code> (Redis-compatible in-memory store)</td></tr>
</tbody>
</table>

<h3 id="sdk-t2-eventloop">event_loop</h3>
<p>The io_uring event loop drives all I/O. One per process, shared by all runtimes.</p>

<div class="method-card" id="sdk-el-init">
<div class="method-header">
  <span class="method-name">event_loop::init</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">bool init()</p>
<p class="method-desc">Initialize the io_uring ring with SQPOLL. Must be called before any other event_loop method. Returns false if io_uring setup fails (missing kernel support).</p>
</div>

<div class="method-card" id="sdk-el-run">
<div class="method-header">
  <span class="method-name">event_loop::run</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">void run()</p>
<p class="method-desc">Enter the main event loop. Blocks until <code>request_stop()</code> is called (typically from a signal handler). Processes io_uring completions and dispatches them to runtime handlers.</p>
</div>

<div class="method-card" id="sdk-el-stop">
<div class="method-header">
  <span class="method-name">event_loop::request_stop</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">void request_stop()</p>
<p class="method-desc">Signal the event loop to stop. Safe to call from signal handlers. The loop exits after the current batch of completions is processed.</p>
</div>

<h3 id="sdk-t2-manager">runtime_manager</h3>
<p>Manages the lifecycle and lookup of all runtimes.</p>

<div class="method-card" id="sdk-mgr-create">
<div class="method-header">
  <span class="method-name">runtime_manager::create</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">bool create(runtime_type type, std::string_view name)</p>
<p class="method-desc">Create a new runtime in <code>created</code> state. Configure it via its type-specific setters before calling <code>start()</code>.</p>
<table>
<thead><tr><th>Parameter</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>type</code></td><td><code>runtime_server</code>, <code>runtime_client</code>, <code>runtime_proxy</code>, <code>runtime_cache</code></td></tr>
<tr><td><code>name</code></td><td>Unique runtime name</td></tr>
</tbody>
</table>
<p class="method-returns"><strong>Returns:</strong> <code>false</code> if name already exists</p>
</div>

<div class="method-card" id="sdk-mgr-start">
<div class="method-header">
  <span class="method-name">runtime_manager::start</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">bool start(std::string_view name, event_loop&amp; loop)</p>
<p class="method-desc">Start a runtime. Calls its <code>setup()</code> to bind/listen/connect and register with the event loop.</p>
<p class="method-returns"><strong>Returns:</strong> <code>false</code> if runtime not found, already running, or setup fails (e.g. port in use)</p>
</div>

<div class="method-card" id="sdk-mgr-stop">
<div class="method-header">
  <span class="method-name">runtime_manager::stop</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">bool stop(std::string_view name, event_loop&amp; loop)</p>
<p class="method-desc">Stop a running runtime. Calls its <code>teardown()</code> to gracefully close connections.</p>
</div>

<div class="method-card" id="sdk-mgr-remove">
<div class="method-header">
  <span class="method-name">runtime_manager::remove</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">bool remove(std::string_view name)</p>
<p class="method-desc">Delete a stopped runtime from the manager.</p>
</div>

<div class="method-card" id="sdk-mgr-get">
<div class="method-header">
  <span class="method-name">runtime_manager::get</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">runtime_instance* get(std::string_view name)</p>
<p class="method-desc">Look up a runtime by name. Returns <code>nullptr</code> if not found. Cast to the concrete type to access type-specific methods.</p>
<pre><code><span class="kw">auto</span>* srv = <span class="kw">static_cast</span>&lt;server_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"my_server"</span>));</code></pre>
</div>

<div class="method-card" id="sdk-mgr-list">
<div class="method-header">
  <span class="method-name">runtime_manager::list</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">const runtime_map&amp; list() const</p>
<p class="method-desc">Get all runtimes as an unordered map of <code>name &rarr; unique_ptr&lt;runtime_instance&gt;</code>.</p>
</div>

<div class="method-card" id="sdk-mgr-stopall">
<div class="method-header">
  <span class="method-name">runtime_manager::stop_all</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">void stop_all(event_loop&amp; loop)</p>
<p class="method-desc">Stop all running runtimes. Call this during shutdown, after the event loop exits.</p>
</div>

<div class="method-card" id="sdk-mgr-dispatch">
<div class="method-header">
  <span class="method-name">runtime_manager::dispatch_publish</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">void dispatch_publish(std::string_view cache_name, std::string_view channel, std::string_view message)</p>
<p class="method-desc">Dispatch a pub/sub message to all runtimes subscribed to the given channel. Used for cross-runtime pub/sub.</p>
</div>

<div class="method-card" id="sdk-mgr-group">
<div class="method-header">
  <span class="method-name">runtime_manager::get_by_group</span>
  <span class="badge badge-tier2">Tier 2</span>
</div>
<p class="method-sig">std::vector&lt;runtime_instance*&gt; get_by_group(std::string_view group) const</p>
<p class="method-desc">Find all runtimes tagged with a specific group. Used by proxy for dynamic backend discovery.</p>
</div>

<h3 id="sdk-t2-base">runtime_instance (Base)</h3>
<p>Base class inherited by all four runtime types. Provides identity, configuration, TLS, limits, lifecycle, and Lua integration.</p>

<h4>Identity</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>get_name() &rarr; string_view</code></td><td>Runtime name</td></tr>
<tr><td><code>set_name(string_view)</code></td><td>Rename runtime</td></tr>
<tr><td><code>get_id() &rarr; string_view</code></td><td>Unique short ID</td></tr>
<tr><td><code>get_type() &rarr; runtime_type</code></td><td>Server, client, proxy, or cache</td></tr>
<tr><td><code>get_state() &rarr; runtime_state</code></td><td>Current lifecycle state</td></tr>
</tbody>
</table>

<h4>Configuration</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_port(uint16_t)</code></td><td>Listen/connect port</td></tr>
<tr><td><code>set_event_loop(event_loop*)</code></td><td><strong>Required</strong> &mdash; event loop reference</td></tr>
<tr><td><code>set_runtime_manager(runtime_manager*)</code></td><td><strong>Required</strong> &mdash; manager reference</td></tr>
<tr><td><code>set_cache_name(string_view)</code></td><td>Link to a cache runtime by name</td></tr>
<tr><td><code>set_target(string_view)</code></td><td>Target address (client type)</td></tr>
<tr><td><code>set_group(string_view)</code></td><td>Group tag (for proxy backend discovery)</td></tr>
<tr><td><code>set_log_file(string_view)</code></td><td>Log output path</td></tr>
</tbody>
</table>

<h4>TLS</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_tls(bool)</code></td><td>Enable/disable TLS</td></tr>
<tr><td><code>set_cert_path(string_view)</code></td><td>Server certificate path</td></tr>
<tr><td><code>set_key_path(string_view)</code></td><td>Private key path</td></tr>
<tr><td><code>set_ca_path(string_view)</code></td><td>CA certificate path (for client verification)</td></tr>
</tbody>
</table>

<h4>Limits</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_max_connections(uint32_t)</code></td><td>Connection limit (0 = unlimited)</td></tr>
<tr><td><code>set_rate_limit(double)</code></td><td>Per-connection rate limit (msgs/sec, 0 = unlimited)</td></tr>
<tr><td><code>set_global_rate_limit(double)</code></td><td>Aggregate rate limit across all connections</td></tr>
<tr><td><code>set_idle_timeout(uint32_t)</code></td><td>Disconnect after idle seconds (0 = disabled)</td></tr>
<tr><td><code>set_drain(bool)</code></td><td>Stop accepting new connections (graceful shutdown)</td></tr>
</tbody>
</table>

<h4>Lifecycle &amp; Stats</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>get_connection_count() &rarr; size_t</code></td><td>Current active connections</td></tr>
<tr><td><code>get_stats() &rarr; string</code></td><td>Formatted statistics string</td></tr>
<tr><td><code>get_created_time()</code></td><td>When the runtime was created</td></tr>
<tr><td><code>get_start_time()</code></td><td>When the runtime was last started</td></tr>
</tbody>
</table>

<h4>Lua Integration</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>load_lua_script(string_view)</code></td><td>Load and execute a Lua script file</td></tr>
<tr><td><code>reload_lua_script()</code></td><td>Hot-reload the current Lua script</td></tr>
<tr><td><code>get_lua_script_path() &rarr; string_view</code></td><td>Currently loaded script path</td></tr>
</tbody>
</table>

<h4>Bash Output</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_bash_output(bool)</code></td><td>Echo client messages to stdout</td></tr>
<tr><td><code>set_bash_prefix(bool)</code></td><td>Prefix output with client fd</td></tr>
<tr><td><code>set_bash_timestamp(bool)</code></td><td>Prefix output with timestamp</td></tr>
</tbody>
</table>

<h3 id="sdk-t2-callbacks">C++ Callbacks</h3>
<p>Set C++ callbacks directly on any runtime as an alternative to Lua scripts. These fire on the io_uring event loop thread.</p>

<div class="callback-card" id="sdk-cb-onstart">
<div class="method-header">
  <span class="method-name">set_on_start</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-all">All</span>
</div>
<p class="method-sig">void set_on_start(std::function&lt;void()&gt; cb)</p>
<p class="method-desc">Fires when the runtime transitions to <code>running</code> state.</p>
<p class="fires">Fires: once per start</p>
</div>

<div class="callback-card" id="sdk-cb-onstop">
<div class="method-header">
  <span class="method-name">set_on_stop</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-all">All</span>
</div>
<p class="method-sig">void set_on_stop(std::function&lt;void()&gt; cb)</p>
<p class="method-desc">Fires when the runtime is stopped.</p>
<p class="fires">Fires: once per stop</p>
</div>

<div class="callback-card" id="sdk-cb-onconnect">
<div class="method-header">
  <span class="method-name">set_on_connect</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void set_on_connect(std::function&lt;void(int fd)&gt; cb)</p>
<p class="method-desc">Fires when a new client connects. The <code>fd</code> is the client's file descriptor, used as the client ID in all subsequent operations.</p>
<p class="fires">Fires: per connection</p>
</div>

<div class="callback-card" id="sdk-cb-ondisconnect">
<div class="method-header">
  <span class="method-name">set_on_disconnect</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void set_on_disconnect(std::function&lt;void(int fd)&gt; cb)</p>
<p class="method-desc">Fires when a client disconnects (gracefully or on error).</p>
<p class="fires">Fires: per disconnection</p>
</div>

<div class="callback-card" id="sdk-cb-onclientmsg">
<div class="method-header">
  <span class="method-name">set_on_client_message</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void set_on_client_message(std::function&lt;void(int fd, std::string_view msg)&gt; cb)</p>
<p class="method-desc">Fires when a message arrives from a connected client. Messages are newline-delimited. WebSocket frames are automatically decoded.</p>
<p class="fires">Fires: per message</p>
</div>

<div class="callback-card" id="sdk-cb-onmessage">
<div class="method-header">
  <span class="method-name">set_on_message</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-all">All</span>
</div>
<p class="method-sig">void set_on_message(std::function&lt;void(std::string_view msg)&gt; cb)</p>
<p class="method-desc">Fires when a broadcast message is received (e.g. from <code>socketley send</code>).</p>
<p class="fires">Fires: per broadcast</p>
</div>

<div class="callback-card" id="sdk-cb-ontick">
<div class="method-header">
  <span class="method-name">set_on_tick</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-all">All</span>
</div>
<p class="method-sig">void set_on_tick(std::function&lt;void(double dt_ms)&gt; cb)</p>
<p class="method-desc">Fires periodically at the interval set by <code>set_tick_interval(ms)</code>. The <code>dt_ms</code> parameter is the actual elapsed time since the last tick.</p>
<pre><code>srv-&gt;<span class="fn">set_tick_interval</span>(<span class="nb">1000</span>);  <span class="cm">// 1 second</span>
srv-&gt;<span class="fn">set_on_tick</span>([](<span class="kw">double</span> dt) {
    printf(<span class="st">"tick: %.1f ms\n"</span>, dt);
});</code></pre>
</div>

<h3 id="sdk-t2-server">server_instance</h3>
<p><code>#include &lt;socketley/server.h&gt;</code> &mdash; TCP/UDP server with auto-WebSocket detection.</p>

<h4>Modes</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_mode(server_mode)</code></td><td><code>mode_inout</code> (bidirectional), <code>mode_in</code> (receive only), <code>mode_out</code> (broadcast only), <code>mode_master</code> (first connection is admin)</td></tr>
<tr><td><code>set_udp(bool)</code></td><td>Enable UDP datagram mode</td></tr>
<tr><td><code>set_http_dir(string_view)</code></td><td>Serve static files from directory (enables HTTP mode)</td></tr>
<tr><td><code>set_http_cache(bool)</code></td><td>Cache file contents in memory</td></tr>
</tbody>
</table>

<h4>Actions</h4>

<div class="method-card" id="sdk-srv-broadcast">
<div class="method-header">
  <span class="method-name">lua_broadcast</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void lua_broadcast(std::string_view msg)</p>
<p class="method-desc">Send a message to all connected clients. WebSocket clients receive it as a WebSocket frame.</p>
</div>

<div class="method-card" id="sdk-srv-sendto">
<div class="method-header">
  <span class="method-name">lua_send_to</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void lua_send_to(int client_id, std::string_view msg)</p>
<p class="method-desc">Send a message to a specific client by fd.</p>
</div>

<div class="method-card" id="sdk-srv-disconnect">
<div class="method-header">
  <span class="method-name">lua_disconnect</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void lua_disconnect(int client_fd)</p>
<p class="method-desc">Disconnect a client. Uses <code>SHUT_RD</code> (not <code>SHUT_RDWR</code>) so queued writes still reach the client before the connection closes.</p>
</div>

<div class="method-card" id="sdk-srv-peerip">
<div class="method-header">
  <span class="method-name">lua_peer_ip</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">std::string lua_peer_ip(int client_fd)</p>
<p class="method-desc">Get the IP address of a connected client. Returns IPv4 or IPv6 string.</p>
</div>

<div class="method-card" id="sdk-srv-clients">
<div class="method-header">
  <span class="method-name">lua_clients</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">std::vector&lt;int&gt; lua_clients() const</p>
<p class="method-desc">Get all connected client file descriptors.</p>
</div>

<div class="method-card" id="sdk-srv-multicast">
<div class="method-header">
  <span class="method-name">lua_multicast</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-sig">void lua_multicast(const std::vector&lt;int&gt;&amp; fds, std::string_view msg)</p>
<p class="method-desc">Send a message to a subset of clients. Uses a zero-copy shared buffer path internally.</p>
</div>

<h4>Metadata</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>lua_set_data(fd, key, val)</code></td><td>Set per-connection metadata</td></tr>
<tr><td><code>lua_get_data(fd, key)</code></td><td>Get per-connection metadata</td></tr>
<tr><td><code>lua_del_data(fd, key)</code></td><td>Delete per-connection metadata</td></tr>
<tr><td><code>lua_ws_headers(fd)</code></td><td>Get WebSocket upgrade headers (cookie, origin, protocol, auth)</td></tr>
</tbody>
</table>

<h4>Routing</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>route_client(fd, target_name)</code></td><td>Forward a client to another server runtime</td></tr>
<tr><td><code>unroute_client(fd)</code></td><td>Remove client routing</td></tr>
<tr><td><code>owner_send(fd, msg)</code></td><td>Send to parent server's client</td></tr>
<tr><td><code>owner_broadcast(msg)</code></td><td>Broadcast to parent server's clients</td></tr>
</tbody>
</table>

<h3 id="sdk-t2-cache">cache_instance</h3>
<p><code>#include &lt;socketley/cache.h&gt;</code> &mdash; Redis-compatible in-memory data store with RESP2 auto-detection.</p>

<h4>Modes</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_mode(cache_mode)</code></td><td><code>cache_mode_readonly</code> (GET only), <code>cache_mode_readwrite</code> (GET/SET/DEL), <code>cache_mode_admin</code> (all commands)</td></tr>
<tr><td><code>set_resp_forced(bool)</code></td><td>Force RESP2 wire protocol (for redis-benchmark compatibility)</td></tr>
</tbody>
</table>

<h4>Persistence &amp; Memory</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_persistent(string_view path)</code></td><td>RDB snapshot path (auto-load on start, auto-save on stop)</td></tr>
<tr><td><code>set_max_memory(size_t bytes)</code></td><td>Memory limit (0 = unlimited)</td></tr>
<tr><td><code>set_eviction(eviction_policy)</code></td><td><code>evict_none</code>, <code>evict_allkeys_lru</code>, <code>evict_allkeys_random</code></td></tr>
<tr><td><code>flush_to(string_view path)</code></td><td>Save cache to file</td></tr>
<tr><td><code>load_from(string_view path)</code></td><td>Load cache from file</td></tr>
</tbody>
</table>

<h4>Replication</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_replicate_target(string_view)</code></td><td>Leader address (makes this cache a follower)</td></tr>
<tr><td><code>get_repl_role()</code></td><td>Returns <code>repl_none</code>, <code>repl_leader</code>, or <code>repl_follower</code></td></tr>
</tbody>
</table>

<h4 id="sdk-t2-cache-strings">Strings</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_set</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_set(const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-desc">Set a string value. Overwrites any existing key regardless of type.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> on success</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_get</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">std::string lua_get(const std::string&amp; key)</p>
<p class="method-desc">Get a string value by key.</p>
<p class="method-returns"><strong>Returns:</strong> The value, or empty string if key doesn't exist</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_del</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_del(const std::string&amp; key)</p>
<p class="method-desc">Delete a key of any type.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if the key existed and was deleted</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">store_direct</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">void store_direct(const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-desc">Direct write into the backing store, bypassing protocol parsing. Used internally by server <code>--cache</code> integration.</p>
</div>

<h4 id="sdk-t2-cache-lists">Lists</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_lpush / lua_rpush</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_lpush(const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-sig">bool lua_rpush(const std::string&amp; key, const std::string&amp; value)</p>
<p class="method-desc">Push a value to the head (<code>lpush</code>) or tail (<code>rpush</code>) of a list. Creates the list if it doesn't exist.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> on success, <code>false</code> on type conflict (key exists but isn't a list)</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_lpop / lua_rpop</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">std::string lua_lpop(const std::string&amp; key)</p>
<p class="method-sig">std::string lua_rpop(const std::string&amp; key)</p>
<p class="method-desc">Pop and return the first (<code>lpop</code>) or last (<code>rpop</code>) element of a list.</p>
<p class="method-returns"><strong>Returns:</strong> The value, or empty string if the list is empty or doesn't exist</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_llen</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">int lua_llen(const std::string&amp; key)</p>
<p class="method-desc">Get the length of a list.</p>
<p class="method-returns"><strong>Returns:</strong> Element count, or <code>0</code> if key doesn't exist</p>
</div>

<h4 id="sdk-t2-cache-sets">Sets</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_sadd</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">int lua_sadd(const std::string&amp; key, const std::string&amp; member)</p>
<p class="method-desc">Add a member to a set. Creates the set if it doesn't exist.</p>
<p class="method-returns"><strong>Returns:</strong> <code>1</code> if added, <code>0</code> if already exists, <code>-1</code> on type conflict</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_srem</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_srem(const std::string&amp; key, const std::string&amp; member)</p>
<p class="method-desc">Remove a member from a set.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if the member was removed</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_sismember</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_sismember(const std::string&amp; key, const std::string&amp; member)</p>
<p class="method-desc">Check if a member exists in a set.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if the member is in the set</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_scard</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">int lua_scard(const std::string&amp; key)</p>
<p class="method-desc">Get the number of members in a set.</p>
<p class="method-returns"><strong>Returns:</strong> Member count, or <code>0</code> if key doesn't exist</p>
</div>

<h4 id="sdk-t2-cache-hashes">Hashes</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_hset</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_hset(const std::string&amp; key, const std::string&amp; field, const std::string&amp; value)</p>
<p class="method-desc">Set a field in a hash. Creates the hash if it doesn't exist.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> on success</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_hget</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">std::string lua_hget(const std::string&amp; key, const std::string&amp; field)</p>
<p class="method-desc">Get the value of a hash field.</p>
<p class="method-returns"><strong>Returns:</strong> The value, or empty string if field or key doesn't exist</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_hdel</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_hdel(const std::string&amp; key, const std::string&amp; field)</p>
<p class="method-desc">Delete a field from a hash.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if the field was removed</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_hlen</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">int lua_hlen(const std::string&amp; key)</p>
<p class="method-desc">Get the number of fields in a hash.</p>
<p class="method-returns"><strong>Returns:</strong> Field count, or <code>0</code> if key doesn't exist</p>
</div>

<h4 id="sdk-t2-cache-ttl">TTL / Expiry</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_expire</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_expire(const std::string&amp; key, int seconds)</p>
<p class="method-desc">Set a TTL on a key. The key is automatically deleted after the timeout.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if the timeout was set, <code>false</code> if key doesn't exist</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_ttl</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">int lua_ttl(const std::string&amp; key)</p>
<p class="method-desc">Get the remaining time-to-live of a key in seconds.</p>
<p class="method-returns"><strong>Returns:</strong> Seconds remaining, <code>-1</code> if key has no TTL, <code>-2</code> if key doesn't exist</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">lua_persist</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool lua_persist(const std::string&amp; key)</p>
<p class="method-desc">Remove the TTL from a key, making it persistent.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if the timeout was removed, <code>false</code> if key doesn't exist or had no TTL</p>
</div>

<h4 id="sdk-t2-cache-pubsub">Pub/Sub</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">publish</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">int publish(const std::string&amp; channel, const std::string&amp; message)</p>
<p class="method-desc">Publish a message to a channel. All clients subscribed to the channel (via SUBSCRIBE command or Lua <code>socketley.subscribe()</code>) receive the message.</p>
<p class="method-returns"><strong>Returns:</strong> Number of subscribers that received the message</p>
</div>

<h5>Receiving Published Messages</h5>
<p>The <code>publish()</code> method above sends messages. To <strong>receive</strong> them, use one of these approaches:</p>

<table>
<thead><tr><th>Method</th><th>How</th><th>Best for</th></tr></thead>
<tbody>
<tr><td>Lua callback</td><td><code>socketley.subscribe(cache_name, channel, fn)</code> in any runtime's Lua script</td><td>Cross-runtime event handling (recommended)</td></tr>
<tr><td>RESP client</td><td>Connect via TCP, send <code>SUBSCRIBE channel</code>, receive RESP push messages</td><td>External Redis-compatible clients</td></tr>
<tr><td>Text-mode client</td><td>Connect via TCP, send <code>subscribe channel</code>, receive <code>message &lt;channel&gt; &lt;payload&gt;\n</code></td><td>Simple scripting / netcat</td></tr>
</tbody>
</table>

<div class="info-box"><strong>Lua is the primary receive mechanism.</strong> Tier 1 SDK (IPC) cannot receive async push messages &mdash; it's request/response only. Use <code>socketley.subscribe()</code> in a Lua script attached to any runtime to react to published messages. See <a href="#addons-pubsub">Cross-Runtime Pub/Sub</a> for the full API.</div>

<p><strong>Example:</strong> A server that broadcasts cache events to all TCP clients:</p>
<pre><code><span class="cm">-- notify.lua (attach to a server runtime)</span>
<span class="kw">function</span> <span class="fn">on_start</span>()
    socketley.<span class="fn">subscribe</span>(<span class="st">"store"</span>, <span class="st">"events"</span>, <span class="kw">function</span>(ch, msg)
        self.<span class="fn">broadcast</span>(<span class="st">"event: "</span> .. msg)
    <span class="kw">end</span>)
<span class="kw">end</span></code></pre>

<h4 id="sdk-t2-cache-mgmt">Management</h4>

<div class="method-card">
<div class="method-header">
  <span class="method-name">get_size</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">uint32_t get_size()</p>
<p class="method-desc">Get the total number of keys in the cache store.</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">store_memory_used</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">size_t store_memory_used()</p>
<p class="method-desc">Get the approximate memory used by the cache store in bytes.</p>
</div>

<div class="method-card">
<div class="method-header">
  <span class="method-name">flush_to / load_from</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">bool flush_to(std::string_view path)</p>
<p class="method-sig">bool load_from(std::string_view path)</p>
<p class="method-desc">Save or load the entire cache to/from a binary snapshot file. Requires admin mode.</p>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> on success</p>
</div>

<h4 id="sdk-t2-cache-textproto">Text-Protocol Command Reference</h4>
<p>The cache runtime supports 40+ commands via the text protocol (line-based, newline-delimited) and RESP2 (Redis wire protocol). Both protocols support the same command set. Text protocol is used by default; RESP2 is auto-detected or forced with <code>--resp-forced</code>.</p>
<p>Access these commands via TCP connections, <code>execute()</code> in Tier 2 code, or interactive mode (<code>-i</code> flag):</p>

<div class="method-card">
<div class="method-header">
  <span class="method-name">execute</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-sig">std::string execute(const std::string&amp; command)</p>
<p class="method-desc">Execute a text-protocol command string directly on the cache instance and return the response. Bypasses the network layer.</p>
<pre><code>std::string val  = cache-&gt;<span class="fn">execute</span>(<span class="st">"INCR counter"</span>);       <span class="cm">// "1"</span>
std::string list = cache-&gt;<span class="fn">execute</span>(<span class="st">"LRANGE mylist 0 -1"</span>); <span class="cm">// "a\nb\nc"</span>
std::string info = cache-&gt;<span class="fn">execute</span>(<span class="st">"DBSIZE"</span>);              <span class="cm">// "42"</span></code></pre>
</div>

<h5>Strings</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>SET</code></td><td><code>SET key value [EX s] [PX ms] [NX|XX]</code></td><td>Set value with optional expiry and condition flags</td></tr>
<tr><td><code>GET</code></td><td><code>GET key</code></td><td>Get string value</td></tr>
<tr><td><code>DEL</code></td><td><code>DEL key</code></td><td>Delete key</td></tr>
<tr><td><code>EXISTS</code></td><td><code>EXISTS key</code></td><td>Check if key exists (1/0)</td></tr>
<tr><td><code>INCR</code></td><td><code>INCR key</code></td><td>Increment integer value by 1</td></tr>
<tr><td><code>DECR</code></td><td><code>DECR key</code></td><td>Decrement integer value by 1</td></tr>
<tr><td><code>INCRBY</code></td><td><code>INCRBY key delta</code></td><td>Increment by arbitrary integer</td></tr>
<tr><td><code>DECRBY</code></td><td><code>DECRBY key delta</code></td><td>Decrement by arbitrary integer</td></tr>
<tr><td><code>APPEND</code></td><td><code>APPEND key suffix</code></td><td>Append to string, returns new length</td></tr>
<tr><td><code>STRLEN</code></td><td><code>STRLEN key</code></td><td>Get string length</td></tr>
<tr><td><code>GETSET</code></td><td><code>GETSET key value</code></td><td>Set value and return old value</td></tr>
<tr><td><code>MGET</code></td><td><code>MGET key [key ...]</code></td><td>Get multiple values</td></tr>
<tr><td><code>MSET</code></td><td><code>MSET key value [key value ...]</code></td><td>Set multiple key-value pairs</td></tr>
<tr><td><code>SETNX</code></td><td><code>SETNX key value</code></td><td>Set only if key does not exist</td></tr>
<tr><td><code>SETEX</code></td><td><code>SETEX key seconds value</code></td><td>Set with expiry in seconds</td></tr>
<tr><td><code>PSETEX</code></td><td><code>PSETEX key ms value</code></td><td>Set with expiry in milliseconds</td></tr>
</tbody>
</table>

<h5>Lists</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>LPUSH</code></td><td><code>LPUSH key value</code></td><td>Push to head</td></tr>
<tr><td><code>RPUSH</code></td><td><code>RPUSH key value</code></td><td>Push to tail</td></tr>
<tr><td><code>LPOP</code></td><td><code>LPOP key</code></td><td>Pop from head</td></tr>
<tr><td><code>RPOP</code></td><td><code>RPOP key</code></td><td>Pop from tail</td></tr>
<tr><td><code>LLEN</code></td><td><code>LLEN key</code></td><td>List length</td></tr>
<tr><td><code>LINDEX</code></td><td><code>LINDEX key index</code></td><td>Get element by index</td></tr>
<tr><td><code>LRANGE</code></td><td><code>LRANGE key start stop</code></td><td>Get range of elements (0-based, -1 = last)</td></tr>
</tbody>
</table>

<h5>Sets</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>SADD</code></td><td><code>SADD key member</code></td><td>Add member to set</td></tr>
<tr><td><code>SREM</code></td><td><code>SREM key member</code></td><td>Remove member from set</td></tr>
<tr><td><code>SISMEMBER</code></td><td><code>SISMEMBER key member</code></td><td>Check membership (1/0)</td></tr>
<tr><td><code>SCARD</code></td><td><code>SCARD key</code></td><td>Set cardinality</td></tr>
<tr><td><code>SMEMBERS</code></td><td><code>SMEMBERS key</code></td><td>List all members</td></tr>
</tbody>
</table>

<h5>Hashes</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>HSET</code></td><td><code>HSET key field value</code></td><td>Set hash field</td></tr>
<tr><td><code>HGET</code></td><td><code>HGET key field</code></td><td>Get hash field value</td></tr>
<tr><td><code>HDEL</code></td><td><code>HDEL key field</code></td><td>Delete hash field</td></tr>
<tr><td><code>HLEN</code></td><td><code>HLEN key</code></td><td>Number of fields in hash</td></tr>
<tr><td><code>HGETALL</code></td><td><code>HGETALL key</code></td><td>Get all field-value pairs</td></tr>
</tbody>
</table>

<h5>TTL / Expiry</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>EXPIRE</code></td><td><code>EXPIRE key seconds</code></td><td>Set TTL in seconds</td></tr>
<tr><td><code>PEXPIRE</code></td><td><code>PEXPIRE key ms</code></td><td>Set TTL in milliseconds</td></tr>
<tr><td><code>TTL</code></td><td><code>TTL key</code></td><td>Remaining TTL in seconds (-1 = no TTL, -2 = missing)</td></tr>
<tr><td><code>PTTL</code></td><td><code>PTTL key</code></td><td>Remaining TTL in milliseconds</td></tr>
<tr><td><code>PERSIST</code></td><td><code>PERSIST key</code></td><td>Remove TTL</td></tr>
<tr><td><code>EXPIREAT</code></td><td><code>EXPIREAT key timestamp</code></td><td>Set expiry at Unix timestamp (seconds)</td></tr>
<tr><td><code>PEXPIREAT</code></td><td><code>PEXPIREAT key timestamp</code></td><td>Set expiry at Unix timestamp (milliseconds)</td></tr>
</tbody>
</table>

<h5>Query &amp; Introspection</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>TYPE</code></td><td><code>TYPE key</code></td><td>Returns <code>"string"</code>, <code>"list"</code>, <code>"set"</code>, <code>"hash"</code>, or <code>"none"</code></td></tr>
<tr><td><code>KEYS</code></td><td><code>KEYS pattern</code></td><td>Find keys matching glob pattern (<code>*</code>, <code>?</code>)</td></tr>
<tr><td><code>SCAN</code></td><td><code>SCAN cursor [MATCH pattern] [COUNT n]</code></td><td>Incrementally iterate keys (cursor-based)</td></tr>
<tr><td><code>DBSIZE</code></td><td><code>DBSIZE</code></td><td>Total key count</td></tr>
</tbody>
</table>

<h5>Pub/Sub</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>PUBLISH</code></td><td><code>PUBLISH channel message</code></td><td>Publish to channel, returns subscriber count</td></tr>
<tr><td><code>SUBSCRIBE</code></td><td><code>SUBSCRIBE channel</code></td><td>Subscribe to channel (push mode)</td></tr>
<tr><td><code>UNSUBSCRIBE</code></td><td><code>UNSUBSCRIBE channel</code></td><td>Unsubscribe from channel</td></tr>
</tbody>
</table>

<h5>Admin</h5>
<table>
<thead><tr><th>Command</th><th>Syntax</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>PING</code></td><td><code>PING</code></td><td>Returns <code>PONG</code></td></tr>
<tr><td><code>INFO</code></td><td><code>INFO</code></td><td>Server info (keys, memory, connections, uptime)</td></tr>
<tr><td><code>MEMORY</code></td><td><code>MEMORY</code></td><td>Max and used memory</td></tr>
<tr><td><code>FLUSH</code></td><td><code>FLUSH [path]</code></td><td>Save snapshot to disk (admin mode)</td></tr>
<tr><td><code>LOAD</code></td><td><code>LOAD [path]</code></td><td>Load snapshot from disk (admin mode)</td></tr>
</tbody>
</table>

<h3 id="sdk-t2-proxy">proxy_instance</h3>
<p><code>#include &lt;socketley/proxy.h&gt;</code> &mdash; HTTP or TCP reverse proxy with load balancing.</p>

<h4>Protocol &amp; Strategy</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_protocol(proxy_protocol)</code></td><td><code>protocol_http</code> or <code>protocol_tcp</code></td></tr>
<tr><td><code>set_strategy(proxy_strategy)</code></td><td><code>strategy_round_robin</code>, <code>strategy_random</code>, <code>strategy_lua</code></td></tr>
</tbody>
</table>

<h4>Backends</h4>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>add_backend(string_view addr)</code></td><td>Add backend (<code>"host:port"</code> or <code>"@group"</code> for dynamic discovery)</td></tr>
<tr><td><code>clear_backends()</code></td><td>Remove all backends</td></tr>
<tr><td><code>get_backends()</code></td><td>Get current backend list</td></tr>
</tbody>
</table>

<h3 id="sdk-t2-client">client_instance</h3>
<p><code>#include &lt;socketley/client.h&gt;</code> &mdash; TCP or UDP client that connects to a remote server.</p>

<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>set_mode(client_mode)</code></td><td><code>client_mode_inout</code>, <code>client_mode_in</code>, <code>client_mode_out</code></td></tr>
<tr><td><code>set_udp(bool)</code></td><td>Use UDP datagrams</td></tr>
<tr><td><code>set_target(string_view)</code></td><td>Target address (<code>"host:port"</code>)</td></tr>
<tr><td><code>set_reconnect(int)</code></td><td>Reconnect attempts (-1 = disabled, 0 = infinite)</td></tr>
<tr><td><code>lua_send(string_view msg)</code></td><td>Send data to the connected server</td></tr>
</tbody>
</table>

<h3 id="sdk-t2-enums">Enums &amp; Constants</h3>
<pre><code><span class="cm">// Runtime types</span>
<span class="kw">enum</span> runtime_type  { runtime_server, runtime_client, runtime_proxy, runtime_cache };
<span class="kw">enum</span> runtime_state { runtime_created, runtime_running, runtime_stopped, runtime_failed };

<span class="cm">// Server modes</span>
<span class="kw">enum</span> server_mode { mode_inout, mode_in, mode_out, mode_master };

<span class="cm">// Cache modes</span>
<span class="kw">enum</span> cache_mode { cache_mode_readonly, cache_mode_readwrite, cache_mode_admin };

<span class="cm">// Cache eviction</span>
<span class="kw">enum</span> eviction_policy { evict_none, evict_allkeys_lru, evict_allkeys_random };

<span class="cm">// Proxy settings</span>
<span class="kw">enum</span> proxy_protocol { protocol_http, protocol_tcp };
<span class="kw">enum</span> proxy_strategy { strategy_round_robin, strategy_random, strategy_lua };

<span class="cm">// Client modes</span>
<span class="kw">enum</span> client_mode { client_mode_inout, client_mode_in, client_mode_out };</code></pre>

<!-- ══════════════════════════════════════════════════════════════
     TIER 3: DAEMON ATTACH
══════════════════════════════════════════════════════════════ -->
<h2 id="sdk-t3">Tier 3: Daemon Attach</h2>
<p><code>#include &lt;socketley/attach.h&gt;</code> &mdash; header-only, zero dependencies. Register your own process as a runtime in a running daemon.</p>

<h3 id="sdk-t3-api">API</h3>

<div class="method-card" id="sdk-attach">
<div class="method-header">
  <span class="method-name">daemon_attach</span>
  <span class="badge badge-tier3">Tier 3</span>
</div>
<p class="method-sig">bool socketley::daemon_attach(const std::string&amp; name, const std::string&amp; type, uint16_t port)</p>
<p class="method-desc">Register the current process with the daemon. After calling, your process appears in <code>socketley ls</code>, <code>socketley stats</code>, and <code>socketley ps</code>. Automatically deregisters on <code>exit()</code> via <code>atexit()</code>.</p>
<table>
<thead><tr><th>Parameter</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code></td><td>Name to register under</td></tr>
<tr><td><code>type</code></td><td><code>"server"</code>, <code>"client"</code>, <code>"proxy"</code>, or <code>"cache"</code></td></tr>
<tr><td><code>port</code></td><td>Port your service is listening on</td></tr>
</tbody>
</table>
<p class="method-returns"><strong>Returns:</strong> <code>true</code> if daemon accepted the registration, <code>false</code> if daemon not running (service works standalone)</p>
</div>

<div class="method-card" id="sdk-detach">
<div class="method-header">
  <span class="method-name">daemon_detach</span>
  <span class="badge badge-tier3">Tier 3</span>
</div>
<p class="method-sig">void socketley::daemon_detach(const std::string&amp; name)</p>
<p class="method-sig">void socketley::daemon_detach()</p>
<p class="method-desc">Explicitly deregister a runtime. The no-argument form deregisters the name from the last <code>daemon_attach()</code> call.</p>
</div>

<h3 id="sdk-t3-lifecycle">Lifecycle</h3>
<p>The typical Tier 3 pattern:</p>
<ol>
<li>Start your own server (any framework, any language with C++ FFI)</li>
<li>Call <code>daemon_attach()</code> &mdash; registers with daemon</li>
<li>Run your accept loop / event loop</li>
<li>On shutdown: <code>daemon_detach()</code> is called automatically via <code>atexit()</code></li>
</ol>

<div class="info-box"><strong>Graceful degradation:</strong> If the daemon isn't running, <code>daemon_attach()</code> returns <code>false</code> and your service continues working in standalone mode. This makes Tier 3 safe to use unconditionally.</div>

<!-- ══════════════════════════════════════════════════════════════
     PATTERNS & BEST PRACTICES
══════════════════════════════════════════════════════════════ -->
<h2 id="sdk-patterns">Patterns &amp; Best Practices</h2>

<h3 id="sdk-pat-mixed">Mixed: Tier 2 + Tier 3</h3>
<p>Embed the full engine for maximum performance, then register with the daemon for fleet visibility:</p>
<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/server.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;socketley/attach.h&gt;</span>

<span class="cm">// ... event_loop + runtime_manager setup ...</span>

mgr.<span class="fn">start</span>(<span class="st">"my_server"</span>, loop);

<span class="cm">// Register with daemon (Tier 3)</span>
socketley::<span class="fn">daemon_attach</span>(<span class="st">"my_server"</span>, <span class="st">"server"</span>, <span class="nb">9000</span>);

<span class="cm">// Now: socketley ls shows my_server</span>
<span class="cm">// Now: socketley stats my_server works</span>
loop.<span class="fn">run</span>();
<span class="cm">// daemon_detach() called automatically via atexit()</span></code></pre>

<div class="info-box"><strong>Multiple runtimes:</strong> <code>daemon_attach()</code> can only auto-detach one name via <code>atexit()</code>. For additional runtimes, use <code>socketley::ctl::command("attach ...")</code> and manually detach on shutdown.</div>

<h3 id="sdk-pat-signals">Signal Handling</h3>
<pre><code><span class="cm">// Always ignore SIGPIPE — io_uring writes CAN trigger it</span>
signal(SIGPIPE, SIG_IGN);

<span class="cm">// Use a global event_loop pointer for signal handlers</span>
<span class="kw">static</span> event_loop* g_loop = <span class="kw">nullptr</span>;
<span class="cm">// ... after init ...</span>
g_loop = &amp;loop;

<span class="cm">// Graceful shutdown on Ctrl-C / kill</span>
signal(SIGINT,  [](<span class="kw">int</span>) { <span class="kw">if</span> (g_loop) g_loop-&gt;<span class="fn">request_stop</span>(); });
signal(SIGTERM, [](<span class="kw">int</span>) { <span class="kw">if</span> (g_loop) g_loop-&gt;<span class="fn">request_stop</span>(); });</code></pre>
<div class="warn-box"><strong>SIGPIPE is critical.</strong> Without <code>signal(SIGPIPE, SIG_IGN)</code>, a disconnected client can kill your entire process when io_uring delivers a write to a closed socket.</div>

<h3 id="sdk-pat-lua">Lua Integration</h3>
<p>Tier 2 runtimes can load Lua scripts just like daemon-managed runtimes. The Lua callbacks and C++ callbacks work together &mdash; C++ callbacks fire first, then Lua callbacks (if both are set).</p>
<pre><code><span class="kw">auto</span>* srv = <span class="kw">static_cast</span>&lt;server_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"chat"</span>));

<span class="cm">// Try loading Lua script</span>
<span class="kw">bool</span> lua_ok = srv-&gt;<span class="fn">load_lua_script</span>(<span class="st">"chat.lua"</span>);
<span class="kw">if</span> (!lua_ok) {
    <span class="cm">// Fallback to C++ callbacks</span>
    srv-&gt;<span class="fn">set_on_client_message</span>([srv](<span class="kw">int</span>, std::string_view msg) {
        srv-&gt;<span class="fn">lua_broadcast</span>(msg);
    });
}</code></pre>
<div class="info-box">Build with <code>-lluajit</code> to enable Lua support, or define <code>SOCKETLEY_NO_LUA</code> to compile without it.</div>

<h3 id="sdk-pat-choosing">Choosing a Tier</h3>
<table>
<thead><tr><th>Use Case</th><th>Tier</th><th>Why</th></tr></thead>
<tbody>
<tr><td>Deployment scripts, CI/CD</td><td><span class="badge badge-tier1">Tier 1</span></td><td>Header-only, zero deps, simple API</td></tr>
<tr><td>Monitoring dashboards</td><td><span class="badge badge-tier1">Tier 1</span></td><td>Query stats, list runtimes</td></tr>
<tr><td>Custom game server</td><td><span class="badge badge-tier2">Tier 2</span></td><td>Full control, max performance, C++ callbacks</td></tr>
<tr><td>IoT gateway</td><td><span class="badge badge-tier2">Tier 2</span></td><td>Embed engine, multiple protocols</td></tr>
<tr><td>Legacy service integration</td><td><span class="badge badge-tier3">Tier 3</span></td><td>Register existing service with daemon fleet</td></tr>
<tr><td>Microservice with monitoring</td><td><span class="badge badge-mixed">Mixed</span></td><td>Embedded engine + daemon visibility</td></tr>
</tbody>
</table>

</div><!-- #content-socketley-sdk -->

<!-- ═══════════════════════════════════════════
     LUA TAB CONTENT
═══════════════════════════════════════════ -->
<div id="content-lua" class="content" style="display:none">

<h2 id="lua-scripting">Lua Scripting</h2>
<p>Socketley embeds LuaJIT via sol2. Scripts attach to runtimes and can define lifecycle callbacks, call runtime action methods, and manage other runtimes programmatically.</p>

<h3 id="lua-attaching">Attaching Scripts</h3>
<pre><code><span class="cm"># Per-runtime script</span>
socketley create server myserver -p 9000 --lua handler.lua -s

<span class="cm"># Orchestration script (defines runtimes table)</span>
socketley --lua setup.lua

<span class="cm"># Hot-reload without restarting</span>
socketley reload-lua myserver</code></pre>

<h3 id="lua-bindings">How Bindings Work</h3>
<div class="info-box"><strong>Binding order:</strong> <code>register_bindings()</code> runs <em>before</em> script execution. The <code>self</code>, <code>socketley</code>, and type-alias tables are already available at the top level of your script.</div>
<ol>
<li>Fresh LuaJIT state with <code>base</code>, <code>string</code>, <code>table</code>, <code>math</code>, <code>os</code> libs</li>
<li>Registers <code>socketley</code> namespace (log, create, start, stop, remove, send, list, get)</li>
<li>Registers <code>self</code> table with runtime properties and type-specific action methods</li>
<li>Registers a type alias (<code>server</code> / <code>client</code> / <code>cache</code> / <code>proxy</code>) pointing to the same <code>self</code> table</li>
<li>Executes the script, then captures any defined callback functions</li>
</ol>

<h3 id="lua-globals">Globals &amp; self</h3>
<h4>self Table (read-only properties)</h4>
<table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>self.name</td><td>string</td><td>Runtime name</td></tr>
<tr><td>self.port</td><td>number</td><td>Port number (0 = internal-only)</td></tr>
<tr><td>self.type</td><td>string</td><td><code>"server"</code>, <code>"client"</code>, <code>"cache"</code>, <code>"proxy"</code></td></tr>
<tr><td>self.state</td><td>string</td><td><code>"created"</code>, <code>"running"</code>, <code>"stopped"</code>, <code>"failed"</code></td></tr>
<tr><td>self.protocol</td><td>string</td><td><code>"tcp"</code> or <code>"udp"</code> (server/client)</td></tr>
</tbody></table>

<div class="method-card">
<div class="method-header"><span class="method-name">socketley.log</span><span class="method-sig">(msg)</span><span class="badge badge-all">all types</span></div>
<div class="method-desc">Write to stderr with <code>[lua]</code> prefix. Useful for debugging.</div>
</div>

<h2 id="callbacks">Lua Callbacks</h2>
<p>Define global functions to react to lifecycle events. All are optional. <code>self.state</code> is updated before each callback fires.</p>

<div class="callback-card" id="cb-on-start">
<div class="method-header"><span class="method-name">on_start()</span><span class="badge badge-all">all types</span></div>
<div class="fires">Fires when runtime enters <code>running</code> state. Also fires again on reconnect (client).</div>
<pre><code><span class="kw">function</span> <span class="fn">on_start</span>()
    socketley.log(self.name .. <span class="st">" started on port "</span> .. tostring(self.port))
<span class="kw">end</span></code></pre>
</div>

<div class="callback-card" id="cb-on-stop">
<div class="method-header"><span class="method-name">on_stop()</span><span class="badge badge-all">all types</span></div>
<div class="fires">Fires when runtime enters <code>stopped</code> state.</div>
</div>

<div class="callback-card" id="cb-on-message">
<div class="method-header"><span class="method-name">on_message(msg)</span><span class="badge badge-server">server</span><span class="badge badge-client">client</span><span class="badge badge-cache">cache</span></div>
<div class="fires">Fires on each received message. Trailing newline is stripped.</div>
<pre><code><span class="kw">function</span> <span class="fn">on_message</span>(msg)
    self.broadcast(<span class="st">"[echo] "</span> .. msg)
<span class="kw">end</span></code></pre>
</div>

<div class="callback-card" id="cb-on-client-message">
<div class="method-header"><span class="method-name">on_client_message(client_id, msg)</span><span class="badge badge-server">server</span></div>
<div class="fires">Fires with the sender's client_id. Fires <em>alongside</em> <code>on_message</code> (not instead of).</div>
<pre><code><span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="kw">if</span> msg == <span class="st">"whoami"</span> <span class="kw">then</span>
        self.send(client_id, <span class="st">"You are client #"</span> .. tostring(client_id))
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
</div>

<div class="callback-card" id="cb-on-connect">
<div class="method-header"><span class="method-name">on_connect(client_id)</span><span class="badge badge-server">server</span><span class="badge badge-cache">cache</span></div>
<div class="fires">Fires when a client connects. <code>client_id</code> is the file descriptor.</div>
</div>

<div class="callback-card" id="cb-on-disconnect">
<div class="method-header"><span class="method-name">on_disconnect(client_id)</span><span class="badge badge-server">server</span><span class="badge badge-cache">cache</span></div>
<div class="fires">Fires when a client disconnects.</div>
</div>

<div class="callback-card" id="cb-on-send">
<div class="method-header"><span class="method-name">on_send(msg)</span><span class="badge badge-server">server</span><span class="badge badge-client">client</span></div>
<div class="fires">Fires after a message is sent or broadcast.</div>
</div>

<div class="callback-card" id="cb-on-tick">
<div class="method-header"><span class="method-name">on_tick(dt)</span><span class="badge badge-all">all types</span></div>
<div class="fires">Fires at a configurable interval while the runtime is running. <code>dt</code> is the actual elapsed time in milliseconds since the last tick (double). Requires a top-level <code>tick_ms</code> global (minimum 10&nbsp;ms, default 100&nbsp;ms if omitted). Self-rescheduling — if Lua is slow, ticks do not queue.</div>
<pre><code>tick_ms = <span class="nb">50</span>   <span class="cm">-- fire every ~50 ms</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    self.broadcast(<span class="st">"ping"</span>)
    socketley.log(<span class="st">"tick dt="</span> .. tostring(dt))
<span class="kw">end</span></code></pre>
</div>

<div class="callback-card" id="cb-on-route">
<div class="method-header"><span class="method-name">on_route(method, path)</span><span class="badge badge-proxy">proxy</span></div>
<div class="fires">Fires for each HTTP request when strategy is <code>"lua"</code>.</div>
<div class="method-returns"><strong>Returns:</strong> number (0-based backend index) or nil (use default strategy)</div>
<pre><code><span class="kw">function</span> <span class="fn">on_route</span>(method, path)
    <span class="kw">if</span> path:match(<span class="st">"^/api/"</span>) <span class="kw">then</span> <span class="kw">return</span> <span class="nb">0</span> <span class="kw">end</span>
    <span class="kw">return</span> <span class="kw">nil</span>
<span class="kw">end</span></code></pre>
</div>

<div class="callback-card" id="cb-on-master-auth">
<div class="method-header"><span class="method-name">on_master_auth(client_id, password)</span><span class="badge badge-server">server</span></div>
<div class="fires">Fires when a client sends <code>master &lt;password&gt;</code>. If defined, overrides <code>--master-pw</code>.</div>
<div class="method-returns"><strong>Returns:</strong> boolean — true to grant master role</div>
</div>

<h2 id="server-api">Lua Server API</h2>

<div class="method-card" id="srv-broadcast">
<div class="method-header"><span class="method-name">self.broadcast</span><span class="method-sig">(msg)</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Send to <strong>all</strong> connected clients. Newline appended automatically. WebSocket clients receive a framed text message.</div>
</div>
<div class="method-card" id="srv-send">
<div class="method-header"><span class="method-name">self.send</span><span class="method-sig">(client_id, msg)</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Send to a <strong>specific</strong> client by file descriptor.</div>
</div>
<div class="method-card" id="srv-connections">
<div class="method-header"><span class="method-name">self.connections</span><span class="method-sig">() &rarr; number</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Current connected client count.</div>
</div>

<h3 id="srv-master">Master Mode</h3>
<p>With <code>--mode master</code>, one authenticated client becomes the broadcaster. Others are silenced (or forwarded via <code>--master-forward</code>). Auth via <code>--master-pw</code> or the <code>on_master_auth</code> callback.</p>

<h2 id="client-api">Lua Client API</h2>

<div class="method-card" id="cli-send">
<div class="method-header"><span class="method-name">self.send</span><span class="method-sig">(msg)</span><span class="badge badge-client">client</span></div>
<div class="method-desc">Send a message to the connected server.</div>
</div>
<div class="method-card" id="cli-connections">
<div class="method-header"><span class="method-name">self.connections</span><span class="method-sig">() &rarr; number</span><span class="badge badge-client">client</span></div>
<div class="method-desc"><code>0</code> = disconnected, <code>1</code> = connected.</div>
</div>

<div class="info-box"><strong>Auto-reconnect:</strong> Enable with <code>--reconnect [max]</code>. Uses exponential backoff. <code>on_start</code> fires again on each successful reconnect.</div>

<h2 id="cache-api">Lua Cache API</h2>
<p>Direct in-memory access from Lua — no TCP round-trip. Use from a cache runtime's own script, or from a server script linked with <code>--cache &lt;name&gt;</code>.</p>
<div class="warn-box"><strong>Type enforcement:</strong> One type per key. Use <code>self.del(key)</code> to clear before changing type.</div>

<h3 id="cache-strings">Strings</h3>
<div class="method-card"><div class="method-header"><span class="method-name">self.set</span><span class="method-sig">(key, value) &rarr; boolean</span><span class="badge badge-cache">cache</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">self.get</span><span class="method-sig">(key) &rarr; string</span><span class="badge badge-cache">cache</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">self.del</span><span class="method-sig">(key) &rarr; boolean</span><span class="badge badge-cache">cache</span></div></div>

<h3 id="cache-lists">Lists</h3>
<div class="method-card"><div class="method-header"><span class="method-name">self.lpush / self.rpush</span><span class="method-sig">(key, value) &rarr; boolean</span><span class="badge badge-cache">cache</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">self.lpop / self.rpop</span><span class="method-sig">(key) &rarr; string</span><span class="badge badge-cache">cache</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">self.llen</span><span class="method-sig">(key) &rarr; number</span><span class="badge badge-cache">cache</span></div></div>

<h3 id="cache-sets">Sets</h3>
<div class="method-card"><div class="method-header"><span class="method-name">self.sadd</span><span class="method-sig">(key, member) &rarr; number</span><span class="badge badge-cache">cache</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">self.srem</span><span class="method-sig">(key, member) &rarr; boolean</span><span class="badge badge-cache">cache</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">self.sismember</span><span class="method-sig">(key, member) &rarr; boolean</span><span class="badge badge-cache">cache</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">self.scard</span><span class="method-sig">(key) &rarr; number</span><span class="badge badge-cache">cache</span></div></div>

<h3 id="cache-hashes">Hashes</h3>
<div class="method-card"><div class="method-header"><span class="method-name">self.hset</span><span class="method-sig">(key, field, value) &rarr; boolean</span><span class="badge badge-cache">cache</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">self.hget</span><span class="method-sig">(key, field) &rarr; string</span><span class="badge badge-cache">cache</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">self.hdel</span><span class="method-sig">(key, field) &rarr; boolean</span><span class="badge badge-cache">cache</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">self.hlen</span><span class="method-sig">(key) &rarr; number</span><span class="badge badge-cache">cache</span></div></div>

<h3 id="cache-ttl">TTL / Expiry</h3>
<div class="method-card"><div class="method-header"><span class="method-name">self.expire</span><span class="method-sig">(key, seconds) &rarr; boolean</span><span class="badge badge-cache">cache</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">self.ttl</span><span class="method-sig">(key) &rarr; number</span><span class="badge badge-cache">cache</span></div>
<div class="method-desc"><code>-1</code> = no TTL set, <code>-2</code> = key not found.</div></div>
<div class="method-card"><div class="method-header"><span class="method-name">self.persist</span><span class="method-sig">(key) &rarr; boolean</span><span class="badge badge-cache">cache</span></div></div>

<h3 id="cache-pubsub">Pub/Sub</h3>
<div class="method-card"><div class="method-header"><span class="method-name">self.publish</span><span class="method-sig">(channel, message) &rarr; number</span><span class="badge badge-cache">cache</span></div>
<div class="method-desc">Publish to a channel. Returns the subscriber count.</div></div>

<h2 id="proxy-api">Lua Proxy API</h2>

<div class="method-card" id="proxy-connections">
<div class="method-header"><span class="method-name">self.connections</span><span class="method-sig">() &rarr; number</span><span class="badge badge-proxy">proxy</span></div>
<div class="method-desc">Current active connection count through the proxy.</div>
</div>

<h3 id="proxy-routing">Lua Routing</h3>
<p>Set strategy to <code>"lua"</code> and define <code>on_route</code>. Backends are 0-indexed. Return <code>nil</code> to fall back to the default strategy.</p>

<h2 id="runtime-mgmt">Runtime Management API</h2>
<p>Manage other runtimes from within a Lua script using the <code>socketley</code> namespace.</p>

<div class="method-card" id="mgmt-create">
<div class="method-header"><span class="method-name">socketley.create</span><span class="method-sig">(type, name, config?) &rarr; boolean</span><span class="badge badge-all">all</span></div>
<div class="method-desc">Config keys: <code>port</code>, <code>lua</code>/<code>config</code>, <code>target</code>, <code>mode</code>, <code>on_parent_stop</code> (<code>"stop"</code>|<code>"remove"</code>), <code>start</code>.</div>
</div>
<div class="method-card"><div class="method-header"><span class="method-name">socketley.start</span><span class="method-sig">(name) &rarr; boolean</span><span class="badge badge-all">all</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">socketley.stop</span><span class="method-sig">(name) &rarr; boolean</span><span class="badge badge-all">all</span></div></div>
<div class="method-card"><div class="method-header"><span class="method-name">socketley.remove</span><span class="method-sig">(name) &rarr; boolean</span><span class="badge badge-all">all</span></div></div>

<div class="method-card" id="mgmt-send">
<div class="method-header"><span class="method-name">socketley.send</span><span class="method-sig">(name, msg) &rarr; boolean</span><span class="badge badge-all">all</span></div>
</div>
<div class="method-card">
<div class="method-header"><span class="method-name">socketley.list</span><span class="method-sig">() &rarr; table</span><span class="badge badge-all">all</span></div>
<div class="method-desc">Returns an array of all runtime names.</div>
</div>
<div class="method-card">
<div class="method-header"><span class="method-name">socketley.get</span><span class="method-sig">(name) &rarr; table or nil</span><span class="badge badge-all">all</span></div>
<div class="method-desc">Returns <code>{name, type, state, port, connections, owner}</code> or nil if not found.</div>
</div>

<h3 id="mgmt-ownership">Ownership</h3>
<p>Runtimes created via <code>socketley.create()</code> are owned by the calling runtime. Use <code>on_parent_stop = "remove"</code> to auto-remove children when the parent stops.</p>
<pre><code>socketley.create(<span class="st">"server"</span>, <span class="st">"worker"</span>, {
    port = <span class="nb">0</span>, lua = <span class="st">"worker.lua"</span>,
    on_parent_stop = <span class="st">"remove"</span>, start = <span class="kw">true</span>
})</code></pre>

<h2 id="client-routing">Client Routing</h2>
<p>Forward clients from a parent server to child sub-servers. Ideal for game lobbies, chat rooms, and microservice dispatch.</p>
<div class="info-box">Routed clients' messages go to the sub-server's <code>on_client_message</code>. Sub-servers reply with <code>owner_send</code> / <code>owner_broadcast</code>.</div>

<div class="method-card" id="route-route">
<div class="method-header"><span class="method-name">self.route</span><span class="method-sig">(client_id, target) &rarr; boolean</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Route a client to a named sub-server. Messages from that client will be forwarded.</div>
</div>
<div class="method-card">
<div class="method-header"><span class="method-name">self.unroute</span><span class="method-sig">(client_id) &rarr; boolean</span><span class="badge badge-server">server</span></div>
</div>
<div class="method-card">
<div class="method-header"><span class="method-name">self.get_route</span><span class="method-sig">(client_id) &rarr; string or nil</span><span class="badge badge-server">server</span></div>
</div>
<div class="method-card" id="route-owner-send">
<div class="method-header"><span class="method-name">self.owner_send</span><span class="method-sig">(client_id, msg) &rarr; boolean</span><span class="badge badge-server">server</span></div>
<div class="method-desc">From a sub-server, send to a specific client on the parent server.</div>
</div>
<div class="method-card">
<div class="method-header"><span class="method-name">self.owner_broadcast</span><span class="method-sig">(msg) &rarr; boolean</span><span class="badge badge-server">server</span></div>
<div class="method-desc">From a sub-server, broadcast to all clients on the parent server.</div>
</div>

<p>Port-0 sub-servers have no listener — they only receive messages via client routing from the parent.</p>

<h2 id="cluster-api">Cluster Introspection API</h2>
<p>When the daemon has cluster mode enabled (<code>daemon --name</code> + <code>daemon --cluster</code>), the <code>socketley.cluster</code> table provides read-only access to the full cluster topology. All functions return empty tables when not in cluster mode, so scripts work in both standalone and cluster setups without modification.</p>

<div class="info-box"><strong>Requires cluster mode.</strong> Enable with <code>socketley daemon --name &lt;n&gt; --cluster &lt;dir&gt;</code>. Remote daemons are discovered via JSON heartbeat files in the shared cluster directory. Discovery runs every 2&nbsp;seconds.</div>

<div class="method-card" id="cluster-daemons">
<div class="method-header"><span class="method-name">socketley.cluster.daemons</span><span class="method-sig">() &rarr; table</span><span class="badge badge-cluster">cluster</span></div>
<div class="method-desc">Returns an array of all daemons in the cluster. The local daemon is always the first entry.</div>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td>string</td><td>Daemon name (from <code>--name</code>)</td></tr>
<tr><td>host</td><td>string</td><td>Hostname (from <code>gethostname()</code>)</td></tr>
<tr><td>runtimes</td><td>number</td><td>Count of runtimes on this daemon</td></tr>
</tbody></table>
<pre><code><span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="kw">for</span> _, d <span class="kw">in</span> <span class="fn">ipairs</span>(socketley.cluster.daemons()) <span class="kw">do</span>
        socketley.log(d.name .. <span class="st">" @ "</span> .. d.host .. <span class="st">" ("</span> .. d.runtimes .. <span class="st">" runtimes)"</span>)
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
</div>

<div class="method-card" id="cluster-runtimes">
<div class="method-header"><span class="method-name">socketley.cluster.runtimes</span><span class="method-sig">() &rarr; table</span><span class="badge badge-cluster">cluster</span></div>
<div class="method-desc">Returns a flat array of every runtime across all daemons in the cluster (local + remote).</div>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>daemon</td><td>string</td><td>Hosting daemon name</td></tr>
<tr><td>name</td><td>string</td><td>Runtime name</td></tr>
<tr><td>type</td><td>string</td><td><code>"server"</code>, <code>"client"</code>, <code>"proxy"</code>, or <code>"cache"</code></td></tr>
<tr><td>port</td><td>number</td><td>Listen port (0 = internal-only)</td></tr>
<tr><td>group</td><td>string</td><td>Group tag (empty string if unset)</td></tr>
<tr><td>state</td><td>string</td><td><code>"created"</code>, <code>"running"</code>, <code>"stopped"</code>, or <code>"failed"</code></td></tr>
<tr><td>connections</td><td>number</td><td>Current connection count</td></tr>
</tbody></table>
</div>

<div class="method-card" id="cluster-group">
<div class="method-header"><span class="method-name">socketley.cluster.group</span><span class="method-sig">(name) &rarr; table</span><span class="badge badge-cluster">cluster</span></div>
<div class="method-desc">Returns running members of the named group that have a valid port. Useful for building custom routing, health checks, or failover logic.</div>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>daemon</td><td>string</td><td>Daemon name</td></tr>
<tr><td>host</td><td>string</td><td>Advertised address</td></tr>
<tr><td>port</td><td>number</td><td>Listen port</td></tr>
<tr><td>connections</td><td>number</td><td>Current connection count</td></tr>
</tbody></table>
<pre><code><span class="cm">-- Pick the least-loaded backend from the "api" group</span>
<span class="kw">local</span> members = socketley.cluster.group(<span class="st">"api"</span>)
<span class="kw">local</span> best = members[<span class="nb">1</span>]
<span class="kw">for</span> _, m <span class="kw">in</span> <span class="fn">ipairs</span>(members) <span class="kw">do</span>
    <span class="kw">if</span> m.connections &lt; best.connections <span class="kw">then</span> best = m <span class="kw">end</span>
<span class="kw">end</span>
socketley.log(<span class="st">"best backend: "</span> .. best.host .. <span class="st">":"</span> .. best.port)</code></pre>
</div>

<div class="method-card" id="cluster-stats">
<div class="method-header"><span class="method-name">socketley.cluster.stats</span><span class="method-sig">() &rarr; table</span><span class="badge badge-cluster">cluster</span></div>
<div class="method-desc">Returns aggregate cluster statistics in a single call.</div>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>daemons</td><td>number</td><td>Total daemon count (local + remote)</td></tr>
<tr><td>runtimes</td><td>number</td><td>Total runtime count across all daemons</td></tr>
<tr><td>running</td><td>number</td><td>Runtimes currently in <code>"running"</code> state</td></tr>
<tr><td>groups</td><td>table</td><td>Maps group name &rarr; member count</td></tr>
</tbody></table>
<pre><code><span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="kw">local</span> s = socketley.cluster.stats()
    socketley.log(<span class="st">"cluster: "</span> .. s.daemons .. <span class="st">" daemons, "</span>
                  .. s.running .. <span class="st">"/"</span> .. s.runtimes .. <span class="st">" running"</span>)
    <span class="kw">for</span> name, count <span class="kw">in</span> <span class="fn">pairs</span>(s.groups) <span class="kw">do</span>
        socketley.log(<span class="st">"  group "</span> .. name .. <span class="st">": "</span> .. count .. <span class="st">" members"</span>)
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
</div>

</div><!-- #content-lua -->

<!-- ═══════════════════════════════════════════
     ADDONS TAB CONTENT
═══════════════════════════════════════════ -->
<div id="content-addons" class="content" style="display:none">

<h2 id="addons-overview">Addons</h2>
<p>Socketley's Lua scripting layer enables pure-Lua addon patterns that extend servers with auth middleware, rate limiting, service discovery, metrics push, and more — without touching C++ code. This page documents the primitives that make these patterns possible and shows working examples for each use case.</p>

<h2 id="addons-auth">Auth Middleware</h2>
<p>Two complementary auth patterns cover the most common cases: IP-based admission (via <code>on_auth</code>) and first-message token auth (via <code>self.disconnect</code>).</p>

<h3 id="addons-auth-ip">IP Allowlist</h3>
<p><code>on_auth(client_id)</code> fires immediately after a TCP accept, before <code>on_connect</code>. Return <code>true</code> to admit the client or <code>false</code> to reject and close the connection. Rejected clients never trigger <code>on_connect</code>.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">on_auth</span><span class="method-sig">(client_id) &rarr; bool</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Called before <code>on_connect</code>. Return <code>false</code> (or raise an error) to reject. Fail-closed: if the callback throws, the client is rejected.</div>
</div>

<div class="method-card">
<div class="method-header"><span class="method-name">self.peer_ip</span><span class="method-sig">(client_id) &rarr; string</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Returns the client's IP address (IPv4 or IPv6 string). Calls <code>getpeername()</code> at call time; works in any callback including <code>on_auth</code>.</div>
</div>

<pre><code><span class="cm">-- auth-ip-allowlist.lua</span>
<span class="kw">local</span> allowed_prefix = <span class="st">"192.168."</span>

<span class="kw">function</span> <span class="fn">on_auth</span>(client_id)
    <span class="kw">local</span> ip = self.peer_ip(client_id)
    <span class="kw">local</span> ok = ip:sub(<span class="nb">1</span>, #allowed_prefix) == allowed_prefix
    <span class="kw">if not</span> ok <span class="kw">then</span>
        socketley.log(<span class="st">"rejected: "</span> .. ip)
    <span class="kw">end</span>
    <span class="kw">return</span> ok
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    self.broadcast(<span class="st">"["</span> .. tostring(client_id) .. <span class="st">"] "</span> .. msg)
<span class="kw">end</span></code></pre>

<pre><code><span class="cm"># Test: 127.0.0.1 is not in 192.168. → rejected immediately</span>
socketley create server authtest -p 19100 --lua auth-ip-allowlist.lua -s
nc 127.0.0.1 19100   <span class="cm"># connection is closed before any data exchange</span></code></pre>

<h3 id="addons-auth-token">Token Auth</h3>
<p>For protocol-level auth (e.g., an API token as the first message), use <code>self.disconnect(client_id)</code> to close the connection from inside a callback.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">self.disconnect</span><span class="method-sig">(client_id)</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Gracefully terminates a client connection. Calls <code>shutdown(SHUT_RDWR)</code> on the fd — the pending read CQE completes with EOF, which triggers <code>on_disconnect</code> and cleans up the slot normally. Safe to call at any time from any server callback.</div>
</div>

<pre><code><span class="cm">-- auth-token.lua</span>
<span class="kw">local</span> SECRET = <span class="st">"my-secret-token"</span>
<span class="kw">local</span> authenticated = {}

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)    authenticated[client_id] = <span class="kw">false</span> <span class="kw">end</span>
<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id) authenticated[client_id] = <span class="kw">nil</span>   <span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="kw">if not</span> authenticated[client_id] <span class="kw">then</span>
        <span class="kw">if</span> msg == SECRET <span class="kw">then</span>
            authenticated[client_id] = <span class="kw">true</span>
            self.send(client_id, <span class="st">"AUTH OK"</span>)
        <span class="kw">else</span>
            self.send(client_id, <span class="st">"AUTH FAIL"</span>)
            self.disconnect(client_id)
        <span class="kw">end</span>
        <span class="kw">return</span>
    <span class="kw">end</span>
    self.broadcast(<span class="st">"["</span> .. tostring(client_id) .. <span class="st">"] "</span> .. msg)
<span class="kw">end</span></code></pre>

<h2 id="addons-websocket-session">WebSocket Session Identity</h2>
<p>When a browser connects via WebSocket, the HTTP upgrade request automatically carries rich identity information: <code>Cookie</code>, <code>Origin</code>, <code>Sec-WebSocket-Protocol</code>, and <code>Authorization</code>. The <code>on_websocket</code> callback fires after the handshake completes and exposes these headers as a Lua table.</p>
<p>This is the preferred mechanism for cross-session identity: the session cookie set by your web app's login flow is forwarded automatically by the browser on every WebSocket reconnect, giving you a durable identifier that survives fd recycling and IP changes.</p>

<div class="method-card" id="cb-on-websocket">
<div class="method-header"><span class="method-name">on_websocket</span><span class="method-sig">(client_id, headers)</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Called immediately after a WebSocket upgrade handshake completes, after <code>on_connect</code> has already fired. <code>headers</code> is a Lua table with any subset of: <code>cookie</code>, <code>origin</code>, <code>protocol</code> (Sec-WebSocket-Protocol), <code>authorization</code>. Absent headers are nil. Never fires for plain TCP clients.</div>
</div>

<div class="method-card">
<div class="method-header"><span class="method-name">self.ws_headers</span><span class="method-sig">(client_id) &rarr; table | nil</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Returns the stored WebSocket upgrade headers table for a connected client, or <code>nil</code> if the client is a plain TCP connection. Same keys as the <code>on_websocket</code> <code>headers</code> argument. Can be called from any server callback after the handshake.</div>
</div>

<pre><code><span class="cm">-- websocket-session.lua</span>
<span class="kw">local</span> cjson    = require <span class="st">"cjson"</span>
<span class="kw">local</span> sessions = {}   <span class="cm">-- client_id → { sid, ip, origin }</span>

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)
    sessions[client_id] = { sid = tostring(client_id), ip = self.peer_ip(client_id) }
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_websocket</span>(client_id, headers)
    <span class="kw">local</span> sid = sessions[client_id] <span class="kw">and</span> sessions[client_id].sid <span class="kw">or</span> tostring(client_id)
    <span class="kw">if</span> headers.cookie <span class="kw">then</span>
        sid = headers.cookie:match(<span class="st">"session_id=([^;%s]+)"</span>) <span class="kw">or</span> sid
    <span class="kw">end</span>
    sessions[client_id] = { sid = sid, ip = self.peer_ip(client_id), origin = headers.origin <span class="kw">or</span> <span class="st">"unknown"</span> }
    socketley.log(<span class="st">"ws connect sid="</span> .. sid .. <span class="st">" origin="</span> .. (headers.origin <span class="kw">or</span> <span class="st">"?"</span>))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id)
    <span class="kw">local</span> s = sessions[client_id]
    <span class="kw">if</span> s <span class="kw">then</span> socketley.log(<span class="st">"disconnect sid="</span> .. s.sid) sessions[client_id] = <span class="kw">nil</span> <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="kw">local</span> s = sessions[client_id] <span class="kw">or</span> {}
    self.broadcast(cjson.encode({ sid = s.sid, data = msg }))
<span class="kw">end</span></code></pre>

<pre><code><span class="cm"># Start server and connect with a cookie header</span>
socketley start ws-test --lua websocket-session.lua --port 9000
wscat --header <span class="st">"Cookie: session_id=abc123"</span> --connect ws://localhost:9000
<span class="cm"># Logs: ws connect sid=abc123 origin=?</span>
<span class="cm"># Reconnect with same cookie → same sid=abc123</span></code></pre>

<h2 id="addons-rate-limit">Rate Limiting</h2>
<p>Combine <code>self.disconnect</code> with <code>on_tick</code> to enforce a per-client message budget. No external deps required — pure Lua.</p>

<pre><code><span class="cm">-- rate-limit.lua: 10 messages per second per client</span>
<span class="kw">local</span> MAX_MSGS = <span class="nb">10</span>
<span class="kw">local</span> counts   = {}
tick_ms = <span class="nb">1000</span>

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)    counts[client_id] = <span class="nb">0</span>   <span class="kw">end</span>
<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id) counts[client_id] = <span class="kw">nil</span> <span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    counts[client_id] = (counts[client_id] <span class="kw">or</span> <span class="nb">0</span>) + <span class="nb">1</span>
    <span class="kw">if</span> counts[client_id] > MAX_MSGS <span class="kw">then</span>
        self.send(client_id, <span class="st">"ERROR rate limit exceeded"</span>)
        self.disconnect(client_id)
        <span class="kw">return</span>
    <span class="kw">end</span>
    self.broadcast(msg)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">for</span> id <span class="kw">in</span> pairs(counts) <span class="kw">do</span> counts[id] = <span class="nb">0</span> <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<h2 id="addons-clients-multicast">Client Enumeration &amp; Multicast</h2>
<p>Two primitives fill the gap between single-target <code>self.send</code> and full-fanout <code>self.broadcast</code>: <code>self.clients()</code> enumerates connected client IDs and <code>self.multicast(ids, msg)</code> sends to an arbitrary subset in one call.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">self.clients</span><span class="method-sig">() &rarr; table</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Returns a Lua table (1-based array) of all currently connected client fd integers. The list is a snapshot — clients that disconnect before you iterate it are safe to ignore (send to them simply does nothing).</div>
</div>

<div class="method-card">
<div class="method-header"><span class="method-name">self.multicast</span><span class="method-sig">(ids, msg)</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Send <code>msg</code> to every client_id in the <code>ids</code> table. Silently skips invalid or already-disconnected fds. Uses the same zero-copy shared-string path as <code>broadcast</code>.</div>
</div>

<pre><code><span class="cm">-- multicast.lua: send to clients tagged as "subscriber"</span>
<span class="kw">local</span> subs = {}

<span class="kw">function</span> <span class="fn">on_connect</span>(id) subs[id] = <span class="kw">false</span> <span class="kw">end</span>
<span class="kw">function</span> <span class="fn">on_disconnect</span>(id) subs[id] = <span class="kw">nil</span> <span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(id, msg)
    <span class="kw">if</span> msg == <span class="st">"SUBSCRIBE"</span> <span class="kw">then</span>
        subs[id] = <span class="kw">true</span>
        self.send(id, <span class="st">"OK subscribed"</span>)
    <span class="kw">elseif</span> msg:sub(<span class="nb">1</span>,<span class="nb">9</span>) == <span class="st">"PUBLISH: "</span> <span class="kw">then</span>
        <span class="kw">local</span> targets = {}
        <span class="kw">for</span> cid, is_sub <span class="kw">in</span> pairs(subs) <span class="kw">do</span>
            <span class="kw">if</span> is_sub <span class="kw">then</span> targets[#targets+<span class="nb">1</span>] = cid <span class="kw">end</span>
        <span class="kw">end</span>
        self.multicast(targets, msg:sub(<span class="nb">10</span>))
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<h2 id="addons-metadata">Per-Connection Metadata</h2>
<p>Store arbitrary string key/value pairs on a connection without a separate Lua table. Metadata is freed automatically when the client disconnects — no <code>on_disconnect</code> cleanup needed.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">self.set_data</span><span class="method-sig">(id, key, val)</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Attach a string value to client <code>id</code> under <code>key</code>. Pass <code>nil</code> as <code>val</code> to delete the key.</div>
</div>

<div class="method-card">
<div class="method-header"><span class="method-name">self.get_data</span><span class="method-sig">(id, key) &rarr; string | nil</span><span class="badge badge-server">server</span></div>
<div class="method-desc">Retrieve the value stored under <code>key</code> for client <code>id</code>, or <code>nil</code> if not set.</div>
</div>

<pre><code><span class="cm">-- metadata.lua: store username on auth, access in message handler</span>
<span class="kw">function</span> <span class="fn">on_client_message</span>(id, msg)
    <span class="kw">if</span> <span class="kw">not</span> self.get_data(id, <span class="st">"user"</span>) <span class="kw">then</span>
        <span class="cm">-- First message: treat as login</span>
        self.set_data(id, <span class="st">"user"</span>, msg:match(<span class="st">"^LOGIN (%S+)"</span>))
        self.send(id, <span class="st">"OK"</span>)
        <span class="kw">return</span>
    <span class="kw">end</span>
    <span class="kw">local</span> user = self.get_data(id, <span class="st">"user"</span>)
    self.broadcast(<span class="st">"["</span> .. user .. <span class="st">"] "</span> .. msg)
<span class="kw">end</span>

<span class="cm">-- No on_disconnect needed — metadata freed with connection</span></code></pre>

<h2 id="addons-timers">Timers</h2>
<p>One-shot and repeating timers backed by io_uring <code>IORING_OP_TIMEOUT</code> — no extra threads, no polling. Each timer fires on the runtime's event loop turn.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">socketley.set_timeout</span><span class="method-sig">(ms, fn)</span><span class="badge badge-all">all</span></div>
<div class="method-desc">Fire <code>fn()</code> once after <code>ms</code> milliseconds. The timer is automatically freed after firing.</div>
</div>

<div class="method-card">
<div class="method-header"><span class="method-name">socketley.set_interval</span><span class="method-sig">(ms, fn)</span><span class="badge badge-all">all</span></div>
<div class="method-desc">Fire <code>fn()</code> every <code>ms</code> milliseconds. The interval continues until the runtime's Lua context is destroyed (i.e. on stop). No explicit cancel API — intervals are bounded to the runtime lifetime.</div>
</div>

<pre><code><span class="cm">-- timers.lua: one-shot warmup delay + repeating heartbeat</span>
<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="cm">-- Fire once after 2 seconds</span>
    socketley.set_timeout(<span class="nb">2000</span>, <span class="kw">function</span>()
        socketley.log(<span class="st">"warmup complete"</span>)
        self.broadcast(<span class="st">"SERVER READY"</span>)
    <span class="kw">end</span>)

    <span class="cm">-- Fire every 5 seconds</span>
    socketley.set_interval(<span class="nb">5000</span>, <span class="kw">function</span>()
        self.broadcast(<span class="st">"heartbeat conns="</span> .. tostring(self.connections()))
    <span class="kw">end</span>)
<span class="kw">end</span></code></pre>

<h2 id="addons-proxy-hooks">Proxy Data Hooks</h2>
<p>Intercept, modify, or drop data at the proxy layer without touching backend or client code. Both hooks follow the same contract: return a modified string to replace the chunk, or <code>nil</code> to drop it entirely.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">on_proxy_request</span><span class="method-sig">(client_id, data) &rarr; string | nil</span><span class="badge badge-proxy">proxy</span></div>
<div class="method-desc">Called for every chunk forwarded from a client to a backend. Return a replacement string or <code>nil</code> to drop. Fires before the data is queued for the backend write.</div>
</div>

<div class="method-card">
<div class="method-header"><span class="method-name">on_proxy_response</span><span class="method-sig">(client_id, data) &rarr; string | nil</span><span class="badge badge-proxy">proxy</span></div>
<div class="method-desc">Called for every chunk forwarded from a backend to a client. Same semantics as <code>on_proxy_request</code>.</div>
</div>

<pre><code><span class="cm">-- proxy-hooks.lua: uppercase requests, add header to responses</span>
<span class="kw">function</span> <span class="fn">on_proxy_request</span>(client_id, data)
    <span class="kw">return</span> data:upper()   <span class="cm">-- modify</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_proxy_response</span>(client_id, data)
    <span class="cm">-- Drop responses containing "SECRET"</span>
    <span class="kw">if</span> data:find(<span class="st">"SECRET"</span>) <span class="kw">then</span> <span class="kw">return</span> <span class="kw">nil</span> <span class="kw">end</span>
    <span class="kw">return</span> data
<span class="kw">end</span></code></pre>

<h2 id="addons-pubsub">Cross-Runtime Pub/Sub</h2>
<p>A runtime's Lua script can now subscribe to any named cache runtime's publish channel — no RESP client socket required. <code>socketley.subscribe</code> registers a callback that fires on the subscribing runtime's event loop turn whenever the cache publishes to that channel.</p>

<div class="method-card">
<div class="method-header"><span class="method-name">socketley.subscribe</span><span class="method-sig">(cache_name, channel, fn)</span><span class="badge badge-all">all</span></div>
<div class="method-desc">Register <code>fn(channel, message)</code> to fire whenever the named cache runtime publishes to <code>channel</code>. Multiple subscriptions to the same channel stack and all fire in registration order. The callback is bound to the subscribing runtime's Lua context and freed when the runtime stops.</div>
</div>

<pre><code><span class="cm">-- pubsub-server.lua: server reacts to cache publish events</span>
<span class="kw">function</span> <span class="fn">on_start</span>()
    socketley.subscribe(<span class="st">"events"</span>, <span class="st">"alerts"</span>, <span class="kw">function</span>(ch, msg)
        socketley.log(<span class="st">"alert: "</span> .. msg)
        self.broadcast(<span class="st">"ALERT: "</span> .. msg)
    <span class="kw">end</span>)
<span class="kw">end</span>

<span class="cm">-- pubsub-cache.lua: cache script that publishes alerts</span>
<span class="kw">function</span> <span class="fn">on_write</span>(key, value, ttl)
    <span class="kw">if</span> key:sub(<span class="nb">1</span>,<span class="nb">6</span>) == <span class="st">"alert:"</span> <span class="kw">then</span>
        self.publish(<span class="st">"alerts"</span>, value)
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<pre><code><span class="cm"># Wire it up:</span>
socketley create cache events --port 9100 --lua pubsub-cache.lua
socketley create server api   --port 9000 --lua pubsub-server.lua
socketley start events
socketley start api</code></pre>

<h2 id="addons-cluster-events">Cluster Event Callbacks</h2>
<p>React to cluster topology changes from Lua. These optional callbacks fire when daemons join or leave the cluster, or when a group's membership count changes. Events are detected during the 2-second scan/publish cycle, so callbacks may fire up to 2&nbsp;seconds after the actual change.</p>

<div class="info-box"><strong>Requires cluster mode.</strong> These callbacks only fire when cluster mode is enabled (<code>daemon --name</code> + <code>daemon --cluster</code>). A daemon is considered stale and triggers <code>on_cluster_leave</code> after 10&nbsp;seconds without a heartbeat update.</div>

<div class="callback-card" id="addons-cluster-join">
<div class="method-header"><span class="method-name">on_cluster_join(daemon)</span><span class="badge badge-cluster">cluster</span></div>
<div class="fires">Fires when a new remote daemon is discovered in the cluster directory.</div>
<table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>daemon.name</td><td>string</td><td>The new daemon's name</td></tr>
<tr><td>daemon.host</td><td>string</td><td>The new daemon's advertised address</td></tr>
</tbody></table>
</div>

<div class="callback-card" id="addons-cluster-leave">
<div class="method-header"><span class="method-name">on_cluster_leave(daemon)</span><span class="badge badge-cluster">cluster</span></div>
<div class="fires">Fires when a remote daemon's heartbeat becomes stale (&gt;10s) or its file is removed.</div>
<table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>daemon.name</td><td>string</td><td>The departed daemon's name</td></tr>
</tbody></table>
</div>

<div class="callback-card" id="addons-group-change">
<div class="method-header"><span class="method-name">on_group_change(group, members)</span><span class="badge badge-cluster">cluster</span></div>
<div class="fires">Fires when the total member count of a group changes &mdash; a runtime joins or leaves the group, or a daemon with group members appears or disappears. Only fires on actual count changes, not on every scan cycle.</div>
<table><thead><tr><th>Argument</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>group</td><td>string</td><td>The group name</td></tr>
<tr><td>members</td><td>table</td><td>Array of <code>{daemon, host, port}</code> for current group members</td></tr>
</tbody></table>
</div>

<pre><code><span class="cm">-- cluster-failover.lua: maintain a live routing table for the "api" group</span>
<span class="kw">local</span> backends = {}

<span class="kw">function</span> <span class="fn">on_cluster_join</span>(daemon)
    socketley.log(<span class="st">"daemon joined: "</span> .. daemon.name .. <span class="st">" @ "</span> .. daemon.host)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_cluster_leave</span>(daemon)
    socketley.log(<span class="st">"daemon left: "</span> .. daemon.name)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_group_change</span>(group, members)
    <span class="kw">if</span> group == <span class="st">"api"</span> <span class="kw">then</span>
        backends = members
        socketley.log(<span class="st">"api group now has "</span> .. #members .. <span class="st">" members"</span>)
    <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="cm">-- Initial cluster snapshot</span>
    <span class="kw">local</span> stats = socketley.cluster.stats()
    socketley.log(<span class="st">"cluster: "</span> .. stats.daemons .. <span class="st">" daemons, "</span>
                  .. stats.running .. <span class="st">"/"</span> .. stats.runtimes .. <span class="st">" running"</span>)

    <span class="cm">-- Seed the routing table</span>
    backends = socketley.cluster.group(<span class="st">"api"</span>)
    socketley.log(<span class="st">"api group: "</span> .. #backends .. <span class="st">" members"</span>)
<span class="kw">end</span></code></pre>

<pre><code><span class="cm"># Configure two daemons for cluster mode + create api servers + monitoring:</span>
socketley daemon --name node1 --cluster /shared/cluster
socketley daemon --name node2 --cluster /shared/cluster

<span class="cm"># On node1: api server + monitoring server with cluster callbacks</span>
SOCKETLEY_SOCKET=/tmp/node1.sock socketley create server api1 -p 9001 -g api -s
SOCKETLEY_SOCKET=/tmp/node1.sock socketley create server monitor -p 9100 --lua cluster-failover.lua -s

<span class="cm"># On node2: api server (triggers on_cluster_join + on_group_change on node1)</span>
SOCKETLEY_SOCKET=/tmp/node2.sock socketley create server api2 -p 9002 -g api -s</code></pre>

<div class="info-box"><strong>Combining introspection + events.</strong> Use <code>socketley.cluster.group()</code> in <code>on_start</code> for the initial snapshot, then keep it up-to-date via <code>on_group_change</code>. This avoids polling and gives you a near-real-time routing table with ~2s convergence.</div>

<h2 id="addons-http">HTTP Calls</h2>

<h3 id="addons-http-api">socketley.http API</h3>
<p>Make synchronous HTTP or HTTPS requests from Lua scripts using <code>socketley.http(opts)</code>.</p>

<div class="warn-box"><strong>Blocks the event loop.</strong> <code>socketley.http</code> is a synchronous call that blocks the single-threaded event loop for the duration of the request. Use it only in <code>on_start</code>, <code>on_stop</code>, or low-frequency <code>on_tick</code> callbacks (e.g., <code>tick_ms = 30000</code>). Never call it from <code>on_client_message</code> or <code>on_connect</code> under load.</div>

<div class="method-card" id="addons-http-api">
<div class="method-header"><span class="method-name">socketley.http</span><span class="method-sig">(opts) &rarr; table</span><span class="badge badge-all">all</span></div>
<div class="method-desc">
  Sends a synchronous HTTP/1.0 request. Returns <code>{ok, status, body, error}</code>.
  <br><br>
  <strong>opts keys:</strong> <code>url</code> (required), <code>method</code> (default <code>"GET"</code>), <code>body</code>, <code>headers</code> (table), <code>timeout_ms</code> (default 5000).
</div>
</div>

<pre><code><span class="cm">-- Simple GET</span>
<span class="kw">local</span> res = socketley.http({ url = <span class="st">"http://127.0.0.1:8500/v1/status/leader"</span> })
<span class="kw">if</span> res.ok <span class="kw">then</span>
    socketley.log(<span class="st">"leader: "</span> .. res.body)
<span class="kw">else</span>
    socketley.log(<span class="st">"error: "</span> .. res.error)
<span class="kw">end</span>

<span class="cm">-- POST with JSON body</span>
<span class="kw">local</span> res = socketley.http({
    method  = <span class="st">"POST"</span>,
    url     = <span class="st">"http://127.0.0.1:9091/metrics/job/myapp"</span>,
    body    = <span class="st">"connections "</span> .. tostring(self.connections()) .. <span class="st">"\n"</span>,
    headers = { [<span class="st">"Content-Type"</span>] = <span class="st">"text/plain"</span> },
})</code></pre>

<h3 id="addons-http-https">HTTPS</h3>
<p>HTTPS is supported via OpenSSL. Certificate validation is skipped (<code>SSL_VERIFY_NONE</code>) — suitable for trusted internal services (Consul, etcd, Prometheus Pushgateway on localhost).</p>
<p>For external HTTPS with certificate validation, use <code>io.popen</code> (available in Lua scripts since <code>sol::lib::io</code> is opened):</p>
<pre><code><span class="cm">-- Fallback via curl for full cert validation</span>
<span class="kw">local</span> f = io.popen(<span class="st">"curl -s https://api.example.com/health"</span>)
<span class="kw">local</span> body = f:read(<span class="st">"*a"</span>)
f:close()</code></pre>

<h2 id="addons-service-discovery">Service Discovery</h2>
<p>Register and deregister this runtime with Consul (or any HTTP-based registry) using <code>socketley.http</code> in <code>on_start</code>/<code>on_stop</code>.</p>

<pre><code><span class="cm">-- service-discovery.lua — Consul registration</span>
<span class="kw">local</span> CONSUL = <span class="st">"http://127.0.0.1:8500"</span>

<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="kw">local</span> payload = string.format(
        <span class="st">'{"ID":"%s","Name":"%s","Port":%d}'</span>,
        self.name, self.name, self.port)
    socketley.http({
        method  = <span class="st">"PUT"</span>,
        url     = CONSUL .. <span class="st">"/v1/agent/service/register"</span>,
        body    = payload,
        headers = { [<span class="st">"Content-Type"</span>] = <span class="st">"application/json"</span> },
    })
    socketley.log(<span class="st">"registered with Consul: "</span> .. self.name)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_stop</span>()
    socketley.http({
        method = <span class="st">"PUT"</span>,
        url    = CONSUL .. <span class="st">"/v1/agent/service/deregister/"</span> .. self.name,
    })
<span class="kw">end</span></code></pre>

<p>The same pattern works with etcd (PUT to <code>/v3/kv/put</code>), Eureka (POST to <code>/eureka/apps/&lt;name&gt;</code>), or any REST-based registry.</p>

<h2 id="addons-metrics">Metrics Push</h2>
<p>Push runtime metrics to Prometheus Pushgateway every N seconds using <code>on_tick</code> + <code>socketley.http</code>.</p>

<pre><code><span class="cm">-- metrics-push.lua — Prometheus Pushgateway</span>
<span class="kw">local</span> PUSHGW = <span class="st">"http://127.0.0.1:9091"</span>
tick_ms = <span class="nb">30000</span>   <span class="cm">-- push every 30 s</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">local</span> conns = self.connections()
    <span class="kw">local</span> body  = string.format(
        <span class="st">"# HELP socketley_connections Active TCP connections\n"</span> ..
        <span class="st">"# TYPE socketley_connections gauge\n"</span> ..
        <span class="st">"socketley_connections{runtime=\"%s\"} %d\n"</span>,
        self.name, conns)
    socketley.http({
        method  = <span class="st">"POST"</span>,
        url     = PUSHGW .. <span class="st">"/metrics/job/socketley/instance/"</span> .. self.name,
        body    = body,
        headers = { [<span class="st">"Content-Type"</span>] = <span class="st">"text/plain; version=0.0.4"</span> },
    })
<span class="kw">end</span></code></pre>

<h2 id="db-backend">Database Backend Hooks</h2>
<p>Four Lua callbacks wire the cache to any database — no built-in drivers, no C++ changes required. Install a Lua DB library with <code>luarocks</code>, implement the callbacks you need, and the cache handles read-through population and write propagation automatically.</p>
<table><thead><tr><th>Callback</th><th>Signature</th><th>Fires when</th></tr></thead><tbody>
<tr><td><code>on_miss(key)</code></td><td><code>&rarr; value [, ttl_seconds]</code></td><td>GET returns nil — fetch from DB</td></tr>
<tr><td><code>on_write(key, value, ttl)</code></td><td>&rarr; nothing</td><td>After SET / SETEX / SETNX / MSET</td></tr>
<tr><td><code>on_delete(key)</code></td><td>&rarr; nothing</td><td>After DEL</td></tr>
<tr><td><code>on_expire(key)</code></td><td>&rarr; nothing</td><td>After TTL sweep removes key</td></tr>
</tbody></table>
<div class="info-box"><strong>Zero overhead when unused.</strong> Each hook is a single boolean check on the event loop thread — if the callback is not defined in your script, execution falls straight through with no extra work.</div>

<div class="callback-card" id="cb-on-miss">
<div class="method-header"><span class="method-name">on_miss(key)</span><span class="method-sig"> &rarr; value [, ttl_seconds]</span><span class="badge badge-cache">cache</span></div>
<div class="fires">Fires when a GET misses the in-memory store. Return a value (and optional TTL in seconds) to populate the cache transparently and return it to the client. Return nil to pass the miss through to the client normally.</div>
<pre><code><span class="kw">function</span> <span class="fn">on_miss</span>(key)
    <span class="kw">local</span> value = db_fetch(key)
    <span class="kw">if</span> value <span class="kw">then</span>
        <span class="kw">return</span> value, <span class="nb">300</span>  <span class="cm">-- populate cache, expire after 300 s</span>
    <span class="kw">end</span>
    <span class="cm">-- return nil → client receives nil, nothing cached</span>
<span class="kw">end</span></code></pre>
</div>

<div class="callback-card" id="cb-on-write">
<div class="method-header"><span class="method-name">on_write(key, value, ttl)</span><span class="badge badge-cache">cache</span></div>
<div class="fires">Fires after every successful SET, SETEX, PSETEX, SETNX, or MSET. <code>ttl</code> is the expiry in seconds (0 = no TTL). Runs synchronously on the event loop thread — for write-heavy workloads use the <strong>write-behind</strong> pattern: buffer in this callback, flush to the DB in <code>on_tick</code>.</div>
<pre><code><span class="kw">local</span> pending = {}

<span class="kw">function</span> <span class="fn">on_write</span>(key, value, ttl)
    pending[key] = value  <span class="cm">-- buffer — instant return to client</span>
<span class="kw">end</span>

tick_ms = <span class="nb">2000</span>
<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">if</span> <span class="kw">not</span> next(pending) <span class="kw">then</span> <span class="kw">return</span> <span class="kw">end</span>
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db_upsert(k, v)
    <span class="kw">end</span>
    pending = {}
<span class="kw">end</span></code></pre>
</div>

<div class="callback-card" id="cb-on-delete-expire">
<div class="method-header"><span class="method-name">on_delete(key)</span>&ensp;<span class="method-name">on_expire(key)</span><span class="badge badge-cache">cache</span></div>
<div class="fires"><code>on_delete</code> fires after DEL. <code>on_expire</code> fires when the 100 ms background TTL sweep removes a key. <code>on_expire</code> does <em>not</em> delete from the DB by default — uncomment <code>on_delete(key)</code> below if you want expiry to propagate.</div>
<pre><code><span class="kw">function</span> <span class="fn">on_delete</span>(key)
    db:exec(<span class="st">"DELETE FROM kv WHERE key="</span> .. db:quote(key))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_expire</span>(key)
    socketley.log(<span class="st">"expired: "</span> .. key)
    <span class="cm">-- on_delete(key)  -- un-comment to propagate expiry to DB</span>
<span class="kw">end</span></code></pre>
</div>

<h3 id="db-sqlite">SQLite — lsqlite3</h3>
<p>Embedded, zero-config, no server required. Ideal for single-host deployments and local development.</p>
<pre><code>luarocks install lsqlite3</code></pre>
<pre><code><span class="cm">-- Attach: socketley create cache mydb -p 9000 --lua sqlite.lua -s</span>
<span class="kw">local</span> db, pending = <span class="kw">nil</span>, {}
tick_ms = <span class="nb">2000</span>

<span class="kw">function</span> <span class="fn">on_start</span>()
    db = require(<span class="st">"lsqlite3"</span>).open(<span class="st">"/tmp/cache.db"</span>)
    db:exec(<span class="st">"CREATE TABLE IF NOT EXISTS kv (key TEXT PRIMARY KEY, value TEXT)"</span>)
    socketley.log(<span class="st">"SQLite backend ready"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_miss</span>(key)
    <span class="kw">for</span> row <span class="kw">in</span> db:nrows(<span class="st">"SELECT value FROM kv WHERE key="</span> .. db:quote(key)) <span class="kw">do</span>
        <span class="kw">return</span> row.value, <span class="nb">300</span>  <span class="cm">-- value + TTL</span>
    <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_write</span>(key, value, ttl)
    pending[key] = value
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">if</span> <span class="kw">not</span> next(pending) <span class="kw">then</span> <span class="kw">return</span> <span class="kw">end</span>
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db:exec(<span class="st">"INSERT OR REPLACE INTO kv(key,value) VALUES("</span>
                ..db:quote(k)..<span class="st">","</span>..db:quote(v)..<span class="st">")"</span>)
    <span class="kw">end</span>
    pending = {}
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_delete</span>(key)
    pending[key] = <span class="kw">nil</span>
    db:exec(<span class="st">"DELETE FROM kv WHERE key="</span> .. db:quote(key))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_expire</span>(key)
    socketley.log(<span class="st">"expired: "</span> .. key)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_stop</span>()
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>  <span class="cm">-- flush before shutdown</span>
        db:exec(<span class="st">"INSERT OR REPLACE INTO kv(key,value) VALUES("</span>
                ..db:quote(k)..<span class="st">","</span>..db:quote(v)..<span class="st">")"</span>)
    <span class="kw">end</span>
    <span class="kw">if</span> db <span class="kw">then</span> db:close() <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<h3 id="db-mysql">MySQL / MariaDB — luasql-mysql</h3>
<pre><code>luarocks install luasql-mysql</code></pre>
<pre><code><span class="cm">-- Attach: socketley create cache mydb -p 9000 --lua mysql.lua -s</span>
<span class="cm">-- Schema: CREATE TABLE kv (k VARCHAR(512) PRIMARY KEY, v TEXT,</span>
<span class="cm">--                          updated_at TIMESTAMP DEFAULT NOW() ON UPDATE NOW());</span>
<span class="kw">local</span> env, db, pending = <span class="kw">nil</span>, <span class="kw">nil</span>, {}
tick_ms = <span class="nb">2000</span>

<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="kw">local</span> luasql = require(<span class="st">"luasql.mysql"</span>)
    env = luasql.mysql()
    db  = env:connect(<span class="st">"mydb"</span>, <span class="st">"user"</span>, <span class="st">"password"</span>, <span class="st">"127.0.0.1"</span>, <span class="nb">3306</span>)
    db:execute(<span class="st">"CREATE TABLE IF NOT EXISTS kv ("</span>
               ..<span class="st">"k VARCHAR(512) PRIMARY KEY, v TEXT)"</span>)
    socketley.log(<span class="st">"MySQL backend ready"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_miss</span>(key)
    <span class="kw">local</span> cur = db:execute(<span class="st">"SELECT v FROM kv WHERE k='"</span>
                           ..db:escape(key)..<span class="st">"'"</span>)
    <span class="kw">local</span> row = cur:fetch({}, <span class="st">"a"</span>)
    cur:close()
    <span class="kw">if</span> row <span class="kw">then</span> <span class="kw">return</span> row.v, <span class="nb">300</span> <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_write</span>(key, value, ttl)
    pending[key] = value
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">if</span> <span class="kw">not</span> next(pending) <span class="kw">then</span> <span class="kw">return</span> <span class="kw">end</span>
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db:execute(<span class="st">"INSERT INTO kv(k,v) VALUES('"</span>..db:escape(k)..<span class="st">"','"</span>
                   ..db:escape(v)..<span class="st">"') ON DUPLICATE KEY UPDATE v=VALUES(v)"</span>)
    <span class="kw">end</span>
    pending = {}
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_delete</span>(key)
    pending[key] = <span class="kw">nil</span>
    db:execute(<span class="st">"DELETE FROM kv WHERE k='"</span> .. db:escape(key) .. <span class="st">"'"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_expire</span>(key)
    socketley.log(<span class="st">"expired: "</span> .. key)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_stop</span>()
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db:execute(<span class="st">"INSERT INTO kv(k,v) VALUES('"</span>..db:escape(k)..<span class="st">"','"</span>
                   ..db:escape(v)..<span class="st">"') ON DUPLICATE KEY UPDATE v=VALUES(v)"</span>)
    <span class="kw">end</span>
    <span class="kw">if</span> db  <span class="kw">then</span> db:close()  <span class="kw">end</span>
    <span class="kw">if</span> env <span class="kw">then</span> env:close() <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<h3 id="db-postgres">PostgreSQL — luasql-postgres</h3>
<pre><code>luarocks install luasql-postgres</code></pre>
<pre><code><span class="cm">-- Attach: socketley create cache mydb -p 9000 --lua postgres.lua -s</span>
<span class="cm">-- Schema: CREATE TABLE IF NOT EXISTS kv (k TEXT PRIMARY KEY, v TEXT);</span>
<span class="kw">local</span> env, db, pending = <span class="kw">nil</span>, <span class="kw">nil</span>, {}
tick_ms = <span class="nb">2000</span>

<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="kw">local</span> luasql = require(<span class="st">"luasql.postgres"</span>)
    env = luasql.postgres()
    db  = env:connect(<span class="st">"host=127.0.0.1 dbname=mydb user=app password=secret"</span>)
    db:execute(<span class="st">"CREATE TABLE IF NOT EXISTS kv (k TEXT PRIMARY KEY, v TEXT)"</span>)
    socketley.log(<span class="st">"PostgreSQL backend ready"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_miss</span>(key)
    <span class="kw">local</span> cur = db:execute(<span class="st">"SELECT v FROM kv WHERE k='"</span>
                           ..db:escape(key)..<span class="st">"'"</span>)
    <span class="kw">local</span> row = cur:fetch({}, <span class="st">"a"</span>)
    cur:close()
    <span class="kw">if</span> row <span class="kw">then</span> <span class="kw">return</span> row.v, <span class="nb">300</span> <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_write</span>(key, value, ttl)
    pending[key] = value
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">if</span> <span class="kw">not</span> next(pending) <span class="kw">then</span> <span class="kw">return</span> <span class="kw">end</span>
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db:execute(<span class="st">"INSERT INTO kv(k,v) VALUES('"</span>..db:escape(k)..<span class="st">"','"</span>
                   ..db:escape(v)..<span class="st">"') ON CONFLICT(k) DO UPDATE SET v=EXCLUDED.v"</span>)
    <span class="kw">end</span>
    pending = {}
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_delete</span>(key)
    pending[key] = <span class="kw">nil</span>
    db:execute(<span class="st">"DELETE FROM kv WHERE k='"</span> .. db:escape(key) .. <span class="st">"'"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_expire</span>(key)
    socketley.log(<span class="st">"expired: "</span> .. key)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_stop</span>()
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db:execute(<span class="st">"INSERT INTO kv(k,v) VALUES('"</span>..db:escape(k)..<span class="st">"','"</span>
                   ..db:escape(v)..<span class="st">"') ON CONFLICT(k) DO UPDATE SET v=EXCLUDED.v"</span>)
    <span class="kw">end</span>
    <span class="kw">if</span> db  <span class="kw">then</span> db:close()  <span class="kw">end</span>
    <span class="kw">if</span> env <span class="kw">then</span> env:close() <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<h3 id="db-patterns">Write-Behind vs Write-Through</h3>
<table><thead><tr><th>Pattern</th><th>How</th><th>SET latency</th><th>Durability</th><th>Best for</th></tr></thead><tbody>
<tr><td><strong>Write-behind</strong></td><td>Buffer in <code>on_write</code>, flush in <code>on_tick</code></td><td>Cache only — instant</td><td>Up to <code>tick_ms</code> lag on crash</td><td>High write rate, latency-sensitive</td></tr>
<tr><td><strong>Write-through</strong></td><td>Call DB directly in <code>on_write</code></td><td>Cache + DB latency</td><td>Always in sync</td><td>Low write rate, strict durability</td></tr>
</tbody></table>
<div class="warn-box"><strong>Write-through saturation:</strong> At 1 ms/DB write, write-through saturates around 1 000 writes/s on a single-threaded event loop. Use write-behind for anything above that.</div>
<div class="info-box"><strong>Flush on shutdown:</strong> Always flush <code>pending</code> in <code>on_stop()</code> to avoid losing the last batch of writes when the cache is stopped cleanly.</div>


<h2 id="addons-mq">Message Queue Bridge</h2>
<p>Bridge connected clients to RabbitMQ, NATS, or Redis Streams using luarocks libraries inside server callbacks.</p>

<pre><code><span class="cm">-- nats-bridge.lua — forward all client messages to a NATS subject</span>
<span class="cm">-- Requires: luarocks install lua-nats (or similar binding)</span>
<span class="kw">local</span> nats

<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="kw">local</span> ok, mod = pcall(require, <span class="st">"nats"</span>)
    <span class="kw">if</span> ok <span class="kw">then</span>
        nats = mod.connect({ host = <span class="st">"127.0.0.1"</span>, port = <span class="nb">4222</span> })
        socketley.log(<span class="st">"NATS bridge connected"</span>)
    <span class="kw">else</span>
        socketley.log(<span class="st">"NATS not available: "</span> .. tostring(mod))
    <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="kw">if</span> nats <span class="kw">then</span>
        nats:publish(<span class="st">"socketley."</span> .. self.name, msg)
    <span class="kw">end</span>
    self.broadcast(msg)   <span class="cm">-- also relay to TCP clients</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_stop</span>()
    <span class="kw">if</span> nats <span class="kw">then</span> nats:close() <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<div class="info-box">
<strong>Tip — HTTP-based MQ:</strong> If your broker has an HTTP API (RabbitMQ Management, NATS JetStream), you can publish messages directly via <code>socketley.http</code> without any extra library:
<pre style="margin-top:0.5em;margin-bottom:0"><code>socketley.http({
    method = <span class="st">"POST"</span>,
    url    = <span class="st">"http://127.0.0.1:15672/api/exchanges/%2F/amq.default/publish"</span>,
    body   = <span class="st">'{"properties":{},"routing_key":"myqueue","payload":"'</span> .. msg .. <span class="st">'","payload_encoding":"string"}'</span>,
    headers = {
        [<span class="st">"Content-Type"</span>] = <span class="st">"application/json"</span>,
        [<span class="st">"Authorization"</span>] = <span class="st">"Basic Z3Vlc3Q6Z3Vlc3Q="</span>,  <span class="cm">-- guest:guest</span>
    },
})</code></pre>
</div>


<h2 id="addons-redis-session">Distributed Session / Shared State</h2>
<p>A single Socketley instance keeps state in plain Lua tables. For multi-instance deployments (load-balanced), shared state is needed: rate-limit counters, presence tracking, session data. <code>redis-lua</code> connects to an external Redis from within any Lua callback.</p>

<pre><code><span class="cm">-- luarocks install redis-lua</span>
<span class="kw">local</span> redis = require <span class="st">"redis"</span>
<span class="kw">local</span> r     = redis.connect(<span class="st">"127.0.0.1"</span>, <span class="nb">6379</span>)

<span class="kw">local</span> RATE_LIMIT = <span class="nb">20</span>  <span class="cm">-- max messages per second per IP</span>

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)
    r:sadd(<span class="st">"socketley:online"</span>, tostring(client_id))
    <span class="kw">local</span> key = <span class="st">"session:"</span> .. tostring(client_id)
    r:hset(key, <span class="st">"ip"</span>, self.peer_ip(client_id))
    r:expire(key, <span class="nb">3600</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id)
    r:srem(<span class="st">"socketley:online"</span>, tostring(client_id))
    r:del(<span class="st">"session:"</span> .. tostring(client_id))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="cm">-- Distributed rate limiting — shared across all server instances</span>
    <span class="kw">local</span> key = <span class="st">"rl:"</span> .. self.peer_ip(client_id)
    <span class="kw">local</span> n   = r:incr(key)
    <span class="kw">if</span> n == <span class="nb">1</span> <span class="kw">then</span> r:expire(key, <span class="nb">1</span>) <span class="kw">end</span>   <span class="cm">-- 1-second window</span>
    <span class="kw">if</span> n > RATE_LIMIT <span class="kw">then</span>
        self.send(client_id, <span class="st">"ERROR rate limit exceeded"</span>)
        self.disconnect(client_id)
        <span class="kw">return</span>
    <span class="kw">end</span>
    self.broadcast(msg)
<span class="kw">end</span></code></pre>

<div class="warn-box"><strong>Blocking calls.</strong> <code>redis-lua</code> uses synchronous sockets and blocks the io_uring event loop for the duration of each Redis round-trip. Keep calls in <code>on_start</code>/<code>on_stop</code> or rate-limit how often they fire in <code>on_client_message</code>. For high-frequency paths, batch writes in a local table and flush in <code>on_tick</code>.</div>

<p>Full example: <code>examples/server/redis-session.lua</code></p>


<h2 id="addons-session-ids">Session IDs &amp; Tracing</h2>
<p>Assign a UUID to each connection for end-to-end tracing across logs, metrics, and external systems. Pairs naturally with <code>cjson</code> (embed in outbound JSON envelopes) and <code>redis-lua</code> (use as the session store key).</p>

<pre><code><span class="cm">-- luarocks install uuid</span>
<span class="kw">local</span> uuid  = require <span class="st">"uuid"</span>
<span class="kw">local</span> cjson = require <span class="st">"cjson"</span>
uuid.seed()

<span class="kw">local</span> session_ids = {}

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)
    session_ids[client_id] = uuid()
    socketley.log(<span class="st">"connect sid="</span> .. session_ids[client_id]
                  .. <span class="st">" ip="</span> .. self.peer_ip(client_id))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id)
    socketley.log(<span class="st">"disconnect sid="</span> .. (session_ids[client_id] <span class="kw">or</span> <span class="st">"?"</span>))
    session_ids[client_id] = <span class="kw">nil</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="cm">-- Embed the session ID in every outbound message for distributed tracing</span>
    self.broadcast(cjson.encode({
        sid  = session_ids[client_id],
        from = client_id,
        data = msg,
    }))
<span class="kw">end</span></code></pre>

<div class="info-box"><strong>Tip — combine with redis-lua.</strong> Use the UUID as the Redis session store key (<code>r:hset("session:" .. session_ids[client_id], ...)</code>) so the same correlation ID flows from the TCP layer through your Redis session store and into your logs.</div>

<p>Full example: <code>examples/server/session-ids.lua</code></p>

</div><!-- #content-addons -->

<!-- ═══════════════════════════════════════════
     EXAMPLES TAB CONTENT
═══════════════════════════════════════════ -->
<div id="content-examples" class="content" style="display:none">

<!-- ── Getting Started ── -->
<h2 id="ex-getting-started">Getting Started</h2>
<p>The basics: create runtimes, connect them, and see output. These examples use only CLI flags &mdash; no Lua required.</p>

<div class="method-card" id="ex-hello-server">
<div class="method-header">
  <span class="method-name">Hello Server</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">Create a TCP server listening on port 9000. This is the simplest possible runtime &mdash; it accepts connections and broadcasts any message it receives to all connected clients.</p>
<pre><code>socketley create server hello-server -p 9000 -s --log /tmp/hello-server.log</code></pre>
<pre><code><span class="cm"># Test with netcat from another terminal:</span>
nc localhost 9000</code></pre>
</div>

<div class="method-card" id="ex-hello-client">
<div class="method-header">
  <span class="method-name">Hello Client</span>
  <span class="badge badge-client">client</span>
</div>
<p class="method-desc">Create a client that connects to an existing server. The <code>-t</code> flag specifies the target address. Make sure the server from the previous example is running first.</p>
<pre><code>socketley create client hello-client -t 127.0.0.1:9000 -s --log /tmp/hello-client.log</code></pre>
</div>

<div class="method-card" id="ex-combined">
<div class="method-header">
  <span class="method-name">Combined Setup</span>
  <span class="badge badge-server">server</span>
  <span class="badge badge-client">client</span>
</div>
<p class="method-desc">A complete script that creates both a server and client, with message logging via <code>-w</code>. Demonstrates the typical create &rarr; start &rarr; use &rarr; stop &rarr; remove lifecycle with cleanup on exit.</p>
<pre><code><span class="cm"># Create server with message logging</span>
socketley create server demo-server -p 9000 -w /tmp/demo-server-messages.txt
socketley start demo-server

<span class="cm"># Create client that connects to it</span>
socketley create client demo-client -t 127.0.0.1:9000 -w /tmp/demo-client-messages.txt
socketley start demo-client

<span class="cm"># Check status</span>
socketley ps

<span class="cm"># Cleanup</span>
socketley stop demo-client demo-server
socketley remove demo-client demo-server</code></pre>
</div>

<div class="method-card" id="ex-bash-output">
<div class="method-header">
  <span class="method-name">Bash Output Modes</span>
  <span class="badge badge-all">all types</span>
</div>
<p class="method-desc">The <code>-b</code> flag family pipes received messages to stdout, useful for scripting and monitoring. Combine with <code>-p</code> (prefix with runtime name) and <code>-t</code> (timestamp) for formatted output.</p>
<pre><code><span class="cm"># Raw output</span>
socketley create server raw-echo -p 9001 -b -s
<span class="cm"># Output: hello world</span>

<span class="cm"># With runtime name prefix</span>
socketley create server prefix-echo -p 9002 -bp -s
<span class="cm"># Output: [prefix-echo] hello world</span>

<span class="cm"># With timestamp</span>
socketley create server time-echo -p 9003 -bt -s
<span class="cm"># Output: [14:32:05] hello world</span>

<span class="cm"># Both prefix and timestamp</span>
socketley create server full-echo -p 9004 -bpt -s
<span class="cm"># Output: [14:32:05] [full-echo] hello world</span></code></pre>
</div>

<!-- ── Server & Client ── -->
<h2 id="ex-server-client">Server &amp; Client</h2>
<p>Common server-client patterns: echo, broadcast, bidirectional chat, and message mode control.</p>

<div class="method-card" id="ex-echo-server">
<div class="method-header">
  <span class="method-name">Echo Server</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">A Lua-powered echo server. The <code>on_message</code> callback intercepts every incoming message and broadcasts it back to all connected clients. The simplest useful Lua script.</p>
<pre><code><span class="cm">-- echo-server.lua</span>
<span class="kw">function</span> <span class="fn">on_message</span>(msg)
    socketley.log(<span class="st">"Received: "</span> .. msg)
    self.broadcast(msg)
<span class="kw">end</span></code></pre>
<pre><code>socketley create server echo-server -p 9000 --lua echo-server.lua -s</code></pre>
</div>

<div class="method-card" id="ex-broadcast">
<div class="method-header">
  <span class="method-name">Broadcast</span>
  <span class="badge badge-server">server</span>
  <span class="badge badge-client">client</span>
</div>
<p class="method-desc">One server, multiple clients. Any message sent to the server is broadcast to all connected clients. Each client logs received messages to a file via <code>-w</code>.</p>
<pre><code><span class="cm"># Create server</span>
socketley create server broadcast-hub -p 9000 -s

<span class="cm"># Connect 3 clients, each logging to a file</span>
socketley create client client-1 -t 127.0.0.1:9000 -w /tmp/client-1.txt -s
socketley create client client-2 -t 127.0.0.1:9000 -w /tmp/client-2.txt -s
socketley create client client-3 -t 127.0.0.1:9000 -w /tmp/client-3.txt -s

<span class="cm"># Send a message via netcat — all 3 clients receive it</span>
echo <span class="st">"hello everyone"</span> | nc localhost 9000</code></pre>
</div>

<div class="method-card" id="ex-bidirectional">
<div class="method-header">
  <span class="method-name">Bidirectional Chat</span>
  <span class="badge badge-server">server</span>
  <span class="badge badge-client">client</span>
</div>
<p class="method-desc">Full-duplex communication with timestamped messages. The server script prepends timestamps to broadcasts, and clients receive all messages from all participants.</p>
<pre><code><span class="cm">-- chat-server.lua</span>
<span class="kw">function</span> <span class="fn">on_message</span>(msg)
    self.broadcast(<span class="st">"["</span> .. os.date(<span class="st">"%H:%M:%S"</span>) .. <span class="st">"] "</span> .. msg)
<span class="kw">end</span></code></pre>
<pre><code>socketley create server chat -p 9000 --lua chat-server.lua -s
socketley create client alice -t 127.0.0.1:9000 -w /tmp/alice.txt -s
socketley create client bob -t 127.0.0.1:9000 -w /tmp/bob.txt -s</code></pre>
</div>

<div class="method-card" id="ex-modes">
<div class="method-header">
  <span class="method-name">Message Modes</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">Compare the three message flow modes. <code>inout</code> is bidirectional (default), <code>in</code> receives only (useful for log collectors), and <code>out</code> sends only (ignores incoming data).</p>
<pre><code><span class="cm"># Bidirectional — receives and broadcasts</span>
socketley create server srv-inout -p 9001 --mode inout -s

<span class="cm"># Receive-only — accepts messages, never responds</span>
socketley create server srv-in -p 9002 --mode in -w /tmp/received.txt -s

<span class="cm"># Send-only — broadcasts only, ignores input</span>
socketley create server srv-out -p 9003 --mode out -s</code></pre>
</div>

<!-- ── Proxy ── -->
<h2 id="ex-proxy-cat">Proxy</h2>
<p>Reverse proxying, load balancing, group-based discovery, and custom Lua routing. Backends can be IP:port addresses, runtime names, or <code>@group</code> references.</p>

<div class="method-card" id="ex-http-proxy">
<div class="method-header">
  <span class="method-name">HTTP Reverse Proxy</span>
  <span class="badge badge-proxy">proxy</span>
</div>
<p class="method-desc">Forward HTTP requests from a public-facing port to an internal backend server. The simplest proxy setup &mdash; one frontend, one backend.</p>
<pre><code>socketley create server backend-api -p 9001 -s
socketley create proxy gateway -p 8080 --backend 127.0.0.1:9001 --protocol http -s

<span class="cm"># Requests to :8080 are forwarded to :9001</span>
curl localhost:8080/gateway/api/data</code></pre>
</div>

<div class="method-card" id="ex-load-balancer">
<div class="method-header">
  <span class="method-name">Load Balancer</span>
  <span class="badge badge-proxy">proxy</span>
</div>
<p class="method-desc">Distribute HTTP traffic across multiple backend servers using round-robin. Add or remove backends at any time. Other strategies available: <code>random</code> and <code>lua</code>.</p>
<pre><code>socketley create server api-1 -p 9001 -s
socketley create server api-2 -p 9002 -s
socketley create server api-3 -p 9003 -s

socketley create proxy lb -p 8080 \
    --backend 127.0.0.1:9001,127.0.0.1:9002,127.0.0.1:9003 \
    --strategy round-robin --protocol http -s

<span class="cm"># Requests cycle: api-1 → api-2 → api-3 → api-1 → ...</span></code></pre>
</div>

<div class="method-card" id="ex-group-discovery">
<div class="method-header">
  <span class="method-name">Group Discovery</span>
  <span class="badge badge-proxy">proxy</span>
</div>
<p class="method-desc">Tag runtimes with <code>-g &lt;group&gt;</code> and use <code>@group</code> as a proxy backend. The proxy discovers all running group members <strong>at connection time</strong> &mdash; add or remove members dynamically without touching the proxy.</p>
<pre><code><span class="cm"># Tag servers with a group</span>
socketley create server api-1 -p 9001 -g api -s
socketley create server api-2 -p 9002 -g api -s

<span class="cm"># Proxy discovers group members dynamically</span>
socketley create proxy gw -p 8080 --backend @api --strategy round-robin -s

<span class="cm"># Scale up: add a new member without restarting the proxy</span>
socketley create server api-3 -p 9003 -g api -s
<span class="cm"># Next connection automatically includes api-3 in the pool</span>

<span class="cm"># Scale down: stop a member and it's excluded automatically</span>
socketley stop api-2
<span class="cm"># Proxy routes only to api-1 and api-3</span>

<span class="cm"># Mix groups with static backends</span>
socketley create proxy gw2 -p 8081 --backend @api,10.0.0.5:9000 -s</code></pre>
</div>

<div class="method-card" id="ex-tcp-proxy">
<div class="method-header">
  <span class="method-name">TCP Proxy</span>
  <span class="badge badge-proxy">proxy</span>
</div>
<p class="method-desc">Raw TCP byte forwarding with no HTTP parsing. Protocol-agnostic &mdash; works with any TCP protocol (databases, custom binary protocols, TLS passthrough).</p>
<pre><code>socketley create server tcp-backend -p 9001 -s
socketley create proxy tcp-gw -p 8080 --backend 127.0.0.1:9001 --protocol tcp -s

<span class="cm"># Raw bytes forwarded in both directions</span>
nc localhost 8080</code></pre>
</div>

<div class="method-card" id="ex-name-backend">
<div class="method-header">
  <span class="method-name">Runtime-Name Backends</span>
  <span class="badge badge-proxy">proxy</span>
</div>
<p class="method-desc">Reference backends by their runtime name instead of IP:port. The proxy resolves names to addresses automatically via the runtime manager &mdash; no hardcoded ports needed.</p>
<pre><code>socketley create server api-service -p 9001 -s
socketley create server auth-service -p 9002 -s

<span class="cm"># Use names instead of addresses</span>
socketley create proxy gateway -p 8080 \
    --backend api-service,auth-service \
    --strategy round-robin --protocol http -s</code></pre>
</div>

<div class="method-card" id="ex-lua-routing">
<div class="method-header">
  <span class="method-name">Lua Routing</span>
  <span class="badge badge-proxy">proxy</span>
</div>
<p class="method-desc">Custom routing logic via the <code>on_route(method, path)</code> callback. Route requests to different backends based on HTTP method, URL path, or any combination. Return a 0-based backend index.</p>
<pre><code><span class="cm">-- multi-backend.lua</span>
runtimes = {
    { type = <span class="st">"server"</span>, name = <span class="st">"read-backend"</span>,  port = <span class="nb">9001</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"write-backend"</span>, port = <span class="nb">9002</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"admin-backend"</span>, port = <span class="nb">9003</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"proxy"</span>,  name = <span class="st">"smart-proxy"</span>,   port = <span class="nb">8080</span>,
      protocol = <span class="st">"http"</span>, strategy = <span class="st">"lua"</span>,
      backends = { <span class="st">"127.0.0.1:9001"</span>, <span class="st">"127.0.0.1:9002"</span>, <span class="st">"127.0.0.1:9003"</span> },
      start = <span class="kw">true</span> }
}

<span class="kw">function</span> <span class="fn">on_route</span>(method, path)
    <span class="kw">if</span> path:match(<span class="st">"^/admin"</span>) <span class="kw">then</span> <span class="kw">return</span> <span class="nb">2</span> <span class="kw">end</span>
    <span class="kw">if</span> method == <span class="st">"POST"</span> <span class="kw">or</span> method == <span class="st">"PUT"</span> <span class="kw">or</span> method == <span class="st">"DELETE"</span> <span class="kw">then</span> <span class="kw">return</span> <span class="nb">1</span> <span class="kw">end</span>
    <span class="kw">return</span> <span class="nb">0</span>
<span class="kw">end</span></code></pre>
<pre><code>socketley --lua multi-backend.lua</code></pre>
</div>

<!-- ── Cache ── -->
<h2 id="ex-cache-cat">Cache</h2>
<p>In-memory key-value store with persistence, RESP2 (Redis-compatible), data structures, pub/sub, replication, and database backend hooks.</p>

<div class="method-card" id="ex-basic-cache">
<div class="method-header">
  <span class="method-name">Basic Cache</span>
  <span class="badge badge-cache">cache</span>
</div>
<p class="method-desc">An in-memory key-value store listening on a TCP port. Supports plaintext commands over netcat. Data lives in memory only &mdash; lost when the cache stops.</p>
<pre><code>socketley create cache my-cache -p 9000 -s

<span class="cm"># Store and retrieve data</span>
echo <span class="st">"set user alice"</span> | nc -q1 localhost 9000
echo <span class="st">"get user"</span> | nc -q1 localhost 9000</code></pre>
</div>

<div class="method-card" id="ex-persistent-cache">
<div class="method-header">
  <span class="method-name">Persistent Cache</span>
  <span class="badge badge-cache">cache</span>
</div>
<p class="method-desc">Add <code>--persistent</code> to save data to disk on shutdown and reload it on startup. Data survives restarts. The <code>flush</code> command triggers an immediate save.</p>
<pre><code>socketley create cache persistent-store -p 9000 \
    --persistent /tmp/cache-data.bin -s

<span class="cm"># Data survives stop/start cycles:</span>
echo <span class="st">"set mykey myval"</span> | nc -q1 localhost 9000
socketley stop persistent-store
socketley start persistent-store
echo <span class="st">"get mykey"</span> | nc -q1 localhost 9000   <span class="cm"># → myval</span></code></pre>
</div>

<div class="method-card" id="ex-cache-modes">
<div class="method-header">
  <span class="method-name">Access Modes</span>
  <span class="badge badge-cache">cache</span>
</div>
<p class="method-desc">Control what operations clients can perform. <code>readonly</code> allows only GET, <code>readwrite</code> allows GET/SET/DEL but not admin commands, and <code>admin</code> allows everything including <code>flush</code> and <code>load</code>.</p>
<pre><code><span class="cm"># Read-only: GET allowed, SET denied</span>
socketley create cache ro-cache -p 9001 --mode readonly -s

<span class="cm"># Read-write: GET + SET allowed, flush denied</span>
socketley create cache rw-cache -p 9002 --mode readwrite -s

<span class="cm"># Admin: all operations including flush/load</span>
socketley create cache admin-cache -p 9003 --mode admin -s</code></pre>
</div>

<div class="method-card" id="ex-resp-mode">
<div class="method-header">
  <span class="method-name">RESP Mode (Redis-Compatible)</span>
  <span class="badge badge-cache">cache</span>
</div>
<p class="method-desc">Force the RESP2 wire protocol with <code>--resp</code> for full compatibility with <code>redis-cli</code> and any Redis client library (Python redis, Node ioredis, Go redigo, etc.).</p>
<pre><code>socketley create cache myredis -p 6379 --resp -s

<span class="cm"># Use standard redis-cli</span>
redis-cli -p 6379 SET greeting <span class="st">"Hello, World!"</span>
redis-cli -p 6379 GET greeting
redis-cli -p 6379 HSET user:1 name <span class="st">"Alice"</span> age <span class="st">"30"</span>
redis-cli -p 6379 HGETALL user:1
redis-cli -p 6379 PING</code></pre>
</div>

<div class="method-card" id="ex-datastructures">
<div class="method-header">
  <span class="method-name">Data Structures</span>
  <span class="badge badge-cache">cache</span>
</div>
<p class="method-desc">Beyond simple strings: lists (deque-backed task queues), sets (unique membership), hashes (field-value maps), and TTL-based expiry. One type per key, enforced at runtime.</p>
<pre><code><span class="cm"># Lists — task queue</span>
echo -e <span class="st">"rpush tasks build\nrpush tasks test\nrpush tasks deploy"</span> | nc -q1 localhost 9000
echo <span class="st">"lpop tasks"</span> | nc -q1 localhost 9000   <span class="cm"># → build</span>

<span class="cm"># Sets — unique tags</span>
echo -e <span class="st">"sadd tags linux\nsadd tags io-uring\nsmembers tags"</span> | nc -q1 localhost 9000

<span class="cm"># Hashes — user profile</span>
echo -e <span class="st">"hset user:1 name Alice\nhset user:1 role admin\nhgetall user:1"</span> | nc -q1 localhost 9000

<span class="cm"># TTL — auto-expire after 30 seconds</span>
echo -e <span class="st">"set session abc123\nexpire session 30\nttl session"</span> | nc -q1 localhost 9000</code></pre>
</div>

<div class="method-card" id="ex-pubsub">
<div class="method-header">
  <span class="method-name">Pub/Sub</span>
  <span class="badge badge-cache">cache</span>
</div>
<p class="method-desc">Publish/subscribe messaging through the cache. Subscribers receive messages in real time on named channels. Multiple subscribers per channel, multiple channels per client.</p>
<pre><code>socketley create cache pubstore -p 9000 -s

<span class="cm"># Terminal 1: subscribe</span>
(echo <span class="st">"subscribe news"</span>; sleep 60) | nc localhost 9000

<span class="cm"># Terminal 2: publish</span>
echo <span class="st">"publish news breaking-update"</span> | nc -q1 localhost 9000</code></pre>
</div>

<div class="method-card" id="ex-replication">
<div class="method-header">
  <span class="method-name">Replication</span>
  <span class="badge badge-cache">cache</span>
</div>
<p class="method-desc">Leader-follower replication. Writes go to the leader and are automatically replicated to followers. Read from followers to distribute load.</p>
<pre><code><span class="cm"># Create leader</span>
socketley create cache leader -p 9000 -s

<span class="cm"># Create follower that syncs from leader</span>
socketley create cache follower -p 9001 --replicate 127.0.0.1:9000 -s

<span class="cm"># Write to leader</span>
echo <span class="st">"set user alice"</span> | nc -q1 localhost 9000

<span class="cm"># Read from follower — replicated automatically</span>
echo <span class="st">"get user"</span> | nc -q1 localhost 9001   <span class="cm"># → alice</span></code></pre>
</div>

<div class="method-card" id="ex-db-backend">
<div class="method-header">
  <span class="method-name">Database Backend</span>
  <span class="badge badge-cache">cache</span>
</div>
<p class="method-desc">Wire the cache to any database with four Lua callbacks: <code>on_miss</code> (read-through), <code>on_write</code> (write-behind/write-through), <code>on_delete</code>, and <code>on_expire</code>. Works with SQLite, MySQL, and PostgreSQL via luarocks libraries.</p>
<pre><code><span class="cm">-- db-backend.lua (SQLite example, trimmed)</span>
<span class="kw">local</span> db, pending = <span class="kw">nil</span>, {}
tick_ms = <span class="nb">2000</span>

<span class="kw">function</span> <span class="fn">on_start</span>()
    db = require(<span class="st">"lsqlite3"</span>).open(<span class="st">"/tmp/cache.db"</span>)
    db:exec(<span class="st">"CREATE TABLE IF NOT EXISTS cache_kv (key TEXT PRIMARY KEY, value TEXT)"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_miss</span>(key)
    <span class="kw">for</span> row <span class="kw">in</span> db:nrows(<span class="st">"SELECT value FROM cache_kv WHERE key="</span> .. db:quote(key)) <span class="kw">do</span>
        <span class="kw">return</span> row.value, <span class="nb">300</span>
    <span class="kw">end</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_write</span>(key, value, ttl)  pending[key] = value  <span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">if not</span> next(pending) <span class="kw">then</span> <span class="kw">return</span> <span class="kw">end</span>
    <span class="kw">for</span> k, v <span class="kw">in</span> pairs(pending) <span class="kw">do</span>
        db:exec(<span class="st">"INSERT OR REPLACE INTO cache_kv(key,value) VALUES("</span>
                ..db:quote(k)..<span class="st">","</span>..db:quote(v)..<span class="st">")"</span>)
    <span class="kw">end</span>
    pending = {}
<span class="kw">end</span>
<span class="cm">-- (see full example in examples/cache/db-backend.lua)</span></code></pre>
<pre><code>socketley create cache mydb -p 9000 --lua db-backend.lua -s</code></pre>
</div>

<div class="method-card" id="ex-cache-integration">
<div class="method-header">
  <span class="method-name">Cache + Server Integration</span>
  <span class="badge badge-cache">cache</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">Use the cache as a shared data store between runtimes. An orchestration Lua script creates a persistent cache, an API server, and a client &mdash; the server reads and writes the shared cache directly from Lua.</p>
<pre><code><span class="cm">-- cache-integration.lua</span>
runtimes = {
    { type = <span class="st">"cache"</span>,  name = <span class="st">"shared-state"</span>, port = <span class="nb">9000</span>,
      persistent = <span class="st">"/tmp/shared-state.bin"</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"api-server"</span>,   port = <span class="nb">9001</span>, start = <span class="kw">true</span> },
}

<span class="kw">function</span> <span class="fn">on_message</span>(msg)
    <span class="kw">local</span> cmd, key, value = msg:match(<span class="st">"^(%w+)%s+(%S+)%s*(.*)"</span>)
    <span class="kw">if</span> cmd == <span class="st">"GET"</span> <span class="kw">then</span>
        self.send(self.get(key) <span class="kw">or</span> <span class="st">"NOT_FOUND"</span>)
    <span class="kw">elseif</span> cmd == <span class="st">"SET"</span> <span class="kw">then</span>
        self.set(key, value); self.send(<span class="st">"OK"</span>)
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<pre><code>socketley --lua cache-integration.lua</code></pre>
</div>

<!-- ── Server Addons ── -->
<h2 id="ex-server-addons">Server Addons</h2>
<p>Extend servers with auth, rate limiting, session management, service discovery, and more &mdash; all in pure Lua using the addon primitives (<code>on_auth</code>, <code>self.disconnect</code>, <code>self.peer_ip</code>, <code>socketley.http</code>).</p>

<div class="method-card" id="ex-ip-allowlist">
<div class="method-header">
  <span class="method-name">IP Allowlist</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">Network-level admission control. The <code>on_auth</code> callback fires immediately after TCP accept, before <code>on_connect</code>. Check the client's IP with <code>self.peer_ip</code> and return <code>false</code> to reject. Fail-closed: Lua errors also reject.</p>
<pre><code><span class="cm">-- auth-ip-allowlist.lua</span>
<span class="kw">local</span> allowed_prefix = <span class="st">"192.168."</span>

<span class="kw">function</span> <span class="fn">on_auth</span>(client_id)
    <span class="kw">local</span> ip = self.peer_ip(client_id)
    <span class="kw">local</span> ok = ip:sub(<span class="nb">1</span>, #allowed_prefix) == allowed_prefix
    <span class="kw">if not</span> ok <span class="kw">then</span> socketley.log(<span class="st">"rejected: "</span> .. ip) <span class="kw">end</span>
    <span class="kw">return</span> ok
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    self.broadcast(<span class="st">"["</span> .. tostring(client_id) .. <span class="st">"] "</span> .. msg)
<span class="kw">end</span></code></pre>
<pre><code>socketley create server authtest -p 9000 --lua auth-ip-allowlist.lua -s</code></pre>
</div>

<div class="method-card" id="ex-token-auth">
<div class="method-header">
  <span class="method-name">Token Authentication</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">First-message token auth. Clients must send a secret as their first message &mdash; authenticated clients get broadcast access, others are disconnected with <code>self.disconnect</code>.</p>
<pre><code><span class="cm">-- auth-token.lua</span>
<span class="kw">local</span> SECRET = <span class="st">"my-secret-token"</span>
<span class="kw">local</span> authenticated = {}

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)    authenticated[client_id] = <span class="kw">false</span> <span class="kw">end</span>
<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id) authenticated[client_id] = <span class="kw">nil</span>   <span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="kw">if not</span> authenticated[client_id] <span class="kw">then</span>
        <span class="kw">if</span> msg == SECRET <span class="kw">then</span>
            authenticated[client_id] = <span class="kw">true</span>
            self.send(client_id, <span class="st">"AUTH OK"</span>)
        <span class="kw">else</span>
            self.send(client_id, <span class="st">"AUTH FAIL"</span>)
            self.disconnect(client_id)
        <span class="kw">end</span>
        <span class="kw">return</span>
    <span class="kw">end</span>
    self.broadcast(<span class="st">"["</span> .. tostring(client_id) .. <span class="st">"] "</span> .. msg)
<span class="kw">end</span></code></pre>
<pre><code>socketley create server auth -p 9000 --lua auth-token.lua -s</code></pre>
</div>

<div class="method-card" id="ex-rate-limit">
<div class="method-header">
  <span class="method-name">Rate Limiting</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">Per-client message throttling. Counts messages per client and resets every tick interval (1 second). Clients exceeding the limit are disconnected. Pure Lua, no external deps.</p>
<pre><code><span class="cm">-- rate-limit.lua: 10 messages per second per client</span>
<span class="kw">local</span> MAX_MSGS = <span class="nb">10</span>
<span class="kw">local</span> counts   = {}
tick_ms = <span class="nb">1000</span>

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)    counts[client_id] = <span class="nb">0</span>   <span class="kw">end</span>
<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id) counts[client_id] = <span class="kw">nil</span> <span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    counts[client_id] = (counts[client_id] <span class="kw">or</span> <span class="nb">0</span>) + <span class="nb">1</span>
    <span class="kw">if</span> counts[client_id] > MAX_MSGS <span class="kw">then</span>
        self.send(client_id, <span class="st">"ERROR rate limit exceeded"</span>)
        self.disconnect(client_id)
        <span class="kw">return</span>
    <span class="kw">end</span>
    self.broadcast(msg)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_tick</span>(dt)
    <span class="kw">for</span> id <span class="kw">in</span> pairs(counts) <span class="kw">do</span> counts[id] = <span class="nb">0</span> <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<pre><code>socketley create server limited -p 9000 --lua rate-limit.lua -s</code></pre>
</div>

<div class="method-card" id="ex-session-ids">
<div class="method-header">
  <span class="method-name">UUID Session IDs</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">Assign a UUID to every connection for end-to-end distributed tracing. Session IDs are embedded in every outbound JSON envelope, making it easy to correlate events across logs and external systems.</p>
<pre><code><span class="cm">-- session-ids.lua (requires: luarocks install uuid)</span>
<span class="kw">local</span> uuid  = require <span class="st">"uuid"</span>
<span class="kw">local</span> cjson = require <span class="st">"cjson"</span>
uuid.seed()

<span class="kw">local</span> session_ids = {}

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)
    session_ids[client_id] = uuid()
    socketley.log(<span class="st">"connect sid="</span> .. session_ids[client_id]
                  .. <span class="st">" ip="</span> .. self.peer_ip(client_id))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id)
    session_ids[client_id] = <span class="kw">nil</span>
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    self.broadcast(cjson.encode({
        sid = session_ids[client_id], from = client_id, data = msg,
    }))
<span class="kw">end</span></code></pre>
<pre><code>socketley create server traced -p 9000 --lua session-ids.lua -s</code></pre>
</div>

<div class="method-card" id="ex-redis-session">
<div class="method-header">
  <span class="method-name">Redis Distributed Sessions</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">Shared state via an external Redis instance using <code>redis-lua</code>. Enables distributed rate limiting (INCR/EXPIRE per IP), presence tracking (SADD/SREM), and per-connection session data across multiple Socketley instances.</p>
<pre><code><span class="cm">-- redis-session.lua (requires: luarocks install redis-lua)</span>
<span class="kw">local</span> redis = require <span class="st">"redis"</span>
<span class="kw">local</span> r     = redis.connect(<span class="st">"127.0.0.1"</span>, <span class="nb">6379</span>)
<span class="kw">local</span> RATE_LIMIT = <span class="nb">20</span>

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)
    r:sadd(<span class="st">"socketley:online"</span>, tostring(client_id))
    <span class="kw">local</span> key = <span class="st">"session:"</span> .. tostring(client_id)
    r:hset(key, <span class="st">"ip"</span>, self.peer_ip(client_id))
    r:expire(key, <span class="nb">3600</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="kw">local</span> key = <span class="st">"rl:"</span> .. self.peer_ip(client_id)
    <span class="kw">local</span> n = r:incr(key)
    <span class="kw">if</span> n == <span class="nb">1</span> <span class="kw">then</span> r:expire(key, <span class="nb">1</span>) <span class="kw">end</span>
    <span class="kw">if</span> n > RATE_LIMIT <span class="kw">then</span>
        self.send(client_id, <span class="st">"ERROR rate limit exceeded"</span>)
        self.disconnect(client_id)
        <span class="kw">return</span>
    <span class="kw">end</span>
    self.broadcast(msg)
<span class="kw">end</span></code></pre>
<pre><code>socketley create server distributed -p 9000 --lua redis-session.lua -s</code></pre>
</div>

<div class="method-card" id="ex-service-discovery">
<div class="method-header">
  <span class="method-name">Service Discovery (Consul)</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">Automatic Consul registration via <code>socketley.http</code>. Registers the runtime as a service on start and deregisters on stop. The same pattern works with etcd, Eureka, or any REST-based registry.</p>
<pre><code><span class="cm">-- service-discovery.lua</span>
<span class="kw">local</span> CONSUL = <span class="st">"http://127.0.0.1:8500"</span>

<span class="kw">function</span> <span class="fn">on_start</span>()
    <span class="kw">local</span> payload = string.format(
        <span class="st">'{"ID":"%s","Name":"%s","Port":%d,"Address":"127.0.0.1"}'</span>,
        self.name, self.name, self.port)
    socketley.http({
        method  = <span class="st">"PUT"</span>,
        url     = CONSUL .. <span class="st">"/v1/agent/service/register"</span>,
        body    = payload,
        headers = { [<span class="st">"Content-Type"</span>] = <span class="st">"application/json"</span> },
    })
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_stop</span>()
    socketley.http({
        method = <span class="st">"PUT"</span>,
        url    = CONSUL .. <span class="st">"/v1/agent/service/deregister/"</span> .. self.name,
    })
<span class="kw">end</span></code></pre>
<pre><code>socketley create server myapi -p 9000 --lua service-discovery.lua -s</code></pre>
</div>

<div class="method-card" id="ex-ws-session">
<div class="method-header">
  <span class="method-name">WebSocket Session Tracking</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">Track browser sessions via WebSocket upgrade headers. The <code>on_websocket</code> callback fires after the handshake with <code>Cookie</code>, <code>Origin</code>, and <code>Authorization</code> headers. Session cookies provide a durable identifier that survives fd recycling and IP changes.</p>
<pre><code><span class="cm">-- websocket-session.lua</span>
<span class="kw">local</span> cjson    = require <span class="st">"cjson"</span>
<span class="kw">local</span> sessions = {}

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)
    sessions[client_id] = { sid = tostring(client_id), ip = self.peer_ip(client_id) }
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_websocket</span>(client_id, headers)
    <span class="kw">local</span> sid = sessions[client_id] <span class="kw">and</span> sessions[client_id].sid <span class="kw">or</span> tostring(client_id)
    <span class="kw">if</span> headers.cookie <span class="kw">then</span>
        sid = headers.cookie:match(<span class="st">"session_id=([^;%s]+)"</span>) <span class="kw">or</span> sid
    <span class="kw">end</span>
    sessions[client_id] = { sid = sid, ip = self.peer_ip(client_id),
                            origin = headers.origin <span class="kw">or</span> <span class="st">"unknown"</span> }
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="kw">local</span> s = sessions[client_id] <span class="kw">or</span> {}
    self.broadcast(cjson.encode({ sid = s.sid, data = msg }))
<span class="kw">end</span></code></pre>
<pre><code>socketley create server ws-test -p 9000 --lua websocket-session.lua -s
wscat --header <span class="st">"Cookie: session_id=abc123"</span> --connect ws://localhost:9000</code></pre>
</div>

<div class="method-card" id="ex-http-dashboard">
<div class="method-header">
  <span class="method-name">HTTP Dashboard</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">Serve a static HTML/CSS dashboard via the <code>--http</code> flag and handle WebSocket messages in Lua. The page loads with an auto-injected <code>socketley</code> WebSocket global for real-time communication.</p>
<pre><code><span class="cm">-- http-dashboard.lua</span>
<span class="kw">local</span> clients = {}

<span class="kw">function</span> <span class="fn">on_connect</span>(id)
    clients[id] = <span class="kw">true</span>
    self.broadcast(<span class="st">"system: client "</span> .. id .. <span class="st">" joined"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_disconnect</span>(id)
    clients[id] = <span class="kw">nil</span>
    self.broadcast(<span class="st">"system: client "</span> .. id .. <span class="st">" left"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(id, msg)
    self.broadcast(<span class="st">"["</span> .. id .. <span class="st">"] "</span> .. msg)
<span class="kw">end</span></code></pre>
<pre><code>socketley create server dashboard -p 8080 \
    --http ./examples/server/http-dashboard/ \
    --lua http-dashboard.lua -s
<span class="cm"># Open http://localhost:8080 in a browser</span></code></pre>
</div>

<!-- ── Lua Configuration ── -->
<h2 id="ex-lua-config">Lua Configuration</h2>
<p>Orchestrate multiple runtimes from a single Lua file using the <code>runtimes</code> table and lifecycle callbacks.</p>

<div class="method-card" id="ex-simple-config">
<div class="method-header">
  <span class="method-name">Simple Config</span>
  <span class="badge badge-all">all types</span>
</div>
<p class="method-desc">The <code>runtimes</code> table is the simplest way to declare multiple runtimes in one file. Each entry specifies the type, name, port, and optional flags. Run with <code>socketley --lua</code>.</p>
<pre><code><span class="cm">-- simple-config.lua</span>
runtimes = {
    { type = <span class="st">"server"</span>, name = <span class="st">"my-server"</span>, port = <span class="nb">9000</span>,
      mode = <span class="st">"inout"</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"client"</span>, name = <span class="st">"my-client"</span>,
      target = <span class="st">"127.0.0.1:9000"</span>, start = <span class="kw">true</span> },
}

<span class="kw">function</span> <span class="fn">on_start</span>()
    socketley.log(self.name .. <span class="st">" started on port "</span> .. tostring(self.port))
<span class="kw">end</span></code></pre>
<pre><code>socketley --lua simple-config.lua</code></pre>
</div>

<div class="method-card" id="ex-callbacks">
<div class="method-header">
  <span class="method-name">Lifecycle Callbacks</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">All available callbacks demonstrated: <code>on_start</code>, <code>on_stop</code>, <code>on_message</code>, and <code>on_send</code>. Each fires at a specific lifecycle event. All are optional &mdash; define only the ones you need.</p>
<pre><code><span class="cm">-- callbacks.lua</span>
runtimes = {
    { type = <span class="st">"server"</span>, name = <span class="st">"callback-demo"</span>, port = <span class="nb">9000</span>, start = <span class="kw">true</span> }
}

<span class="kw">function</span> <span class="fn">on_start</span>()
    socketley.log(<span class="st">"on_start: "</span> .. self.name .. <span class="st">" running on "</span> .. tostring(self.port))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_stop</span>()
    socketley.log(<span class="st">"on_stop: "</span> .. self.name .. <span class="st">" shutting down"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_message</span>(msg)
    self.broadcast(<span class="st">"[ECHO] "</span> .. msg)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_send</span>(msg)
    socketley.log(<span class="st">"on_send: "</span> .. msg)
<span class="kw">end</span></code></pre>
<pre><code>socketley --lua callbacks.lua</code></pre>
</div>

<div class="method-card" id="ex-conn-callbacks">
<div class="method-header">
  <span class="method-name">Connection Callbacks</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">Track individual client connections with <code>on_connect</code> and <code>on_disconnect</code>. Useful for client counting, connection logging, and per-client state management.</p>
<pre><code><span class="cm">-- callbacks-connect.lua</span>
<span class="kw">local</span> clients = {}

<span class="kw">function</span> <span class="fn">on_connect</span>(client_id)
    clients[client_id] = os.time()
    socketley.log(<span class="st">"connected: "</span> .. tostring(client_id))
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_disconnect</span>(client_id)
    <span class="kw">local</span> t = clients[client_id]
    clients[client_id] = <span class="kw">nil</span>
    socketley.log(<span class="st">"disconnected: "</span> .. tostring(client_id)
                  .. <span class="st">" after "</span> .. tostring(os.time() - (t <span class="kw">or</span> <span class="nb">0</span>)) .. <span class="st">"s"</span>)
<span class="kw">end</span></code></pre>
<pre><code>socketley create server tracker -p 9000 --lua callbacks-connect.lua -s</code></pre>
</div>

<div class="method-card" id="ex-custom-routing">
<div class="method-header">
  <span class="method-name">Custom Routing</span>
  <span class="badge badge-proxy">proxy</span>
</div>
<p class="method-desc">A Lua-strategy proxy that routes by content type: static assets go to a static backend, API calls go to an API backend, and compute-heavy requests go to a compute backend. Demonstrates pattern matching in <code>on_route</code>.</p>
<pre><code><span class="cm">-- custom-routing.lua</span>
runtimes = {
    { type = <span class="st">"server"</span>, name = <span class="st">"static-backend"</span>,  port = <span class="nb">9001</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"api-backend"</span>,     port = <span class="nb">9002</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"compute-backend"</span>, port = <span class="nb">9003</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"proxy"</span>,  name = <span class="st">"smart-router"</span>,    port = <span class="nb">8080</span>,
      protocol = <span class="st">"http"</span>, strategy = <span class="st">"lua"</span>,
      backends = { <span class="st">"127.0.0.1:9001"</span>, <span class="st">"127.0.0.1:9002"</span>, <span class="st">"127.0.0.1:9003"</span> },
      start = <span class="kw">true</span> }
}

<span class="kw">function</span> <span class="fn">on_route</span>(method, path)
    <span class="kw">if</span> path:match(<span class="st">"%.css$"</span>) <span class="kw">or</span> path:match(<span class="st">"%.js$"</span>) <span class="kw">or</span> path:match(<span class="st">"^/static/"</span>) <span class="kw">then</span>
        <span class="kw">return</span> <span class="nb">0</span>  <span class="cm">-- static-backend</span>
    <span class="kw">end</span>
    <span class="kw">if</span> path:match(<span class="st">"^/compute/"</span>) <span class="kw">or</span> path:match(<span class="st">"^/ml/"</span>) <span class="kw">then</span>
        <span class="kw">return</span> <span class="nb">2</span>  <span class="cm">-- compute-backend</span>
    <span class="kw">end</span>
    <span class="kw">return</span> <span class="nb">1</span>      <span class="cm">-- api-backend (default)</span>
<span class="kw">end</span></code></pre>
<pre><code>socketley --lua custom-routing.lua</code></pre>
</div>

<div class="method-card" id="ex-full-setup">
<div class="method-header">
  <span class="method-name">Full Production Setup</span>
  <span class="badge badge-all">all types</span>
</div>
<p class="method-desc">A complete 4-layer production-like architecture: persistent cache (data layer), 3 backend services, a Lua-routed API gateway (proxy layer), and inter-service communication clients. Includes path-based routing and lifecycle logging.</p>
<pre><code><span class="cm">-- full-setup.lua (essential excerpt)</span>
<span class="kw">local</span> CONFIG = { base_port = <span class="nb">9000</span>, cache_file = <span class="st">"/tmp/state.bin"</span> }

runtimes = {
    <span class="cm">-- Layer 1: Data</span>
    { type = <span class="st">"cache"</span>,  name = <span class="st">"state-store"</span>,   port = CONFIG.base_port,
      persistent = CONFIG.cache_file, start = <span class="kw">true</span> },
    <span class="cm">-- Layer 2: Services</span>
    { type = <span class="st">"server"</span>, name = <span class="st">"auth-service"</span>,  port = CONFIG.base_port + <span class="nb">1</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"user-service"</span>,  port = CONFIG.base_port + <span class="nb">2</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"order-service"</span>, port = CONFIG.base_port + <span class="nb">3</span>, start = <span class="kw">true</span> },
    <span class="cm">-- Layer 3: Gateway</span>
    { type = <span class="st">"proxy"</span>,  name = <span class="st">"api-gateway"</span>,   port = <span class="nb">8080</span>,
      protocol = <span class="st">"http"</span>, strategy = <span class="st">"lua"</span>,
      backends = { <span class="st">"auth-service"</span>, <span class="st">"user-service"</span>, <span class="st">"order-service"</span> },
      start = <span class="kw">true</span> },
}

<span class="kw">function</span> <span class="fn">on_route</span>(method, path)
    <span class="kw">if</span> path:match(<span class="st">"^/auth"</span>) <span class="kw">then</span> <span class="kw">return</span> <span class="nb">0</span> <span class="kw">end</span>
    <span class="kw">if</span> path:match(<span class="st">"^/users"</span>) <span class="kw">then</span> <span class="kw">return</span> <span class="nb">1</span> <span class="kw">end</span>
    <span class="kw">if</span> path:match(<span class="st">"^/orders"</span>) <span class="kw">then</span> <span class="kw">return</span> <span class="nb">2</span> <span class="kw">end</span>
    <span class="kw">return</span> <span class="nb">1</span>
<span class="kw">end</span>
<span class="cm">-- (see full example in examples/lua-config/full-setup.lua)</span></code></pre>
<pre><code>socketley --lua full-setup.lua</code></pre>
</div>

<!-- ── Advanced ── -->
<h2 id="ex-advanced">Advanced</h2>
<p>Production-grade patterns: microservices, high availability, centralized logging, development environments, game servers, and UDP.</p>

<div class="method-card" id="ex-microservices">
<div class="method-header">
  <span class="method-name">Microservices Architecture</span>
  <span class="badge badge-all">all types</span>
</div>
<p class="method-desc">A complete e-commerce backend with 5 microservices (users, products, orders, inventory, cache) and an API gateway with Lua-based path routing. Demonstrates service isolation, shared state, and clean URL dispatch.</p>
<pre><code><span class="cm">-- microservices.lua (essential excerpt)</span>
runtimes = {
    { type = <span class="st">"cache"</span>,  name = <span class="st">"service-cache"</span>,     port = <span class="nb">9005</span>,
      persistent = <span class="st">"/tmp/micro-cache.bin"</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"user-service"</span>,      port = <span class="nb">9001</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"product-service"</span>,   port = <span class="nb">9002</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"order-service"</span>,     port = <span class="nb">9003</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"inventory-service"</span>, port = <span class="nb">9004</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"proxy"</span>,  name = <span class="st">"api-gateway"</span>,       port = <span class="nb">8080</span>,
      protocol = <span class="st">"http"</span>, strategy = <span class="st">"lua"</span>,
      backends = { <span class="st">"user-service"</span>, <span class="st">"product-service"</span>, <span class="st">"order-service"</span>, <span class="st">"inventory-service"</span> },
      start = <span class="kw">true</span> },
}

<span class="kw">function</span> <span class="fn">on_route</span>(method, path)
    <span class="kw">if</span> path:match(<span class="st">"^/users"</span>)     <span class="kw">then</span> <span class="kw">return</span> <span class="nb">0</span> <span class="kw">end</span>
    <span class="kw">if</span> path:match(<span class="st">"^/products"</span>)  <span class="kw">then</span> <span class="kw">return</span> <span class="nb">1</span> <span class="kw">end</span>
    <span class="kw">if</span> path:match(<span class="st">"^/orders"</span>)    <span class="kw">then</span> <span class="kw">return</span> <span class="nb">2</span> <span class="kw">end</span>
    <span class="kw">if</span> path:match(<span class="st">"^/inventory"</span>) <span class="kw">then</span> <span class="kw">return</span> <span class="nb">3</span> <span class="kw">end</span>
    <span class="kw">return</span> <span class="nb">0</span>
<span class="kw">end</span>
<span class="cm">-- (see full example in examples/advanced/microservices.lua)</span></code></pre>
<pre><code>socketley --lua microservices.lua</code></pre>
</div>

<div class="method-card" id="ex-high-availability">
<div class="method-header">
  <span class="method-name">High Availability</span>
  <span class="badge badge-proxy">proxy</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">3 API replicas behind a round-robin load balancer, plus 2 worker replicas with random distribution. Stop any replica and traffic automatically redistributes. Health tracking via cache.</p>
<pre><code><span class="cm">-- high-availability.lua (essential excerpt)</span>
runtimes = {
    { type = <span class="st">"cache"</span>,  name = <span class="st">"health-store"</span>,    port = <span class="nb">9000</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"api-replica-1"</span>,   port = <span class="nb">9001</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"api-replica-2"</span>,   port = <span class="nb">9002</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"api-replica-3"</span>,   port = <span class="nb">9003</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"proxy"</span>,  name = <span class="st">"api-lb"</span>,          port = <span class="nb">8080</span>,
      protocol = <span class="st">"http"</span>, strategy = <span class="st">"round-robin"</span>,
      backends = { <span class="st">"api-replica-1"</span>, <span class="st">"api-replica-2"</span>, <span class="st">"api-replica-3"</span> },
      start = <span class="kw">true</span> },
}
<span class="cm">-- (see full example in examples/advanced/high-availability.lua)</span></code></pre>
<pre><code>socketley --lua high-availability.lua

<span class="cm"># Simulate failover: stop one replica, traffic redistributes</span>
socketley stop api-replica-2</code></pre>
</div>

<div class="method-card" id="ex-logging-pipeline">
<div class="method-header">
  <span class="method-name">Logging Pipeline</span>
  <span class="badge badge-server">server</span>
  <span class="badge badge-client">client</span>
</div>
<p class="method-desc">Centralized log collection: application servers have log forwarder clients that send to a central collector server. Logs are aggregated to a single file and metrics are tracked in a cache. The collector uses <code>--mode in</code> (receive-only).</p>
<pre><code><span class="cm">-- logging-pipeline.lua (essential excerpt)</span>
runtimes = {
    { type = <span class="st">"server"</span>, name = <span class="st">"log-collector"</span>, port = <span class="nb">9999</span>, mode = <span class="st">"in"</span>,
      write = <span class="st">"/tmp/all-logs.log"</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"cache"</span>,  name = <span class="st">"log-metrics"</span>,   port = <span class="nb">9998</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"web-app"</span>,        port = <span class="nb">9001</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"api-app"</span>,        port = <span class="nb">9002</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"client"</span>, name = <span class="st">"web-log-fwd"</span>,   target = <span class="st">"127.0.0.1:9999"</span>,
      mode = <span class="st">"out"</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"client"</span>, name = <span class="st">"api-log-fwd"</span>,   target = <span class="st">"127.0.0.1:9999"</span>,
      mode = <span class="st">"out"</span>, start = <span class="kw">true</span> },
}
<span class="cm">-- (see full example in examples/advanced/logging-pipeline.lua)</span></code></pre>
<pre><code>socketley --lua logging-pipeline.lua
tail -f /tmp/all-logs.log</code></pre>
</div>

<div class="method-card" id="ex-dev-env">
<div class="method-header">
  <span class="method-name">Development Environment</span>
  <span class="badge badge-all">all types</span>
</div>
<p class="method-desc">A local 4-tier dev stack accessible on <code>localhost:3000</code>: a mock database (persistent cache on :5432), REST API server (:3001), WebSocket server (:3002), and a Lua-routed proxy that combines everything behind a single port.</p>
<pre><code><span class="cm">-- development-env.lua (essential excerpt)</span>
runtimes = {
    { type = <span class="st">"cache"</span>,  name = <span class="st">"dev-db"</span>,    port = <span class="nb">5432</span>,
      persistent = <span class="st">"/tmp/dev-db.bin"</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"dev-api"</span>,   port = <span class="nb">3001</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"server"</span>, name = <span class="st">"dev-ws"</span>,    port = <span class="nb">3002</span>, start = <span class="kw">true</span> },
    { type = <span class="st">"proxy"</span>,  name = <span class="st">"dev-proxy"</span>, port = <span class="nb">3000</span>,
      protocol = <span class="st">"http"</span>, strategy = <span class="st">"lua"</span>,
      backends = { <span class="st">"dev-api"</span>, <span class="st">"dev-ws"</span> }, start = <span class="kw">true</span> },
}

<span class="kw">function</span> <span class="fn">on_route</span>(method, path)
    <span class="kw">if</span> path:match(<span class="st">"^/ws"</span>) <span class="kw">then</span> <span class="kw">return</span> <span class="nb">1</span> <span class="kw">end</span>
    <span class="kw">return</span> <span class="nb">0</span>
<span class="kw">end</span>
<span class="cm">-- (see full example in examples/advanced/development-env.lua)</span></code></pre>
<pre><code>socketley --lua development-env.lua
<span class="cm"># http://localhost:3000 — unified entry point</span></code></pre>
</div>

<div class="method-card" id="ex-game-routing">
<div class="method-header">
  <span class="method-name">Game Server Routing</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">A lobby server that dynamically creates game mode sub-servers and routes players to them. Clients send <code>join rapid</code> or <code>join blitz</code> to be routed. Sub-servers are auto-removed when the lobby stops via <code>on_parent_stop = "remove"</code>.</p>
<pre><code><span class="cm">-- game-routing.lua</span>
<span class="kw">function</span> <span class="fn">on_start</span>()
    socketley.create(<span class="st">"server"</span>, <span class="st">"chess-rapid"</span>, {
        port = <span class="nb">0</span>, config = <span class="st">"rapid-handler.lua"</span>,
        on_parent_stop = <span class="st">"remove"</span>
    })
    socketley.start(<span class="st">"chess-rapid"</span>)

    socketley.create(<span class="st">"server"</span>, <span class="st">"chess-blitz"</span>, {
        port = <span class="nb">0</span>, config = <span class="st">"blitz-handler.lua"</span>,
        on_parent_stop = <span class="st">"remove"</span>
    })
    socketley.start(<span class="st">"chess-blitz"</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(client_id, msg)
    <span class="kw">if</span> msg:match(<span class="st">"^join "</span>) <span class="kw">then</span>
        <span class="kw">local</span> mode = msg:match(<span class="st">"^join (%S+)"</span>)
        self.route(client_id, <span class="st">"chess-"</span> .. mode)
    <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<pre><code>socketley create server lobby -p 9000 --lua game-routing.lua -s
<span class="cm"># Connect and type: join rapid</span></code></pre>
</div>

<div class="method-card" id="ex-udp-echo">
<div class="method-header">
  <span class="method-name">UDP Echo</span>
  <span class="badge badge-server">server</span>
</div>
<p class="method-desc">Fire-and-forget datagram messaging with <code>--udp</code>. Each UDP datagram is one message (no line-parsing needed). Useful for telemetry, logging, and game state updates where occasional packet loss is acceptable.</p>
<pre><code>socketley create server udpecho -p 9000 --udp -b -s

<span class="cm"># Send datagrams</span>
echo <span class="st">"hello"</span> | socat - UDP:localhost:9000
echo <span class="st">"world"</span> | socat - UDP:localhost:9000</code></pre>
</div>

</div><!-- #content-examples -->

<!-- ═══════════════════════════════════════════
     EXAMPLES SDK TAB CONTENT
═══════════════════════════════════════════ -->
<div id="content-examples-sdk" class="content" style="display:none">

<!-- ── Tier 1: Daemon Control Examples ── -->
<h2 id="exsdk-tier1">Tier 1: Daemon Control</h2>
<p>These examples use only <code>socketley/control.h</code> &mdash; header-only, zero dependencies. They control a running daemon programmatically.</p>

<div class="method-card" id="exsdk-control-basics">
<div class="method-header">
  <span class="method-name">Control Basics</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-desc">Full lifecycle walkthrough: create runtimes, start them, query stats, send messages, stop, and remove. Demonstrates every core <code>socketley::ctl</code> function.</p>

<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/control.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>()
{
    <span class="cm">// Create a server and a cache</span>
    <span class="kw">auto</span> r = socketley::ctl::<span class="fn">create</span>(<span class="st">"server"</span>, <span class="st">"ctl_test_srv"</span>, <span class="st">"-p 19001"</span>);
    <span class="kw">if</span> (r.exit_code != <span class="nb">0</span>) { printf(<span class="st">"create failed: %s\n"</span>, r.data.c_str()); <span class="kw">return</span> <span class="nb">1</span>; }

    socketley::ctl::<span class="fn">create</span>(<span class="st">"cache"</span>, <span class="st">"ctl_test_cache"</span>, <span class="st">"-p 19002"</span>);

    <span class="cm">// List runtimes</span>
    r = socketley::ctl::<span class="fn">ls</span>();
    printf(<span class="st">"runtimes:\n%s\n"</span>, r.data.c_str());

    <span class="cm">// Start both</span>
    socketley::ctl::<span class="fn">start</span>(<span class="st">"ctl_test_srv"</span>);
    socketley::ctl::<span class="fn">start</span>(<span class="st">"ctl_test_cache"</span>);

    <span class="cm">// Check running processes</span>
    r = socketley::ctl::<span class="fn">ps</span>();
    printf(<span class="st">"running:\n%s\n"</span>, r.data.c_str());

    <span class="cm">// Query stats</span>
    r = socketley::ctl::<span class="fn">stats</span>(<span class="st">"ctl_test_srv"</span>);
    printf(<span class="st">"stats:\n%s\n"</span>, r.data.c_str());

    <span class="cm">// Show configuration</span>
    r = socketley::ctl::<span class="fn">show</span>(<span class="st">"ctl_test_srv"</span>);

    <span class="cm">// Send a message (broadcasts to 0 clients &mdash; still succeeds)</span>
    socketley::ctl::<span class="fn">send</span>(<span class="st">"ctl_test_srv"</span>, <span class="st">"hello from SDK"</span>);

    <span class="cm">// Reload (restart)</span>
    socketley::ctl::<span class="fn">reload</span>(<span class="st">"ctl_test_srv"</span>);

    <span class="cm">// Stop and remove</span>
    socketley::ctl::<span class="fn">stop</span>(<span class="st">"ctl_test_srv"</span>);
    socketley::ctl::<span class="fn">stop</span>(<span class="st">"ctl_test_cache"</span>);
    socketley::ctl::<span class="fn">remove</span>(<span class="st">"ctl_test_srv"</span>);
    socketley::ctl::<span class="fn">remove</span>(<span class="st">"ctl_test_cache"</span>);

    <span class="cm">// Verify removal (should fail)</span>
    r = socketley::ctl::<span class="fn">stats</span>(<span class="st">"ctl_test_srv"</span>);
    printf(<span class="st">"after remove: exit=%d (expected 1)\n"</span>, r.exit_code);
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++17 01_control_basics.cpp -Iinclude/linux -o control_basics</code></pre>
<p><strong>Test:</strong> Requires a running socketley daemon. Run <code>./control_basics</code> and verify each operation succeeds.</p>
</div>

<div class="method-card" id="exsdk-cache-ops">
<div class="method-header">
  <span class="method-name">Cache Operations</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-desc">Direct cache read/write through daemon IPC. No TCP connection needed &mdash; the daemon reads/writes the cache store directly.</p>

<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/control.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>()
{
    <span class="cm">// Create and start an admin cache</span>
    socketley::ctl::<span class="fn">create</span>(<span class="st">"cache"</span>, <span class="st">"sdk_cache_test"</span>, <span class="st">"-p 19010 --mode admin"</span>);
    socketley::ctl::<span class="fn">start</span>(<span class="st">"sdk_cache_test"</span>);

    <span class="cm">// String operations</span>
    socketley::ctl::<span class="fn">cache_set</span>(<span class="st">"sdk_cache_test"</span>, <span class="st">"greeting"</span>, <span class="st">"hello_world"</span>);

    <span class="kw">auto</span> r = socketley::ctl::<span class="fn">cache_get</span>(<span class="st">"sdk_cache_test"</span>, <span class="st">"greeting"</span>);
    printf(<span class="st">"greeting = %s\n"</span>, r.data.c_str());  <span class="cm">// "hello_world"</span>

    <span class="cm">// Overwrite</span>
    socketley::ctl::<span class="fn">cache_set</span>(<span class="st">"sdk_cache_test"</span>, <span class="st">"count"</span>, <span class="st">"42"</span>);
    socketley::ctl::<span class="fn">cache_set</span>(<span class="st">"sdk_cache_test"</span>, <span class="st">"count"</span>, <span class="st">"100"</span>);
    r = socketley::ctl::<span class="fn">cache_get</span>(<span class="st">"sdk_cache_test"</span>, <span class="st">"count"</span>);
    printf(<span class="st">"count = %s\n"</span>, r.data.c_str());  <span class="cm">// "100"</span>

    <span class="cm">// Delete</span>
    socketley::ctl::<span class="fn">cache_del</span>(<span class="st">"sdk_cache_test"</span>, <span class="st">"greeting"</span>);
    r = socketley::ctl::<span class="fn">cache_get</span>(<span class="st">"sdk_cache_test"</span>, <span class="st">"greeting"</span>);
    printf(<span class="st">"after del = %s\n"</span>, r.data.c_str());  <span class="cm">// "nil"</span>

    <span class="cm">// Cleanup</span>
    socketley::ctl::<span class="fn">stop</span>(<span class="st">"sdk_cache_test"</span>);
    socketley::ctl::<span class="fn">remove</span>(<span class="st">"sdk_cache_test"</span>);
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++17 02_cache_ops.cpp -Iinclude/linux -o cache_ops</code></pre>
</div>

<div class="method-card" id="exsdk-fleet">
<div class="method-header">
  <span class="method-name">Fleet Manager</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-desc">Create a fleet of servers and caches, manage them with glob patterns, and tear them all down. Demonstrates programmatic orchestration at scale.</p>

<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/control.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;string&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>()
{
    <span class="cm">// Create a fleet of 5 servers</span>
    <span class="kw">for</span> (<span class="kw">int</span> i = <span class="nb">0</span>; i &lt; <span class="nb">5</span>; ++i) {
        std::string name  = <span class="st">"fleet_srv_"</span> + std::to_string(i);
        std::string flags = <span class="st">"-p "</span> + std::to_string(<span class="nb">19110</span> + i);
        socketley::ctl::<span class="fn">create</span>(<span class="st">"server"</span>, name, flags);
    }

    <span class="cm">// Create 2 caches</span>
    <span class="kw">for</span> (<span class="kw">int</span> i = <span class="nb">0</span>; i &lt; <span class="nb">2</span>; ++i) {
        std::string name  = <span class="st">"fleet_cache_"</span> + std::to_string(i);
        std::string flags = <span class="st">"-p "</span> + std::to_string(<span class="nb">19200</span> + i);
        socketley::ctl::<span class="fn">create</span>(<span class="st">"cache"</span>, name, flags);
    }

    <span class="cm">// List all &mdash; should show 7 runtimes</span>
    <span class="kw">auto</span> r = socketley::ctl::<span class="fn">ls</span>();
    printf(<span class="st">"%s\n"</span>, r.data.c_str());

    <span class="cm">// Start all servers with glob pattern</span>
    socketley::ctl::<span class="fn">command</span>(<span class="st">"start fleet_srv_*"</span>);
    socketley::ctl::<span class="fn">start</span>(<span class="st">"fleet_cache_0"</span>);
    socketley::ctl::<span class="fn">start</span>(<span class="st">"fleet_cache_1"</span>);

    <span class="cm">// Stats on all servers at once</span>
    socketley::ctl::<span class="fn">command</span>(<span class="st">"stats fleet_srv_*"</span>);

    <span class="cm">// Stop and remove everything</span>
    socketley::ctl::<span class="fn">command</span>(<span class="st">"stop fleet_srv_*"</span>);
    socketley::ctl::<span class="fn">command</span>(<span class="st">"stop fleet_cache_*"</span>);
    socketley::ctl::<span class="fn">command</span>(<span class="st">"remove fleet_srv_*"</span>);
    socketley::ctl::<span class="fn">command</span>(<span class="st">"remove fleet_cache_*"</span>);

    printf(<span class="st">"fleet cleaned up\n"</span>);
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++17 03_fleet_manager.cpp -Iinclude/linux -o fleet_manager</code></pre>
<p><strong>Key concept:</strong> <code>socketley::ctl::command()</code> accepts any raw command string, including glob patterns like <code>"start fleet_srv_*"</code>.</p>
</div>

<!-- ── Daemon Workflows ── -->
<h2 id="exsdk-daemon-workflows">Daemon Workflows</h2>
<p>The most common pattern: Tier 1 SDK driving daemon-managed runtimes with Lua callbacks. These examples combine <code>socketley::ctl</code> control with Lua scripts and the <code>action</code> subcommand.</p>

<div class="method-card" id="exsdk-dw-lua-echo">
<div class="method-header">
  <span class="method-name">Lua Echo Server via Daemon</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-desc">Create a daemon-managed server with a Lua echo script, send a message, query stats, and clean up. This is how callbacks work in daemon mode &mdash; you write Lua, the daemon runs it.</p>

<p><strong>echo.lua</strong> (save to disk before running):</p>
<pre><code><span class="kw">function</span> <span class="fn">on_client_message</span>(id, msg)
    self.<span class="fn">broadcast</span>(msg)
<span class="kw">end</span></code></pre>

<p><strong>C++ driver:</strong></p>
<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/control.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>()
{
    <span class="cm">// Create server with Lua script, auto-start (-s)</span>
    <span class="kw">auto</span> r = socketley::ctl::<span class="fn">create</span>(<span class="st">"server"</span>, <span class="st">"echo"</span>,
        <span class="st">"-p 9000 --lua echo.lua -s"</span>);
    <span class="kw">if</span> (r.exit_code != <span class="nb">0</span>) { printf(<span class="st">"create: %s\n"</span>, r.data.c_str()); <span class="kw">return</span> <span class="nb">1</span>; }

    <span class="cm">// Send a test message (broadcasts to all connected clients)</span>
    socketley::ctl::<span class="fn">send</span>(<span class="st">"echo"</span>, <span class="st">"hello from SDK"</span>);

    <span class="cm">// Query stats</span>
    r = socketley::ctl::<span class="fn">stats</span>(<span class="st">"echo"</span>);
    printf(<span class="st">"stats:\n%s\n"</span>, r.data.c_str());

    <span class="cm">// Hot-reload Lua without dropping connections</span>
    socketley::ctl::<span class="fn">reload_lua</span>(<span class="st">"echo"</span>);

    <span class="cm">// Cleanup</span>
    socketley::ctl::<span class="fn">stop</span>(<span class="st">"echo"</span>);
    socketley::ctl::<span class="fn">remove</span>(<span class="st">"echo"</span>);
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++17 dw_lua_echo.cpp -Iinclude/linux -o dw_lua_echo</code></pre>
<p><strong>Key concept:</strong> Lua scripts run inside the daemon process. The SDK just controls lifecycle and sends messages. <code>reload_lua()</code> hot-swaps the script without restarting.</p>
</div>

<div class="method-card" id="exsdk-dw-cache-full">
<div class="method-header">
  <span class="method-name">Full Cache Operations</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-desc">Exercise every cache data structure through the <code>action</code> subcommand: strings, lists, sets, hashes, TTL, pub/sub, and admin operations. The <code>action</code> command gives you full Redis-like access from C++.</p>

<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/control.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>()
{
    <span class="cm">// Create admin cache (all commands enabled)</span>
    socketley::ctl::<span class="fn">create</span>(<span class="st">"cache"</span>, <span class="st">"store"</span>, <span class="st">"-p 6379 --mode admin -s"</span>);

    <span class="cm">// ── Strings ──</span>
    socketley::ctl::<span class="fn">cache_set</span>(<span class="st">"store"</span>, <span class="st">"user:1"</span>, <span class="st">"alice"</span>);
    socketley::ctl::<span class="fn">cache_set</span>(<span class="st">"store"</span>, <span class="st">"user:2"</span>, <span class="st">"bob"</span>);
    <span class="kw">auto</span> r = socketley::ctl::<span class="fn">cache_get</span>(<span class="st">"store"</span>, <span class="st">"user:1"</span>);
    printf(<span class="st">"user:1 = %s\n"</span>, r.data.c_str());  <span class="cm">// "alice"</span>

    r = socketley::ctl::<span class="fn">cache_exists</span>(<span class="st">"store"</span>, <span class="st">"user:1"</span>);
    printf(<span class="st">"exists = %s\n"</span>, r.data.c_str());  <span class="cm">// "1"</span>

    socketley::ctl::<span class="fn">cache_del</span>(<span class="st">"store"</span>, <span class="st">"user:2"</span>);

    <span class="cm">// ── Lists ──</span>
    socketley::ctl::<span class="fn">cache_lpush</span>(<span class="st">"store"</span>, <span class="st">"queue"</span>, <span class="st">"job_c"</span>);
    socketley::ctl::<span class="fn">cache_lpush</span>(<span class="st">"store"</span>, <span class="st">"queue"</span>, <span class="st">"job_b"</span>);
    socketley::ctl::<span class="fn">cache_lpush</span>(<span class="st">"store"</span>, <span class="st">"queue"</span>, <span class="st">"job_a"</span>);

    r = socketley::ctl::<span class="fn">cache_llen</span>(<span class="st">"store"</span>, <span class="st">"queue"</span>);
    printf(<span class="st">"queue length = %s\n"</span>, r.data.c_str());  <span class="cm">// "3"</span>

    r = socketley::ctl::<span class="fn">cache_lpop</span>(<span class="st">"store"</span>, <span class="st">"queue"</span>);
    printf(<span class="st">"dequeued = %s\n"</span>, r.data.c_str());  <span class="cm">// "job_a"</span>

    <span class="cm">// ── Sets ──</span>
    socketley::ctl::<span class="fn">cache_sadd</span>(<span class="st">"store"</span>, <span class="st">"tags:1"</span>, <span class="st">"vip"</span>);
    socketley::ctl::<span class="fn">cache_sadd</span>(<span class="st">"store"</span>, <span class="st">"tags:1"</span>, <span class="st">"premium"</span>);
    socketley::ctl::<span class="fn">cache_sadd</span>(<span class="st">"store"</span>, <span class="st">"tags:1"</span>, <span class="st">"active"</span>);

    r = socketley::ctl::<span class="fn">cache_scard</span>(<span class="st">"store"</span>, <span class="st">"tags:1"</span>);
    printf(<span class="st">"tag count = %s\n"</span>, r.data.c_str());  <span class="cm">// "3"</span>

    r = socketley::ctl::<span class="fn">cache_sismember</span>(<span class="st">"store"</span>, <span class="st">"tags:1"</span>, <span class="st">"vip"</span>);
    printf(<span class="st">"is vip = %s\n"</span>, r.data.c_str());  <span class="cm">// "1"</span>

    socketley::ctl::<span class="fn">cache_srem</span>(<span class="st">"store"</span>, <span class="st">"tags:1"</span>, <span class="st">"active"</span>);

    <span class="cm">// ── Hashes ──</span>
    socketley::ctl::<span class="fn">cache_hset</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>, <span class="st">"token"</span>, <span class="st">"abc123"</span>);
    socketley::ctl::<span class="fn">cache_hset</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>, <span class="st">"user"</span>, <span class="st">"alice"</span>);

    r = socketley::ctl::<span class="fn">cache_hget</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>, <span class="st">"token"</span>);
    printf(<span class="st">"token = %s\n"</span>, r.data.c_str());  <span class="cm">// "abc123"</span>

    r = socketley::ctl::<span class="fn">cache_hlen</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>);
    printf(<span class="st">"fields = %s\n"</span>, r.data.c_str());  <span class="cm">// "2"</span>

    socketley::ctl::<span class="fn">cache_hdel</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>, <span class="st">"user"</span>);

    <span class="cm">// ── TTL ──</span>
    socketley::ctl::<span class="fn">cache_expire</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>, <span class="nb">3600</span>);

    r = socketley::ctl::<span class="fn">cache_ttl</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>);
    printf(<span class="st">"ttl = %s\n"</span>, r.data.c_str());  <span class="cm">// "3600" (approx)</span>

    socketley::ctl::<span class="fn">cache_persist</span>(<span class="st">"store"</span>, <span class="st">"session:1"</span>);

    <span class="cm">// ── Pub/Sub ──</span>
    r = socketley::ctl::<span class="fn">cache_publish</span>(<span class="st">"store"</span>, <span class="st">"notifications"</span>, <span class="st">"hello"</span>);
    printf(<span class="st">"subscribers = %s\n"</span>, r.data.c_str());  <span class="cm">// "0" (no subscribers yet)</span>

    <span class="cm">// ── Admin ──</span>
    r = socketley::ctl::<span class="fn">cache_size</span>(<span class="st">"store"</span>);
    printf(<span class="st">"total keys = %s\n"</span>, r.data.c_str());

    r = socketley::ctl::<span class="fn">cache_memory</span>(<span class="st">"store"</span>);
    printf(<span class="st">"memory = %s\n"</span>, r.data.c_str());

    <span class="cm">// Cleanup</span>
    socketley::ctl::<span class="fn">stop</span>(<span class="st">"store"</span>);
    socketley::ctl::<span class="fn">remove</span>(<span class="st">"store"</span>);
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++17 dw_cache_full.cpp -Iinclude/linux -o dw_cache_full</code></pre>
<p><strong>Key concept:</strong> Every cache data structure has a typed <code>cache_*</code> function. IPC is faster than TCP because it bypasses network and protocol parsing.</p>
</div>

<div class="method-card" id="exsdk-dw-server-cache">
<div class="method-header">
  <span class="method-name">Server + Cache Integration</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-server">Server</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-desc">Create a server linked to a cache via <code>--cache</code>, then access data through two paths: server TCP (for clients) and direct IPC (for orchestration). Shows the most common production pattern.</p>

<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/control.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>()
{
    <span class="cm">// Create cache first (server depends on it)</span>
    socketley::ctl::<span class="fn">create</span>(<span class="st">"cache"</span>, <span class="st">"store"</span>, <span class="st">"-p 6379 --mode admin -s"</span>);

    <span class="cm">// Create server linked to the cache</span>
    socketley::ctl::<span class="fn">create</span>(<span class="st">"server"</span>, <span class="st">"api"</span>, <span class="st">"-p 9000 --cache store -s"</span>);

    <span class="cm">// Path 1: Direct IPC (no TCP, for orchestration)</span>
    socketley::ctl::<span class="fn">cache_set</span>(<span class="st">"store"</span>, <span class="st">"config:version"</span>, <span class="st">"1.0"</span>);
    socketley::ctl::<span class="fn">cache_hset</span>(<span class="st">"store"</span>, <span class="st">"config:limits"</span>, <span class="st">"max_conn"</span>, <span class="st">"1000"</span>);
    socketley::ctl::<span class="fn">cache_hset</span>(<span class="st">"store"</span>, <span class="st">"config:limits"</span>, <span class="st">"timeout"</span>, <span class="st">"30"</span>);

    <span class="cm">// Path 2: Through the server (what TCP clients do)</span>
    <span class="cm">// Clients connected to port 9000 can send:</span>
    <span class="cm">//   "cache set session:abc token123"</span>
    <span class="cm">//   "cache get session:abc"</span>
    <span class="cm">// The server forwards these to the linked cache automatically.</span>

    <span class="cm">// Verify via direct IPC</span>
    <span class="kw">auto</span> r = socketley::ctl::<span class="fn">cache_get</span>(<span class="st">"store"</span>, <span class="st">"config:version"</span>);
    printf(<span class="st">"version = %s\n"</span>, r.data.c_str());  <span class="cm">// "1.0"</span>

    r = socketley::ctl::<span class="fn">cache_hget</span>(<span class="st">"store"</span>, <span class="st">"config:limits"</span>, <span class="st">"max_conn"</span>);
    printf(<span class="st">"max_conn = %s\n"</span>, r.data.c_str());  <span class="cm">// "1000"</span>

    <span class="cm">// Stats on both</span>
    r = socketley::ctl::<span class="fn">stats</span>(<span class="st">"api"</span>);
    printf(<span class="st">"server:\n%s\n"</span>, r.data.c_str());

    r = socketley::ctl::<span class="fn">stats</span>(<span class="st">"store"</span>);
    printf(<span class="st">"cache:\n%s\n"</span>, r.data.c_str());

    <span class="cm">// Cleanup</span>
    socketley::ctl::<span class="fn">stop</span>(<span class="st">"api"</span>);
    socketley::ctl::<span class="fn">stop</span>(<span class="st">"store"</span>);
    socketley::ctl::<span class="fn">remove</span>(<span class="st">"api"</span>);
    socketley::ctl::<span class="fn">remove</span>(<span class="st">"store"</span>);
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++17 dw_server_cache.cpp -Iinclude/linux -o dw_server_cache</code></pre>
<p><strong>Key concept:</strong> <code>--cache store</code> links the server to the cache. Clients send <code>"cache set key val"</code> through the server; the SDK uses <code>cache_get</code>/<code>action</code> for direct access. Two paths, same data.</p>
</div>

<div class="method-card" id="exsdk-dw-monitoring">
<div class="method-header">
  <span class="method-name">Monitoring Dashboard</span>
  <span class="badge badge-tier1">Tier 1</span>
</div>
<p class="method-desc">Create a small fleet and monitor it: query stats from each runtime, parse connection counts, and print a summary. Demonstrates Tier 1 for orchestration and monitoring.</p>

<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/control.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;string&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;vector&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;thread&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;chrono&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>()
{
    <span class="cm">// Create a small fleet</span>
    socketley::ctl::<span class="fn">create</span>(<span class="st">"server"</span>, <span class="st">"web"</span>,  <span class="st">"-p 8080 -s"</span>);
    socketley::ctl::<span class="fn">create</span>(<span class="st">"server"</span>, <span class="st">"api"</span>,  <span class="st">"-p 8081 -s"</span>);
    socketley::ctl::<span class="fn">create</span>(<span class="st">"cache"</span>,  <span class="st">"data"</span>, <span class="st">"-p 6379 --mode admin -s"</span>);

    std::vector&lt;std::string&gt; runtimes = {<span class="st">"web"</span>, <span class="st">"api"</span>, <span class="st">"data"</span>};

    <span class="cm">// Monitor loop (3 iterations)</span>
    <span class="kw">for</span> (<span class="kw">int</span> i = <span class="nb">0</span>; i &lt; <span class="nb">3</span>; ++i) {
        printf(<span class="st">"── Snapshot %d ──\n"</span>, i + <span class="nb">1</span>);

        <span class="kw">for</span> (<span class="kw">const auto</span>&amp; name : runtimes) {
            <span class="kw">auto</span> r = socketley::ctl::<span class="fn">stats</span>(name);
            <span class="kw">if</span> (r.exit_code == <span class="nb">0</span>)
                printf(<span class="st">"  [%s] %s\n"</span>, name.c_str(), r.data.c_str());
            <span class="kw">else</span>
                printf(<span class="st">"  [%s] down\n"</span>, name.c_str());
        }

        <span class="cm">// Also check cache key count</span>
        <span class="kw">auto</span> r = socketley::ctl::<span class="fn">cache_size</span>(<span class="st">"data"</span>);
        printf(<span class="st">"  [data] keys = %s\n"</span>, r.data.c_str());

        r = socketley::ctl::<span class="fn">cache_memory</span>(<span class="st">"data"</span>);
        printf(<span class="st">"  [data] memory = %s\n"</span>, r.data.c_str());

        std::this_thread::sleep_for(std::chrono::seconds(<span class="nb">1</span>));
    }

    <span class="cm">// Cleanup</span>
    <span class="kw">for</span> (<span class="kw">const auto</span>&amp; name : runtimes) {
        socketley::ctl::<span class="fn">stop</span>(name);
        socketley::ctl::<span class="fn">remove</span>(name);
    }

    printf(<span class="st">"fleet shut down\n"</span>);
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++17 dw_monitoring.cpp -Iinclude/linux -o dw_monitoring</code></pre>
<p><strong>Key concept:</strong> Tier 1 is ideal for orchestration tools. Poll <code>stats()</code> and <code>action ... size/memory</code> to build monitoring dashboards without touching the data path.</p>
</div>

<div class="method-card" id="exsdk-dw-pubsub">
<div class="method-header">
  <span class="method-name">Pub/Sub with Lua Callbacks</span>
  <span class="badge badge-tier1">Tier 1</span>
  <span class="badge badge-cache">Cache</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-desc">Create a cache and a server with a Lua script that subscribes to cache events. When the C++ driver publishes to the cache, the server's Lua callback fires and broadcasts the message to all connected TCP clients. This is the primary pattern for receiving pub/sub messages from C++.</p>

<p><strong>notify.lua</strong> (save to disk before running):</p>
<pre><code><span class="kw">function</span> <span class="fn">on_start</span>()
    socketley.<span class="fn">subscribe</span>(<span class="st">"store"</span>, <span class="st">"events"</span>, <span class="kw">function</span>(ch, msg)
        socketley.<span class="fn">log</span>(<span class="st">"event on "</span> .. ch .. <span class="st">": "</span> .. msg)
        self.<span class="fn">broadcast</span>(<span class="st">"EVENT: "</span> .. msg)
    <span class="kw">end</span>)
<span class="kw">end</span>

<span class="kw">function</span> <span class="fn">on_client_message</span>(id, msg)
    <span class="cm">-- Clients can also trigger publishes</span>
    socketley.<span class="fn">log</span>(<span class="st">"client "</span> .. id .. <span class="st">" says: "</span> .. msg)
<span class="kw">end</span></code></pre>

<p><strong>C++ driver:</strong></p>
<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/control.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>

<span class="kw">int</span> <span class="fn">main</span>()
{
    <span class="cm">// Create cache + server with Lua subscribe callback</span>
    socketley::ctl::<span class="fn">create</span>(<span class="st">"cache"</span>, <span class="st">"store"</span>, <span class="st">"-p 6379 --mode admin -s"</span>);
    socketley::ctl::<span class="fn">create</span>(<span class="st">"server"</span>, <span class="st">"notifier"</span>,
        <span class="st">"-p 9000 --lua notify.lua -s"</span>);

    <span class="cm">// Publish events &mdash; the server's Lua callback broadcasts them</span>
    <span class="kw">auto</span> r = socketley::ctl::<span class="fn">cache_publish</span>(<span class="st">"store"</span>, <span class="st">"events"</span>, <span class="st">"user_signup"</span>);
    printf(<span class="st">"subscribers: %s\n"</span>, r.data.c_str());  <span class="cm">// "1"</span>

    r = socketley::ctl::<span class="fn">cache_publish</span>(<span class="st">"store"</span>, <span class="st">"events"</span>, <span class="st">"order_placed"</span>);
    printf(<span class="st">"subscribers: %s\n"</span>, r.data.c_str());  <span class="cm">// "1"</span>

    <span class="cm">// Any TCP client connected to port 9000 receives:</span>
    <span class="cm">//   "EVENT: user_signup"</span>
    <span class="cm">//   "EVENT: order_placed"</span>

    <span class="cm">// Cleanup</span>
    socketley::ctl::<span class="fn">stop</span>(<span class="st">"notifier"</span>);
    socketley::ctl::<span class="fn">stop</span>(<span class="st">"store"</span>);
    socketley::ctl::<span class="fn">remove</span>(<span class="st">"notifier"</span>);
    socketley::ctl::<span class="fn">remove</span>(<span class="st">"store"</span>);
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++17 dw_pubsub.cpp -Iinclude/linux -o dw_pubsub</code></pre>
<p><strong>Key concept:</strong> Tier 1 can publish but not subscribe (IPC is request/response). Use <code>socketley.subscribe()</code> in a Lua script on any runtime to receive messages. The Lua callback fires on the subscribing runtime's event loop &mdash; no polling, no extra TCP connections.</p>
</div>

<!-- ── Tier 2: Embedded Engine Examples ── -->
<h2 id="exsdk-tier2">Tier 2: Embedded Engine</h2>
<p>These examples embed the full io_uring engine in a standalone binary. No daemon needed.</p>

<div class="method-card" id="exsdk-echo">
<div class="method-header">
  <span class="method-name">Echo Server</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-desc">A standalone TCP echo server using C++ callbacks. Demonstrates the core Tier 2 pattern: event loop + runtime manager + callbacks. Tracks connection and message counts with atomics.</p>

<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/server.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;csignal&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;atomic&gt;</span>

<span class="kw">static</span> event_loop* g_loop = <span class="kw">nullptr</span>;
<span class="kw">static</span> std::atomic&lt;<span class="kw">int</span>&gt; g_conn_count{<span class="nb">0</span>};
<span class="kw">static</span> std::atomic&lt;uint64_t&gt; g_msg_count{<span class="nb">0</span>};

<span class="kw">int</span> <span class="fn">main</span>()
{
    signal(SIGPIPE, SIG_IGN);

    event_loop loop;
    loop.<span class="fn">init</span>();
    g_loop = &amp;loop;
    runtime_manager mgr;

    mgr.<span class="fn">create</span>(runtime_server, <span class="st">"echo"</span>);
    <span class="kw">auto</span>* srv = <span class="kw">static_cast</span>&lt;server_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"echo"</span>));
    srv-&gt;<span class="fn">set_port</span>(<span class="nb">9000</span>);
    srv-&gt;<span class="fn">set_mode</span>(mode_inout);
    srv-&gt;<span class="fn">set_runtime_manager</span>(&amp;mgr);
    srv-&gt;<span class="fn">set_event_loop</span>(&amp;loop);

    <span class="cm">// C++ callbacks &mdash; no Lua needed</span>
    srv-&gt;<span class="fn">set_on_connect</span>([](<span class="kw">int</span> fd) {
        g_conn_count++;
        printf(<span class="st">"client %d connected (total: %d)\n"</span>, fd, g_conn_count.load());
    });
    srv-&gt;<span class="fn">set_on_disconnect</span>([](<span class="kw">int</span> fd) {
        g_conn_count--;
        printf(<span class="st">"client %d disconnected (total: %d)\n"</span>, fd, g_conn_count.load());
    });
    srv-&gt;<span class="fn">set_on_client_message</span>([srv](<span class="kw">int</span> fd, std::string_view msg) {
        g_msg_count++;
        srv-&gt;<span class="fn">lua_send_to</span>(fd, msg);  <span class="cm">// echo back to sender</span>
    });

    mgr.<span class="fn">start</span>(<span class="st">"echo"</span>, loop);
    printf(<span class="st">"echo server on port 9000\n"</span>);

    signal(SIGINT,  [](<span class="kw">int</span>) { g_loop-&gt;<span class="fn">request_stop</span>(); });
    signal(SIGTERM, [](<span class="kw">int</span>) { g_loop-&gt;<span class="fn">request_stop</span>(); });
    loop.<span class="fn">run</span>();
    mgr.<span class="fn">stop_all</span>(loop);
    printf(<span class="st">"%lu messages processed\n"</span>, g_msg_count.load());
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++23 04_echo_server.cpp -I. -Iinclude/linux -Lbin/Release -lsocketley_sdk -luring -lssl -lcrypto -o echo_server</code></pre>
<p><strong>Test:</strong></p>
<pre><code>echo <span class="st">"hello"</span> | nc -q1 127.0.0.1 9000</code></pre>
</div>

<div class="method-card" id="exsdk-multi">
<div class="method-header">
  <span class="method-name">Multi-Runtime</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
  <span class="badge badge-cache">Cache</span>
</div>
<p class="method-desc">Run a server and cache in the same event loop. The server is linked to the cache via <code>set_cache_name()</code>, so clients can run cache commands (e.g. <code>cache set foo bar</code>) through the server connection.</p>

<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/server.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;socketley/cache.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;csignal&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>

<span class="kw">static</span> event_loop* g_loop = <span class="kw">nullptr</span>;

<span class="kw">int</span> <span class="fn">main</span>()
{
    signal(SIGPIPE, SIG_IGN);
    event_loop loop; loop.<span class="fn">init</span>();
    g_loop = &amp;loop;
    runtime_manager mgr;

    <span class="cm">// Create cache</span>
    mgr.<span class="fn">create</span>(runtime_cache, <span class="st">"store"</span>);
    <span class="kw">auto</span>* cache = <span class="kw">static_cast</span>&lt;cache_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"store"</span>));
    cache-&gt;<span class="fn">set_port</span>(<span class="nb">6379</span>);
    cache-&gt;<span class="fn">set_mode</span>(cache_mode_admin);
    cache-&gt;<span class="fn">set_runtime_manager</span>(&amp;mgr);
    cache-&gt;<span class="fn">set_event_loop</span>(&amp;loop);

    <span class="cm">// Create server linked to cache</span>
    mgr.<span class="fn">create</span>(runtime_server, <span class="st">"api"</span>);
    <span class="kw">auto</span>* srv = <span class="kw">static_cast</span>&lt;server_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"api"</span>));
    srv-&gt;<span class="fn">set_port</span>(<span class="nb">9000</span>);
    srv-&gt;<span class="fn">set_mode</span>(mode_inout);
    srv-&gt;<span class="fn">set_cache_name</span>(<span class="st">"store"</span>);  <span class="cm">// clients can "cache set k v" through this server</span>
    srv-&gt;<span class="fn">set_runtime_manager</span>(&amp;mgr);
    srv-&gt;<span class="fn">set_event_loop</span>(&amp;loop);

    srv-&gt;<span class="fn">set_on_client_message</span>([srv](<span class="kw">int</span> fd, std::string_view msg) {
        printf(<span class="st">"[api] %d: %.*s\n"</span>, fd, (<span class="kw">int</span>)msg.size(), msg.data());
        srv-&gt;<span class="fn">lua_broadcast</span>(msg);
    });

    mgr.<span class="fn">start</span>(<span class="st">"store"</span>, loop);
    mgr.<span class="fn">start</span>(<span class="st">"api"</span>, loop);
    printf(<span class="st">"server :9000 + cache :6379\n"</span>);

    signal(SIGINT, [](<span class="kw">int</span>) { g_loop-&gt;<span class="fn">request_stop</span>(); });
    loop.<span class="fn">run</span>();
    mgr.<span class="fn">stop_all</span>(loop);
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++23 05_multi_runtime.cpp -I. -Iinclude/linux -Lbin/Release -lsocketley_sdk -luring -lssl -lcrypto -o multi_runtime</code></pre>
<p><strong>Test:</strong></p>
<pre><code>echo <span class="st">"cache set foo bar"</span> | nc -q1 127.0.0.1 9000
echo <span class="st">"cache get foo"</span>     | nc -q1 127.0.0.1 9000  <span class="cm"># returns "bar"</span>
echo <span class="st">"set baz qux"</span>       | nc -q1 127.0.0.1 6379  <span class="cm"># direct cache access</span></code></pre>
</div>

<div class="method-card" id="exsdk-chat">
<div class="method-header">
  <span class="method-name">Chat Server (Lua)</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-desc">Embedded server that loads a Lua script for chat logic. If the Lua file isn't found, it falls back to C++ echo callbacks. Demonstrates Lua + C++ callback coexistence.</p>

<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/server.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;csignal&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>

<span class="kw">static</span> event_loop* g_loop = <span class="kw">nullptr</span>;

<span class="kw">int</span> <span class="fn">main</span>()
{
    signal(SIGPIPE, SIG_IGN);
    event_loop loop; loop.<span class="fn">init</span>();
    g_loop = &amp;loop;
    runtime_manager mgr;

    mgr.<span class="fn">create</span>(runtime_server, <span class="st">"chat"</span>);
    <span class="kw">auto</span>* srv = <span class="kw">static_cast</span>&lt;server_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"chat"</span>));
    srv-&gt;<span class="fn">set_port</span>(<span class="nb">9000</span>);
    srv-&gt;<span class="fn">set_mode</span>(mode_inout);
    srv-&gt;<span class="fn">set_max_connections</span>(<span class="nb">50</span>);
    srv-&gt;<span class="fn">set_runtime_manager</span>(&amp;mgr);
    srv-&gt;<span class="fn">set_event_loop</span>(&amp;loop);

    <span class="cm">// Try Lua first, fallback to C++</span>
    <span class="kw">bool</span> lua_ok = srv-&gt;<span class="fn">load_lua_script</span>(<span class="st">"chat.lua"</span>);
    <span class="kw">if</span> (!lua_ok) {
        printf(<span class="st">"Lua not found, using C++ echo fallback\n"</span>);
        srv-&gt;<span class="fn">set_on_connect</span>([](<span class="kw">int</span> fd) {
            printf(<span class="st">"client %d joined\n"</span>, fd);
        });
        srv-&gt;<span class="fn">set_on_disconnect</span>([](<span class="kw">int</span> fd) {
            printf(<span class="st">"client %d left\n"</span>, fd);
        });
        srv-&gt;<span class="fn">set_on_client_message</span>([srv](<span class="kw">int</span>, std::string_view msg) {
            srv-&gt;<span class="fn">lua_broadcast</span>(msg);
        });
    }

    mgr.<span class="fn">start</span>(<span class="st">"chat"</span>, loop);
    printf(<span class="st">"chat server on port 9000\n"</span>);

    signal(SIGINT, [](<span class="kw">int</span>) { g_loop-&gt;<span class="fn">request_stop</span>(); });
    loop.<span class="fn">run</span>();
    mgr.<span class="fn">stop_all</span>(loop);
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++23 06_chat_server.cpp -I. -Iinclude/linux -Lbin/Release -lsocketley_sdk -luring -lssl -lcrypto -lluajit -o chat_server</code></pre>
<p><strong>Test:</strong> Open multiple terminals with <code>nc 127.0.0.1 9000</code>. Messages from one client appear on all others.</p>
</div>

<div class="method-card" id="exsdk-proxy-lb">
<div class="method-header">
  <span class="method-name">Proxy Load Balancer</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-proxy">Proxy</span>
  <span class="badge badge-server">Server</span>
</div>
<p class="method-desc">Two backend servers with a TCP round-robin proxy in front. Demonstrates multi-runtime orchestration with different runtime types. Each backend tags its response so you can see the load balancing in action.</p>

<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/server.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;socketley/proxy.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;csignal&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>

<span class="kw">static</span> event_loop* g_loop = <span class="kw">nullptr</span>;

<span class="kw">int</span> <span class="fn">main</span>()
{
    signal(SIGPIPE, SIG_IGN);
    event_loop loop; loop.<span class="fn">init</span>();
    g_loop = &amp;loop;
    runtime_manager mgr;

    <span class="cm">// Backend 1 &mdash; echoes with prefix</span>
    mgr.<span class="fn">create</span>(runtime_server, <span class="st">"backend1"</span>);
    <span class="kw">auto</span>* b1 = <span class="kw">static_cast</span>&lt;server_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"backend1"</span>));
    b1-&gt;<span class="fn">set_port</span>(<span class="nb">9001</span>); b1-&gt;<span class="fn">set_mode</span>(mode_inout);
    b1-&gt;<span class="fn">set_runtime_manager</span>(&amp;mgr); b1-&gt;<span class="fn">set_event_loop</span>(&amp;loop);
    b1-&gt;<span class="fn">set_on_client_message</span>([b1](<span class="kw">int</span> fd, std::string_view msg) {
        std::string resp = <span class="st">"[backend1] "</span> + std::string(msg);
        b1-&gt;<span class="fn">lua_send_to</span>(fd, resp);
    });

    <span class="cm">// Backend 2</span>
    mgr.<span class="fn">create</span>(runtime_server, <span class="st">"backend2"</span>);
    <span class="kw">auto</span>* b2 = <span class="kw">static_cast</span>&lt;server_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"backend2"</span>));
    b2-&gt;<span class="fn">set_port</span>(<span class="nb">9002</span>); b2-&gt;<span class="fn">set_mode</span>(mode_inout);
    b2-&gt;<span class="fn">set_runtime_manager</span>(&amp;mgr); b2-&gt;<span class="fn">set_event_loop</span>(&amp;loop);
    b2-&gt;<span class="fn">set_on_client_message</span>([b2](<span class="kw">int</span> fd, std::string_view msg) {
        std::string resp = <span class="st">"[backend2] "</span> + std::string(msg);
        b2-&gt;<span class="fn">lua_send_to</span>(fd, resp);
    });

    <span class="cm">// TCP round-robin proxy</span>
    mgr.<span class="fn">create</span>(runtime_proxy, <span class="st">"lb"</span>);
    <span class="kw">auto</span>* px = <span class="kw">static_cast</span>&lt;proxy_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"lb"</span>));
    px-&gt;<span class="fn">set_port</span>(<span class="nb">8080</span>);
    px-&gt;<span class="fn">set_protocol</span>(protocol_tcp);
    px-&gt;<span class="fn">set_strategy</span>(strategy_round_robin);
    px-&gt;<span class="fn">add_backend</span>(<span class="st">"127.0.0.1:9001"</span>);
    px-&gt;<span class="fn">add_backend</span>(<span class="st">"127.0.0.1:9002"</span>);
    px-&gt;<span class="fn">set_runtime_manager</span>(&amp;mgr); px-&gt;<span class="fn">set_event_loop</span>(&amp;loop);

    mgr.<span class="fn">start</span>(<span class="st">"backend1"</span>, loop);
    mgr.<span class="fn">start</span>(<span class="st">"backend2"</span>, loop);
    mgr.<span class="fn">start</span>(<span class="st">"lb"</span>, loop);
    printf(<span class="st">"proxy :8080 -&gt; backend1 :9001, backend2 :9002\n"</span>);

    signal(SIGINT, [](<span class="kw">int</span>) { g_loop-&gt;<span class="fn">request_stop</span>(); });
    loop.<span class="fn">run</span>();
    mgr.<span class="fn">stop_all</span>(loop);
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++23 07_proxy_lb.cpp -I. -Iinclude/linux -Lbin/Release -lsocketley_sdk -luring -lssl -lcrypto -o proxy_lb</code></pre>
<p><strong>Test:</strong></p>
<pre><code>echo <span class="st">"hello"</span> | nc -q1 127.0.0.1 8080  <span class="cm"># [backend1] hello</span>
echo <span class="st">"hello"</span> | nc -q1 127.0.0.1 8080  <span class="cm"># [backend2] hello</span>
echo <span class="st">"hello"</span> | nc -q1 127.0.0.1 8080  <span class="cm"># [backend1] hello  (round-robin)</span></code></pre>
</div>

<!-- ── Tier 3: Daemon Attach Examples ── -->
<h2 id="exsdk-tier3">Tier 3: Daemon Attach</h2>
<p>Register your own processes with the daemon fleet.</p>

<div class="method-card" id="exsdk-attach">
<div class="method-header">
  <span class="method-name">Attached Service</span>
  <span class="badge badge-tier3">Tier 3</span>
</div>
<p class="method-desc">A raw POSIX TCP server that registers with the socketley daemon via <code>daemon_attach()</code>. Shows up in <code>socketley ls</code> and <code>socketley ps</code>. Degrades gracefully if daemon isn't running.</p>

<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/attach.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;arpa/inet.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;csignal&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;netinet/in.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;poll.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;sys/socket.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;unistd.h&gt;</span>

<span class="kw">static volatile</span> sig_atomic_t g_quit = <span class="nb">0</span>;

<span class="kw">int</span> <span class="fn">main</span>()
{
    signal(SIGPIPE, SIG_IGN);
    signal(SIGINT,  [](<span class="kw">int</span>) { g_quit = <span class="nb">1</span>; });

    <span class="cm">// Own TCP server (raw POSIX)</span>
    <span class="kw">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="nb">0</span>);
    <span class="kw">int</span> opt = <span class="nb">1</span>;
    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="kw">sizeof</span>(opt));

    <span class="kw">struct</span> sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(<span class="nb">8080</span>);
    addr.sin_addr.s_addr = INADDR_ANY;
    bind(sock, (<span class="kw">struct</span> sockaddr*)&amp;addr, <span class="kw">sizeof</span>(addr));
    listen(sock, <span class="nb">128</span>);

    <span class="cm">// Register with daemon</span>
    <span class="kw">if</span> (socketley::<span class="fn">daemon_attach</span>(<span class="st">"ext_service"</span>, <span class="st">"server"</span>, <span class="nb">8080</span>))
        printf(<span class="st">"registered with daemon\n"</span>);
    <span class="kw">else</span>
        printf(<span class="st">"daemon not running (standalone mode)\n"</span>);

    <span class="cm">// Accept loop</span>
    <span class="kw">struct</span> pollfd pfd{};
    pfd.fd = sock; pfd.events = POLLIN;

    <span class="kw">while</span> (!g_quit) {
        <span class="kw">if</span> (poll(&amp;pfd, <span class="nb">1</span>, <span class="nb">500</span>) &lt;= <span class="nb">0</span>) <span class="kw">continue</span>;
        <span class="kw">int</span> client = accept(sock, <span class="kw">nullptr</span>, <span class="kw">nullptr</span>);
        <span class="kw">if</span> (client &lt; <span class="nb">0</span>) <span class="kw">continue</span>;

        <span class="kw">char</span> buf[<span class="nb">4096</span>];
        ssize_t n = read(client, buf, <span class="kw">sizeof</span>(buf) - <span class="nb">1</span>);
        <span class="kw">if</span> (n &gt; <span class="nb">0</span>) {
            buf[n] = <span class="st">'\0'</span>;
            std::string resp = <span class="st">"[ext_service] "</span> + std::string(buf, n) + <span class="st">"\n"</span>;
            <span class="kw">if</span> (write(client, resp.data(), resp.size()) &lt; <span class="nb">0</span>) {}
        }
        close(client);
    }

    close(sock);
    socketley::<span class="fn">daemon_detach</span>();  <span class="cm">// also called via atexit()</span>
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++17 08_attach_service.cpp -Iinclude/linux -o attach_service</code></pre>
<p><strong>Test:</strong></p>
<pre><code>socketley ls                         <span class="cm"># shows "ext_service"</span>
echo <span class="st">"hello"</span> | nc -q1 127.0.0.1 8080  <span class="cm"># [ext_service] hello</span></code></pre>
</div>

<!-- ── Mixed: Engine + Attach ── -->
<h2 id="exsdk-mixed">Mixed: Engine + Attach</h2>
<p>Combine Tier 2 (embedded engine) with Tier 3 (daemon registration) for the best of both worlds.</p>

<div class="method-card" id="exsdk-fullstack">
<div class="method-header">
  <span class="method-name">Full Stack</span>
  <span class="badge badge-tier2">Tier 2</span>
  <span class="badge badge-tier3">Tier 3</span>
</div>
<p class="method-desc">Runs its own io_uring event loop with a server + cache, AND registers both with the daemon. Your binary gets maximum performance from the embedded engine while remaining visible to <code>socketley ls</code> and <code>socketley stats</code>.</p>

<pre><code><span class="kw">#include</span> <span class="st">&lt;socketley/server.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;socketley/cache.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;socketley/attach.h&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;csignal&gt;</span>
<span class="kw">#include</span> <span class="st">&lt;cstdio&gt;</span>

<span class="kw">static</span> event_loop* g_loop = <span class="kw">nullptr</span>;

<span class="kw">int</span> <span class="fn">main</span>()
{
    signal(SIGPIPE, SIG_IGN);
    event_loop loop; loop.<span class="fn">init</span>();
    g_loop = &amp;loop;
    runtime_manager mgr;

    <span class="cm">// Embedded cache + server (Tier 2)</span>
    mgr.<span class="fn">create</span>(runtime_cache, <span class="st">"app_cache"</span>);
    <span class="kw">auto</span>* cache = <span class="kw">static_cast</span>&lt;cache_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"app_cache"</span>));
    cache-&gt;<span class="fn">set_port</span>(<span class="nb">6379</span>);
    cache-&gt;<span class="fn">set_mode</span>(cache_mode_admin);
    cache-&gt;<span class="fn">set_runtime_manager</span>(&amp;mgr);
    cache-&gt;<span class="fn">set_event_loop</span>(&amp;loop);

    mgr.<span class="fn">create</span>(runtime_server, <span class="st">"app_srv"</span>);
    <span class="kw">auto</span>* srv = <span class="kw">static_cast</span>&lt;server_instance*&gt;(mgr.<span class="fn">get</span>(<span class="st">"app_srv"</span>));
    srv-&gt;<span class="fn">set_port</span>(<span class="nb">9000</span>);
    srv-&gt;<span class="fn">set_mode</span>(mode_inout);
    srv-&gt;<span class="fn">set_cache_name</span>(<span class="st">"app_cache"</span>);
    srv-&gt;<span class="fn">set_runtime_manager</span>(&amp;mgr);
    srv-&gt;<span class="fn">set_event_loop</span>(&amp;loop);

    srv-&gt;<span class="fn">set_on_client_message</span>([srv](<span class="kw">int</span> fd, std::string_view msg) {
        printf(<span class="st">"[full] %d: %.*s\n"</span>, fd, (<span class="kw">int</span>)msg.size(), msg.data());
        srv-&gt;<span class="fn">lua_broadcast</span>(msg);
    });

    mgr.<span class="fn">start</span>(<span class="st">"app_cache"</span>, loop);
    mgr.<span class="fn">start</span>(<span class="st">"app_srv"</span>, loop);

    <span class="cm">// Register with daemon (Tier 3)</span>
    socketley::<span class="fn">daemon_attach</span>(<span class="st">"app_srv"</span>, <span class="st">"server"</span>, <span class="nb">9000</span>);

    <span class="cm">// Attach second runtime manually</span>
    <span class="kw">bool</span> cache_attached = <span class="kw">false</span>;
    {
        std::string cmd = <span class="st">"attach cache app_cache 6379 --pid "</span>
                        + std::to_string(getpid());
        <span class="kw">auto</span> r = socketley::ctl::<span class="fn">command</span>(cmd);
        cache_attached = (r.exit_code == <span class="nb">0</span>);
    }

    printf(<span class="st">"server :9000, cache :6379 (check: socketley ls)\n"</span>);

    signal(SIGINT,  [](<span class="kw">int</span>) { g_loop-&gt;<span class="fn">request_stop</span>(); });
    signal(SIGTERM, [](<span class="kw">int</span>) { g_loop-&gt;<span class="fn">request_stop</span>(); });
    loop.<span class="fn">run</span>();

    mgr.<span class="fn">stop_all</span>(loop);
    <span class="kw">if</span> (cache_attached)
        socketley::ctl::<span class="fn">command</span>(<span class="st">"remove app_cache"</span>);
    <span class="cm">// daemon_detach() auto-called for app_srv via atexit()</span>
}</code></pre>

<p><strong>Compile:</strong></p>
<pre><code>g++ -std=c++23 09_full_stack.cpp -I. -Iinclude/linux -Lbin/Release -lsocketley_sdk -luring -lssl -lcrypto -o full_stack</code></pre>
<p><strong>Test:</strong></p>
<pre><code>socketley ls                                     <span class="cm"># shows app_srv + app_cache</span>
echo <span class="st">"hello"</span>         | nc -q1 127.0.0.1 9000    <span class="cm"># broadcast</span>
echo <span class="st">"cache set k v"</span> | nc -q1 127.0.0.1 9000    <span class="cm"># cache through server</span>
echo <span class="st">"get k"</span>          | nc -q1 127.0.0.1 6379    <span class="cm"># direct cache: "v"</span></code></pre>
<p><strong>Key concept:</strong> <code>daemon_attach()</code> registers one name via <code>atexit()</code>. For additional runtimes, use <code>socketley::ctl::command("attach ...")</code> and manually clean up on shutdown.</p>
</div>

</div><!-- #content-examples-sdk -->

<script src="js/app.js"></script>
</body>
</html>
